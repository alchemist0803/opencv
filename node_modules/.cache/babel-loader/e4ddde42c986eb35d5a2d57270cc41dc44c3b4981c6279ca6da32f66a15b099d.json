{"ast":null,"code":"'use strict';\n\nvar FFT = require('./fftlib');\nvar FFTUtils = {\n  DEBUG: false,\n  /**\n   * Calculates the inverse of a 2D Fourier transform\n   *\n   * @param ft\n   * @param ftRows\n   * @param ftCols\n   * @return\n   */\n  ifft2DArray: function (ft, ftRows, ftCols) {\n    var tempTransform = new Array(ftRows * ftCols);\n    var nRows = ftRows / 2;\n    var nCols = (ftCols - 1) * 2;\n    // reverse transform columns\n    FFT.init(nRows);\n    var tmpCols = {\n      re: new Array(nRows),\n      im: new Array(nRows)\n    };\n    for (var iCol = 0; iCol < ftCols; iCol++) {\n      for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n        tmpCols.re[iRow] = ft[iRow * 2 * ftCols + iCol];\n        tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n      }\n      //Unnormalized inverse transform\n      FFT.bt(tmpCols.re, tmpCols.im);\n      for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n        tempTransform[iRow * 2 * ftCols + iCol] = tmpCols.re[iRow];\n        tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n      }\n    }\n\n    // reverse row transform\n    var finalTransform = new Array(nRows * nCols);\n    FFT.init(nCols);\n    var tmpRows = {\n      re: new Array(nCols),\n      im: new Array(nCols)\n    };\n    var scale = nCols * nRows;\n    for (var iRow = 0; iRow < ftRows; iRow += 2) {\n      tmpRows.re[0] = tempTransform[iRow * ftCols];\n      tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n      for (var iCol = 1; iCol < ftCols; iCol++) {\n        tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n        tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n        tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n        tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n      }\n      //Unnormalized inverse transform\n      FFT.bt(tmpRows.re, tmpRows.im);\n      var indexB = iRow / 2 * nCols;\n      for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n        finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n      }\n    }\n    return finalTransform;\n  },\n  /**\n   * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n   * assumed that both nRows and nCols are a power of two\n   *\n   * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n   * even rows contain the real part and the odd rows the imaginary part of the\n   * transform\n   * @param data\n   * @param nRows\n   * @param nCols\n   * @return\n   */\n  fft2DArray: function (data, nRows, nCols, opt) {\n    var options = Object.assign({}, {\n      inplace: true\n    });\n    var ftCols = nCols / 2 + 1;\n    var ftRows = nRows * 2;\n    var tempTransform = new Array(ftRows * ftCols);\n    FFT.init(nCols);\n    // transform rows\n    var tmpRows = {\n      re: new Array(nCols),\n      im: new Array(nCols)\n    };\n    var row1 = {\n      re: new Array(nCols),\n      im: new Array(nCols)\n    };\n    var row2 = {\n      re: new Array(nCols),\n      im: new Array(nCols)\n    };\n    var index, iRow0, iRow1, iRow2, iRow3;\n    for (var iRow = 0; iRow < nRows / 2; iRow++) {\n      index = iRow * 2 * nCols;\n      tmpRows.re = data.slice(index, index + nCols);\n      index = (iRow * 2 + 1) * nCols;\n      tmpRows.im = data.slice(index, index + nCols);\n      FFT.fft1d(tmpRows.re, tmpRows.im);\n      this.reconstructTwoRealFFT(tmpRows, row1, row2);\n      //Now lets put back the result into the output array\n      iRow0 = iRow * 4 * ftCols;\n      iRow1 = (iRow * 4 + 1) * ftCols;\n      iRow2 = (iRow * 4 + 2) * ftCols;\n      iRow3 = (iRow * 4 + 3) * ftCols;\n      for (var k = ftCols - 1; k >= 0; k--) {\n        tempTransform[iRow0 + k] = row1.re[k];\n        tempTransform[iRow1 + k] = row1.im[k];\n        tempTransform[iRow2 + k] = row2.re[k];\n        tempTransform[iRow3 + k] = row2.im[k];\n      }\n    }\n\n    //console.log(tempTransform);\n    row1 = null;\n    row2 = null;\n    // transform columns\n    var finalTransform = new Array(ftRows * ftCols);\n    FFT.init(nRows);\n    var tmpCols = {\n      re: new Array(nRows),\n      im: new Array(nRows)\n    };\n    for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n      for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n        tmpCols.re[iRow] = tempTransform[iRow * 2 * ftCols + iCol];\n        tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n        //TODO Chech why this happens\n        if (isNaN(tmpCols.re[iRow])) {\n          tmpCols.re[iRow] = 0;\n        }\n        if (isNaN(tmpCols.im[iRow])) {\n          tmpCols.im[iRow] = 0;\n        }\n      }\n      FFT.fft1d(tmpCols.re, tmpCols.im);\n      for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n        finalTransform[iRow * 2 * ftCols + iCol] = tmpCols.re[iRow];\n        finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n      }\n    }\n\n    //console.log(finalTransform);\n    return finalTransform;\n  },\n  /**\n   *\n   * @param fourierTransform\n   * @param realTransform1\n   * @param realTransform2\n   *\n   * Reconstructs the individual Fourier transforms of two simultaneously\n   * transformed series. Based on the Symmetry relationships (the asterisk\n   * denotes the complex conjugate)\n   *\n   * F_{N-n} = F_n^{*} for a purely real f transformed to F\n   *\n   * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n   *\n   */\n  reconstructTwoRealFFT: function (fourierTransform, realTransform1, realTransform2) {\n    var length = fourierTransform.re.length;\n\n    // the components n=0 are trivial\n    realTransform1.re[0] = fourierTransform.re[0];\n    realTransform1.im[0] = 0.0;\n    realTransform2.re[0] = fourierTransform.im[0];\n    realTransform2.im[0] = 0.0;\n    var rm, rp, im, ip, j;\n    for (var i = length / 2; i > 0; i--) {\n      j = length - i;\n      rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n      rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n      im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n      ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n      realTransform1.re[i] = rp;\n      realTransform1.im[i] = im;\n      realTransform1.re[j] = rp;\n      realTransform1.im[j] = -im;\n      realTransform2.re[i] = ip;\n      realTransform2.im[i] = -rm;\n      realTransform2.re[j] = ip;\n      realTransform2.im[j] = rm;\n    }\n  },\n  /**\n   * In place version of convolute 2D\n   *\n   * @param ftSignal\n   * @param ftFilter\n   * @param ftRows\n   * @param ftCols\n   * @return\n   */\n  convolute2DI: function (ftSignal, ftFilter, ftRows, ftCols) {\n    var re, im;\n    for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n      for (var iCol = 0; iCol < ftCols; iCol++) {\n        //\n        re = ftSignal[iRow * 2 * ftCols + iCol] * ftFilter[iRow * 2 * ftCols + iCol] - ftSignal[(iRow * 2 + 1) * ftCols + iCol] * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n        im = ftSignal[iRow * 2 * ftCols + iCol] * ftFilter[(iRow * 2 + 1) * ftCols + iCol] + ftSignal[(iRow * 2 + 1) * ftCols + iCol] * ftFilter[iRow * 2 * ftCols + iCol];\n        //\n        ftSignal[iRow * 2 * ftCols + iCol] = re;\n        ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n      }\n    }\n  },\n  /**\n   *\n   * @param data\n   * @param kernel\n   * @param nRows\n   * @param nCols\n   * @returns {*}\n   */\n  convolute: function (data, kernel, nRows, nCols, opt) {\n    var ftSpectrum = new Array(nCols * nRows);\n    for (var i = 0; i < nRows * nCols; i++) {\n      ftSpectrum[i] = data[i];\n    }\n    ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n    var dimR = kernel.length;\n    var dimC = kernel[0].length;\n    var ftFilterData = new Array(nCols * nRows);\n    for (var i = 0; i < nCols * nRows; i++) {\n      ftFilterData[i] = 0;\n    }\n    var iRow, iCol;\n    var shiftR = Math.floor((dimR - 1) / 2);\n    var shiftC = Math.floor((dimC - 1) / 2);\n    for (var ir = 0; ir < dimR; ir++) {\n      iRow = (ir - shiftR + nRows) % nRows;\n      for (var ic = 0; ic < dimC; ic++) {\n        iCol = (ic - shiftC + nCols) % nCols;\n        ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n      }\n    }\n    ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n    var ftRows = nRows * 2;\n    var ftCols = nCols / 2 + 1;\n    this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n    return this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n  },\n  toRadix2: function (data, nRows, nCols) {\n    var i, j, irow, icol;\n    var cols = nCols,\n      rows = nRows,\n      prows = 0,\n      pcols = 0;\n    if (!(nCols !== 0 && (nCols & nCols - 1) === 0)) {\n      //Then we have to make a pading to next radix2\n      cols = 0;\n      while (nCols >> ++cols != 0);\n      cols = 1 << cols;\n      pcols = cols - nCols;\n    }\n    if (!(nRows !== 0 && (nRows & nRows - 1) === 0)) {\n      //Then we have to make a pading to next radix2\n      rows = 0;\n      while (nRows >> ++rows != 0);\n      rows = 1 << rows;\n      prows = (rows - nRows) * cols;\n    }\n    if (rows == nRows && cols == nCols)\n      //Do nothing. Returns the same input!!! Be careful\n      return {\n        data: data,\n        rows: nRows,\n        cols: nCols\n      };\n    var output = new Array(rows * cols);\n    var shiftR = Math.floor((rows - nRows) / 2) - nRows;\n    var shiftC = Math.floor((cols - nCols) / 2) - nCols;\n    for (i = 0; i < rows; i++) {\n      irow = i * cols;\n      icol = (i - shiftR) % nRows * nCols;\n      for (j = 0; j < cols; j++) {\n        output[irow + j] = data[icol + (j - shiftC) % nCols];\n      }\n    }\n    return {\n      data: output,\n      rows: rows,\n      cols: cols\n    };\n  },\n  /**\n   * Crop the given matrix to fit the corresponding number of rows and columns\n   */\n  crop: function (data, rows, cols, nRows, nCols, opt) {\n    if (rows == nRows && cols == nCols)\n      //Do nothing. Returns the same input!!! Be careful\n      return data;\n    var options = Object.assign({}, opt);\n    var output = new Array(nCols * nRows);\n    var shiftR = Math.floor((rows - nRows) / 2);\n    var shiftC = Math.floor((cols - nCols) / 2);\n    var destinyRow, sourceRow, i, j;\n    for (i = 0; i < nRows; i++) {\n      destinyRow = i * nCols;\n      sourceRow = (i + shiftR) * cols;\n      for (j = 0; j < nCols; j++) {\n        output[destinyRow + j] = data[sourceRow + (j + shiftC)];\n      }\n    }\n    return output;\n  }\n};\nmodule.exports = FFTUtils;","map":{"version":3,"names":["FFT","require","FFTUtils","DEBUG","ifft2DArray","ft","ftRows","ftCols","tempTransform","Array","nRows","nCols","init","tmpCols","re","im","iCol","iRow","bt","finalTransform","tmpRows","scale","indexB","fft2DArray","data","opt","options","Object","assign","inplace","row1","row2","index","iRow0","iRow1","iRow2","iRow3","slice","fft1d","reconstructTwoRealFFT","k","isNaN","fourierTransform","realTransform1","realTransform2","length","rm","rp","ip","j","i","convolute2DI","ftSignal","ftFilter","convolute","kernel","ftSpectrum","dimR","dimC","ftFilterData","shiftR","Math","floor","shiftC","ir","ic","toRadix2","irow","icol","cols","rows","prows","pcols","output","crop","destinyRow","sourceRow","module","exports"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/ml-fft/src/FFTUtils.js"],"sourcesContent":["'use strict'\n\nvar FFT = require('./fftlib');\n\nvar FFTUtils= {\n    DEBUG : false,\n\n    /**\n     * Calculates the inverse of a 2D Fourier transform\n     *\n     * @param ft\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    ifft2DArray : function(ft, ftRows, ftCols){\n        var tempTransform = new Array(ftRows * ftCols);\n        var nRows = ftRows / 2;\n        var nCols = (ftCols - 1) * 2;\n        // reverse transform columns\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = 0; iCol < ftCols; iCol++) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = ft[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = ft[(iRow * 2 + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tempTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                tempTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        // reverse row transform\n        var finalTransform = new Array(nRows * nCols);\n        FFT.init(nCols);\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var scale = nCols * nRows;\n        for (var iRow = 0; iRow < ftRows; iRow += 2) {\n            tmpRows.re[0] = tempTransform[iRow * ftCols];\n            tmpRows.im[0] = tempTransform[(iRow + 1) * ftCols];\n            for (var iCol = 1; iCol < ftCols; iCol++) {\n                tmpRows.re[iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[iCol] = tempTransform[(iRow + 1) * ftCols + iCol];\n                tmpRows.re[nCols - iCol] = tempTransform[iRow * ftCols + iCol];\n                tmpRows.im[nCols - iCol] = -tempTransform[(iRow + 1) * ftCols + iCol];\n            }\n            //Unnormalized inverse transform\n            FFT.bt(tmpRows.re, tmpRows.im);\n\n            var indexB = (iRow / 2) * nCols;\n            for (var iCol = nCols - 1; iCol >= 0; iCol--) {\n                finalTransform[indexB + iCol] = tmpRows.re[iCol] / scale;\n            }\n        }\n        return finalTransform;\n    },\n    /**\n     * Calculates the fourier transform of a matrix of size (nRows,nCols) It is\n     * assumed that both nRows and nCols are a power of two\n     *\n     * On exit the matrix has dimensions (nRows * 2, nCols / 2 + 1) where the\n     * even rows contain the real part and the odd rows the imaginary part of the\n     * transform\n     * @param data\n     * @param nRows\n     * @param nCols\n     * @return\n     */\n    fft2DArray:function(data, nRows, nCols, opt) {\n        var options = Object.assign({},{inplace:true})\n        var ftCols = (nCols / 2 + 1);\n        var ftRows = nRows * 2;\n        var tempTransform = new Array(ftRows * ftCols);\n        FFT.init(nCols);\n        // transform rows\n        var tmpRows = {re: new Array(nCols), im: new Array(nCols)};\n        var row1 = {re: new Array(nCols), im: new Array(nCols)}\n        var row2 = {re: new Array(nCols), im: new Array(nCols)}\n        var index, iRow0, iRow1, iRow2, iRow3;\n        for (var iRow = 0; iRow < nRows / 2; iRow++) {\n            index = (iRow * 2) * nCols;\n            tmpRows.re = data.slice(index, index + nCols);\n\n            index = (iRow * 2 + 1) * nCols;\n            tmpRows.im = data.slice(index, index + nCols);\n\n            FFT.fft1d(tmpRows.re, tmpRows.im);\n\n            this.reconstructTwoRealFFT(tmpRows, row1, row2);\n            //Now lets put back the result into the output array\n            iRow0 = (iRow * 4) * ftCols;\n            iRow1 = (iRow * 4 + 1) * ftCols;\n            iRow2 = (iRow * 4 + 2) * ftCols;\n            iRow3 = (iRow * 4 + 3) * ftCols;\n            for (var k = ftCols - 1; k >= 0; k--) {\n                tempTransform[iRow0 + k] = row1.re[k];\n                tempTransform[iRow1 + k] = row1.im[k];\n                tempTransform[iRow2 + k] = row2.re[k];\n                tempTransform[iRow3 + k] = row2.im[k];\n            }\n        }\n\n        //console.log(tempTransform);\n        row1 = null;\n        row2 = null;\n        // transform columns\n        var finalTransform = new Array(ftRows * ftCols);\n\n        FFT.init(nRows);\n        var tmpCols = {re: new Array(nRows), im: new Array(nRows)};\n        for (var iCol = ftCols - 1; iCol >= 0; iCol--) {\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                tmpCols.re[iRow] = tempTransform[(iRow * 2) * ftCols + iCol];\n                tmpCols.im[iRow] = tempTransform[(iRow * 2 + 1) * ftCols + iCol];\n                //TODO Chech why this happens\n                if(isNaN(tmpCols.re[iRow])){\n                    tmpCols.re[iRow]=0;\n                }\n                if(isNaN(tmpCols.im[iRow])){\n                    tmpCols.im[iRow]=0;\n                }\n            }\n            FFT.fft1d(tmpCols.re, tmpCols.im);\n            for (var iRow = nRows - 1; iRow >= 0; iRow--) {\n                finalTransform[(iRow * 2) * ftCols + iCol] = tmpCols.re[iRow];\n                finalTransform[(iRow * 2 + 1) * ftCols + iCol] = tmpCols.im[iRow];\n            }\n        }\n\n        //console.log(finalTransform);\n        return finalTransform;\n\n    },\n    /**\n     *\n     * @param fourierTransform\n     * @param realTransform1\n     * @param realTransform2\n     *\n     * Reconstructs the individual Fourier transforms of two simultaneously\n     * transformed series. Based on the Symmetry relationships (the asterisk\n     * denotes the complex conjugate)\n     *\n     * F_{N-n} = F_n^{*} for a purely real f transformed to F\n     *\n     * G_{N-n} = G_n^{*} for a purely imaginary g transformed to G\n     *\n     */\n    reconstructTwoRealFFT:function(fourierTransform, realTransform1, realTransform2) {\n        var length = fourierTransform.re.length;\n\n        // the components n=0 are trivial\n        realTransform1.re[0] = fourierTransform.re[0];\n        realTransform1.im[0] = 0.0;\n        realTransform2.re[0] = fourierTransform.im[0];\n        realTransform2.im[0] = 0.0;\n        var rm, rp, im, ip, j;\n        for (var i = length / 2; i > 0; i--) {\n            j = length - i;\n            rm = 0.5 * (fourierTransform.re[i] - fourierTransform.re[j]);\n            rp = 0.5 * (fourierTransform.re[i] + fourierTransform.re[j]);\n            im = 0.5 * (fourierTransform.im[i] - fourierTransform.im[j]);\n            ip = 0.5 * (fourierTransform.im[i] + fourierTransform.im[j]);\n            realTransform1.re[i] = rp;\n            realTransform1.im[i] = im;\n            realTransform1.re[j] = rp;\n            realTransform1.im[j] = -im;\n            realTransform2.re[i] = ip;\n            realTransform2.im[i] = -rm;\n            realTransform2.re[j] = ip;\n            realTransform2.im[j] = rm;\n        }\n    },\n\n    /**\n     * In place version of convolute 2D\n     *\n     * @param ftSignal\n     * @param ftFilter\n     * @param ftRows\n     * @param ftCols\n     * @return\n     */\n    convolute2DI:function(ftSignal, ftFilter, ftRows, ftCols) {\n        var re, im;\n        for (var iRow = 0; iRow < ftRows / 2; iRow++) {\n            for (var iCol = 0; iCol < ftCols; iCol++) {\n                //\n                re = ftSignal[(iRow * 2) * ftCols + iCol]\n                    * ftFilter[(iRow * 2) * ftCols + iCol]\n                    - ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol];\n                im = ftSignal[(iRow * 2) * ftCols + iCol]\n                    * ftFilter[(iRow * 2 + 1) * ftCols + iCol]\n                    + ftSignal[(iRow * 2 + 1) * ftCols + iCol]\n                    * ftFilter[(iRow * 2) * ftCols + iCol];\n                //\n                ftSignal[(iRow * 2) * ftCols + iCol] = re;\n                ftSignal[(iRow * 2 + 1) * ftCols + iCol] = im;\n            }\n        }\n    },\n    /**\n     *\n     * @param data\n     * @param kernel\n     * @param nRows\n     * @param nCols\n     * @returns {*}\n     */\n    convolute:function(data, kernel, nRows, nCols, opt) {\n        var ftSpectrum = new Array(nCols * nRows);\n        for (var i = 0; i<nRows * nCols; i++) {\n            ftSpectrum[i] = data[i];\n        }\n\n        ftSpectrum = this.fft2DArray(ftSpectrum, nRows, nCols);\n\n\n        var dimR = kernel.length;\n        var dimC = kernel[0].length;\n        var ftFilterData = new Array(nCols * nRows);\n        for(var i = 0; i < nCols * nRows; i++) {\n            ftFilterData[i] = 0;\n        }\n\n        var iRow, iCol;\n        var shiftR = Math.floor((dimR - 1) / 2);\n        var shiftC = Math.floor((dimC - 1) / 2);\n        for (var ir = 0; ir < dimR; ir++) {\n            iRow = (ir - shiftR + nRows) % nRows;\n            for (var ic = 0; ic < dimC; ic++) {\n                iCol = (ic - shiftC + nCols) % nCols;\n                ftFilterData[iRow * nCols + iCol] = kernel[ir][ic];\n            }\n        }\n        ftFilterData = this.fft2DArray(ftFilterData, nRows, nCols);\n\n        var ftRows = nRows * 2;\n        var ftCols = nCols / 2 + 1;\n        this.convolute2DI(ftSpectrum, ftFilterData, ftRows, ftCols);\n\n        return this.ifft2DArray(ftSpectrum, ftRows, ftCols);\n    },\n\n\n    toRadix2:function(data, nRows, nCols) {\n        var i, j, irow, icol;\n        var cols = nCols, rows = nRows, prows=0, pcols=0;\n        if(!(nCols !== 0 && (nCols & (nCols - 1)) === 0)) {\n            //Then we have to make a pading to next radix2\n            cols = 0;\n            while((nCols>>++cols)!=0);\n            cols=1<<cols;\n            pcols = cols-nCols;\n        }\n        if(!(nRows !== 0 && (nRows & (nRows - 1)) === 0)) {\n            //Then we have to make a pading to next radix2\n            rows = 0;\n            while((nRows>>++rows)!=0);\n            rows=1<<rows;\n            prows = (rows-nRows)*cols;\n        }\n        if(rows==nRows&&cols==nCols)//Do nothing. Returns the same input!!! Be careful\n            return {data:data, rows:nRows, cols:nCols};\n\n        var output = new Array(rows*cols);\n        var shiftR = Math.floor((rows-nRows)/2)-nRows;\n        var shiftC = Math.floor((cols-nCols)/2)-nCols;\n\n        for( i = 0; i < rows; i++) {\n            irow = i*cols;\n            icol = ((i-shiftR) % nRows) * nCols;\n            for( j = 0; j < cols; j++) {\n                output[irow+j] = data[(icol+(j-shiftC) % nCols) ];\n            }\n        }\n        return {data:output, rows:rows, cols:cols};\n    },\n\n    /**\n     * Crop the given matrix to fit the corresponding number of rows and columns\n     */\n    crop:function(data, rows, cols, nRows, nCols, opt) {\n\n        if(rows == nRows && cols == nCols)//Do nothing. Returns the same input!!! Be careful\n            return data;\n\n        var options = Object.assign({}, opt);\n\n        var output = new Array(nCols*nRows);\n\n        var shiftR = Math.floor((rows-nRows)/2);\n        var shiftC = Math.floor((cols-nCols)/2);\n        var destinyRow, sourceRow, i, j;\n        for( i = 0; i < nRows; i++) {\n            destinyRow = i*nCols;\n            sourceRow = (i+shiftR)*cols;\n            for( j = 0;j < nCols; j++) {\n                output[destinyRow+j] = data[sourceRow+(j+shiftC)];\n            }\n        }\n\n        return output;\n    }\n}\n\nmodule.exports = FFTUtils;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}