{"ast":null,"code":"import Image from '../Image';\n\n/**\n * Crops the image\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.x=0] - x coordinate to place the zero of the new image\n * @param {number} [options.y=0] - y coordinate to place the zero of the new image\n * @param {number} [options.width=this.width-x] - width of the new image\n * @param {number} [options.height=this.height-y] - height of the new image\n * @return {Image} The new cropped image\n * @example\n * var cropped = image.crop({\n *   x:0,\n *   y:0\n * });\n */\nexport default function crop(options = {}) {\n  let {\n    x = 0,\n    y = 0,\n    width = this.width - x,\n    height = this.height - y\n  } = options;\n  this.checkProcessable('crop', {\n    bitDepth: [1, 8, 16]\n  });\n  x = Math.round(x);\n  y = Math.round(y);\n  width = Math.round(width);\n  height = Math.round(height);\n  if (x > this.width - 1 || y > this.height - 1) {\n    throw new RangeError(`crop: origin (x:${x}, y:${y}) out of range (${this.width - 1}; ${this.height - 1})`);\n  }\n  if (width <= 0 || height <= 0) {\n    throw new RangeError(`crop: width and height (width:${width}; height:${height}) must be positive numbers`);\n  }\n  if (x < 0 || y < 0) {\n    throw new RangeError(`crop: x and y (x:${x}, y:${y}) must be positive numbers`);\n  }\n  if (width > this.width - x || height > this.height - y) {\n    throw new RangeError(`crop: (x: ${x}, y:${y}, width:${width}, height:${height}) size is out of range`);\n  }\n  let result = this;\n  if (this.bitDepth === 1) {\n    const newImage = new Image(width, height, {\n      kind: 'BINARY',\n      parent: this\n    });\n    result = cropBinary(this, newImage, x, y, width, height);\n  } else {\n    const newImage = Image.createFrom(this, {\n      width,\n      height,\n      position: [x, y]\n    });\n    result = cropDefault(this, newImage, x, y, width, height);\n  }\n  return result;\n}\nfunction cropDefault(img, newImage, x, y, width, height) {\n  let xWidth = width * img.channels;\n  let y1 = y + height;\n  let ptr = 0; // pointer for new array\n\n  let jLeft = x * img.channels;\n  for (let i = y; i < y1; i++) {\n    let j = i * img.width * img.channels + jLeft;\n    let jL = j + xWidth;\n    for (; j < jL; j++) {\n      newImage.data[ptr++] = img.data[j];\n    }\n  }\n  return newImage;\n}\nfunction cropBinary(img, newImage, x, y, width, height) {\n  let xWidth = width * img.channels;\n  let y1 = y + height;\n  let ptr = 0; // pointer for new array\n\n  let jLeft = x * img.channels;\n  for (let i = y; i < y1; i++) {\n    let j = i * img.width * img.channels + jLeft;\n    let jL = j + xWidth;\n    for (; j < jL; j++) {\n      if (img.getBit(j)) {\n        newImage.setBit(ptr);\n      }\n      ++ptr;\n    }\n  }\n  return newImage;\n}","map":{"version":3,"names":["Image","crop","options","x","y","width","height","checkProcessable","bitDepth","Math","round","RangeError","result","newImage","kind","parent","cropBinary","createFrom","position","cropDefault","img","xWidth","channels","y1","ptr","jLeft","i","j","jL","data","getBit","setBit"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/crop.js"],"sourcesContent":["import Image from '../Image';\n\n/**\n * Crops the image\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.x=0] - x coordinate to place the zero of the new image\n * @param {number} [options.y=0] - y coordinate to place the zero of the new image\n * @param {number} [options.width=this.width-x] - width of the new image\n * @param {number} [options.height=this.height-y] - height of the new image\n * @return {Image} The new cropped image\n * @example\n * var cropped = image.crop({\n *   x:0,\n *   y:0\n * });\n */\nexport default function crop(options = {}) {\n  let {\n    x = 0,\n    y = 0,\n    width = this.width - x,\n    height = this.height - y,\n  } = options;\n  this.checkProcessable('crop', {\n    bitDepth: [1, 8, 16],\n  });\n  x = Math.round(x);\n  y = Math.round(y);\n  width = Math.round(width);\n  height = Math.round(height);\n\n  if (x > this.width - 1 || y > this.height - 1) {\n    throw new RangeError(\n      `crop: origin (x:${x}, y:${y}) out of range (${this.width - 1}; ${\n        this.height - 1\n      })`,\n    );\n  }\n\n  if (width <= 0 || height <= 0) {\n    throw new RangeError(\n      `crop: width and height (width:${width}; height:${height}) must be positive numbers`,\n    );\n  }\n\n  if (x < 0 || y < 0) {\n    throw new RangeError(\n      `crop: x and y (x:${x}, y:${y}) must be positive numbers`,\n    );\n  }\n\n  if (width > this.width - x || height > this.height - y) {\n    throw new RangeError(\n      `crop: (x: ${x}, y:${y}, width:${width}, height:${height}) size is out of range`,\n    );\n  }\n\n  let result = this;\n  if (this.bitDepth === 1) {\n    const newImage = new Image(width, height, {\n      kind: 'BINARY',\n      parent: this,\n    });\n    result = cropBinary(this, newImage, x, y, width, height);\n  } else {\n    const newImage = Image.createFrom(this, {\n      width,\n      height,\n      position: [x, y],\n    });\n    result = cropDefault(this, newImage, x, y, width, height);\n  }\n\n  return result;\n}\n\nfunction cropDefault(img, newImage, x, y, width, height) {\n  let xWidth = width * img.channels;\n  let y1 = y + height;\n  let ptr = 0; // pointer for new array\n\n  let jLeft = x * img.channels;\n\n  for (let i = y; i < y1; i++) {\n    let j = i * img.width * img.channels + jLeft;\n    let jL = j + xWidth;\n\n    for (; j < jL; j++) {\n      newImage.data[ptr++] = img.data[j];\n    }\n  }\n\n  return newImage;\n}\n\nfunction cropBinary(img, newImage, x, y, width, height) {\n  let xWidth = width * img.channels;\n  let y1 = y + height;\n  let ptr = 0; // pointer for new array\n\n  let jLeft = x * img.channels;\n\n  for (let i = y; i < y1; i++) {\n    let j = i * img.width * img.channels + jLeft;\n    let jL = j + xWidth;\n\n    for (; j < jL; j++) {\n      if (img.getBit(j)) {\n        newImage.setBit(ptr);\n      }\n      ++ptr;\n    }\n  }\n\n  return newImage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}