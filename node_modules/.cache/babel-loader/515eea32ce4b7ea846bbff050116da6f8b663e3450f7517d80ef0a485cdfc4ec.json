{"ast":null,"code":"/**\n * Paint a polygon defined by an array of points.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>} [options.color=[max,0,0]] - Array of 3 elements (R, G, B), default is red.\n * @param {boolean} [options.filled=false] - If you want the polygon to be filled or not.\n * @return {this} The original painted image\n */\nexport default function paintPolygon(points, options = {}) {\n  let {\n    color = [this.maxValue, 0, 0],\n    filled = false\n  } = options;\n  this.checkProcessable('paintPoints', {\n    bitDepth: [1, 8, 16]\n  });\n  options.closed = true;\n  let filteredPoints = deleteDouble(points);\n  if (filled === false) {\n    return this.paintPolyline(points, options);\n  } else {\n    let matrixBinary = Array(this.height);\n    for (let i = 0; i < this.height; i++) {\n      matrixBinary[i] = [];\n      for (let j = 0; j < this.width; j++) {\n        matrixBinary[i].push(0);\n      }\n    }\n    for (let p = 0; p < filteredPoints.length; p++) {\n      const line = lineBetweenTwoPoints(filteredPoints[p], filteredPoints[(p + 1) % filteredPoints.length]);\n      for (let y = 0; y < this.height; y++) {\n        for (let x = 0; x < this.width; x++) {\n          if (isAtTheRightOfTheLine(x, y, line, this.height)) {\n            matrixBinary[y][x] = matrixBinary[y][x] === 0 ? 1 : 0;\n          }\n        }\n      }\n    }\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (matrixBinary[y][x] === 1) {\n          if (this.bitDepth === 1) {\n            this.setBitXY(x, y);\n          } else {\n            let numberChannels = Math.min(this.channels, color.length);\n            let position = (x + y * this.width) * this.channels;\n            for (let channel = 0; channel < numberChannels; channel++) {\n              this.data[position + channel] = color[channel];\n            }\n          }\n        }\n      }\n    }\n    return this.paintPolyline(points, options);\n  }\n}\nfunction deleteDouble(points) {\n  let finalPoints = [];\n  for (let i = 0; i < points.length; i++) {\n    if (points[i][0] === points[(i + 1) % points.length][0] && points[i][1] === points[(i + 1) % points.length][1]) {\n      continue;\n    } else if (points[i][0] === points[(i - 1 + points.length) % points.length][0] && points[i][1] === points[(i - 1 + points.length) % points.length][1]) {\n      continue;\n    } else if (points[(i + 1) % points.length][0] === points[(i - 1 + points.length) % points.length][0] && points[(i - 1 + points.length) % points.length][1] === points[(i + 1) % points.length][1]) {\n      continue; // we don't consider this point only\n    } else {\n      finalPoints.push(points[i]);\n    }\n  }\n  return finalPoints;\n}\nfunction lineBetweenTwoPoints(p1, p2) {\n  if (p1[0] === p2[0]) {\n    return {\n      a: 0,\n      b: p1[0],\n      vertical: true\n    }; // we store the x of the vertical line into b\n  } else {\n    const coeffA = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    const coeffB = p1[1] - coeffA * p1[0];\n    return {\n      a: coeffA,\n      b: coeffB,\n      vertical: false\n    };\n  }\n}\nfunction isAtTheRightOfTheLine(x, y, line, height) {\n  if (line.vertical === true) {\n    return line.b <= x;\n  } else {\n    if (line.a === 0) {\n      return false;\n    } else {\n      const xline = (y - line.b) / line.a;\n      return xline < x && xline >= 0 && xline <= height;\n    }\n  }\n}","map":{"version":3,"names":["paintPolygon","points","options","color","maxValue","filled","checkProcessable","bitDepth","closed","filteredPoints","deleteDouble","paintPolyline","matrixBinary","Array","height","i","j","width","push","p","length","line","lineBetweenTwoPoints","y","x","isAtTheRightOfTheLine","setBitXY","numberChannels","Math","min","channels","position","channel","data","finalPoints","p1","p2","a","b","vertical","coeffA","coeffB","xline"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/operator/paintPolygon.js"],"sourcesContent":["/**\n * Paint a polygon defined by an array of points.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>} [options.color=[max,0,0]] - Array of 3 elements (R, G, B), default is red.\n * @param {boolean} [options.filled=false] - If you want the polygon to be filled or not.\n * @return {this} The original painted image\n */\nexport default function paintPolygon(points, options = {}) {\n  let { color = [this.maxValue, 0, 0], filled = false } = options;\n\n  this.checkProcessable('paintPoints', {\n    bitDepth: [1, 8, 16],\n  });\n\n  options.closed = true;\n\n  let filteredPoints = deleteDouble(points);\n  if (filled === false) {\n    return this.paintPolyline(points, options);\n  } else {\n    let matrixBinary = Array(this.height);\n    for (let i = 0; i < this.height; i++) {\n      matrixBinary[i] = [];\n      for (let j = 0; j < this.width; j++) {\n        matrixBinary[i].push(0);\n      }\n    }\n    for (let p = 0; p < filteredPoints.length; p++) {\n      const line = lineBetweenTwoPoints(\n        filteredPoints[p],\n        filteredPoints[(p + 1) % filteredPoints.length],\n      );\n      for (let y = 0; y < this.height; y++) {\n        for (let x = 0; x < this.width; x++) {\n          if (isAtTheRightOfTheLine(x, y, line, this.height)) {\n            matrixBinary[y][x] = matrixBinary[y][x] === 0 ? 1 : 0;\n          }\n        }\n      }\n    }\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        if (matrixBinary[y][x] === 1) {\n          if (this.bitDepth === 1) {\n            this.setBitXY(x, y);\n          } else {\n            let numberChannels = Math.min(this.channels, color.length);\n            let position = (x + y * this.width) * this.channels;\n            for (let channel = 0; channel < numberChannels; channel++) {\n              this.data[position + channel] = color[channel];\n            }\n          }\n        }\n      }\n    }\n    return this.paintPolyline(points, options);\n  }\n}\n\nfunction deleteDouble(points) {\n  let finalPoints = [];\n  for (let i = 0; i < points.length; i++) {\n    if (\n      points[i][0] === points[(i + 1) % points.length][0] &&\n      points[i][1] === points[(i + 1) % points.length][1]\n    ) {\n      continue;\n    } else if (\n      points[i][0] === points[(i - 1 + points.length) % points.length][0] &&\n      points[i][1] === points[(i - 1 + points.length) % points.length][1]\n    ) {\n      continue;\n    } else if (\n      points[(i + 1) % points.length][0] ===\n        points[(i - 1 + points.length) % points.length][0] &&\n      points[(i - 1 + points.length) % points.length][1] ===\n        points[(i + 1) % points.length][1]\n    ) {\n      continue; // we don't consider this point only\n    } else {\n      finalPoints.push(points[i]);\n    }\n  }\n  return finalPoints;\n}\n\nfunction lineBetweenTwoPoints(p1, p2) {\n  if (p1[0] === p2[0]) {\n    return { a: 0, b: p1[0], vertical: true }; // we store the x of the vertical line into b\n  } else {\n    const coeffA = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    const coeffB = p1[1] - coeffA * p1[0];\n    return { a: coeffA, b: coeffB, vertical: false };\n  }\n}\n\nfunction isAtTheRightOfTheLine(x, y, line, height) {\n  if (line.vertical === true) {\n    return line.b <= x;\n  } else {\n    if (line.a === 0) {\n      return false;\n    } else {\n      const xline = (y - line.b) / line.a;\n      return xline < x && xline >= 0 && xline <= height;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}