{"ast":null,"code":"import { Matrix, SVD, pseudoInverse } from 'ml-matrix';\nexport default class MultivariateLinearRegression {\n  constructor(x, y, options = {}) {\n    const {\n      intercept = true,\n      statistics = true\n    } = options;\n    this.statistics = statistics;\n    if (x === true) {\n      this.weights = y.weights;\n      this.inputs = y.inputs;\n      this.outputs = y.outputs;\n      this.intercept = y.intercept;\n    } else {\n      x = new Matrix(x);\n      y = new Matrix(y);\n      if (intercept) {\n        x.addColumn(new Array(x.rows).fill(1));\n      }\n      let xt = x.transpose();\n      const xx = xt.mmul(x);\n      const xy = xt.mmul(y);\n      const invxx = new SVD(xx).inverse();\n      const beta = xy.transpose().mmul(invxx).transpose();\n      this.weights = beta.to2DArray();\n      this.inputs = x.columns;\n      this.outputs = y.columns;\n      if (intercept) this.inputs--;\n      this.intercept = intercept;\n      if (statistics) {\n        /*\n         * Let's add some basic statistics about the beta's to be able to interpret them.\n         * source: http://dept.stat.lsa.umich.edu/~kshedden/Courses/Stat401/Notes/401-multreg.pdf\n         * validated against Excel Regression AddIn\n         * test: \"datamining statistics test\"\n         */\n        const fittedValues = x.mmul(beta);\n        const residuals = y.clone().addM(fittedValues.neg());\n        const variance = residuals.to2DArray().map(ri => Math.pow(ri[0], 2)).reduce((a, b) => a + b) / (y.rows - x.columns);\n        this.stdError = Math.sqrt(variance);\n        this.stdErrorMatrix = pseudoInverse(xx).mul(variance);\n        this.stdErrors = this.stdErrorMatrix.diagonal().map(d => Math.sqrt(d));\n        this.tStats = this.weights.map((d, i) => this.stdErrors[i] === 0 ? 0 : d[0] / this.stdErrors[i]);\n      }\n    }\n  }\n  predict(x) {\n    if (Array.isArray(x)) {\n      if (typeof x[0] === 'number') {\n        return this._predict(x);\n      } else if (Array.isArray(x[0])) {\n        const y = new Array(x.length);\n        for (let i = 0; i < x.length; i++) {\n          y[i] = this._predict(x[i]);\n        }\n        return y;\n      }\n    } else if (Matrix.isMatrix(x)) {\n      const y = new Matrix(x.rows, this.outputs);\n      for (let i = 0; i < x.rows; i++) {\n        y.setRow(i, this._predict(x.getRow(i)));\n      }\n      return y;\n    }\n    throw new TypeError('x must be a matrix or array of numbers');\n  }\n  _predict(x) {\n    const result = new Array(this.outputs);\n    if (this.intercept) {\n      for (let i = 0; i < this.outputs; i++) {\n        result[i] = this.weights[this.inputs][i];\n      }\n    } else {\n      result.fill(0);\n    }\n    for (let i = 0; i < this.inputs; i++) {\n      for (let j = 0; j < this.outputs; j++) {\n        result[j] += this.weights[i][j] * x[i];\n      }\n    }\n    return result;\n  }\n  score() {\n    throw new Error('score method is not implemented yet');\n  }\n  toJSON() {\n    return {\n      name: 'multivariateLinearRegression',\n      weights: this.weights,\n      inputs: this.inputs,\n      outputs: this.outputs,\n      intercept: this.intercept,\n      summary: this.statistics ? {\n        regressionStatistics: {\n          standardError: this.stdError,\n          observations: this.outputs\n        },\n        variables: this.weights.map((d, i) => {\n          return {\n            label: i === this.weights.length - 1 ? 'Intercept' : `X Variable ${i + 1}`,\n            coefficients: d,\n            standardError: this.stdErrors[i],\n            tStat: this.tStats[i]\n          };\n        })\n      } : undefined\n    };\n  }\n  static load(model) {\n    if (model.name !== 'multivariateLinearRegression') {\n      throw new Error('not a MLR model');\n    }\n    return new MultivariateLinearRegression(true, model);\n  }\n}","map":{"version":3,"names":["Matrix","SVD","pseudoInverse","MultivariateLinearRegression","constructor","x","y","options","intercept","statistics","weights","inputs","outputs","addColumn","Array","rows","fill","xt","transpose","xx","mmul","xy","invxx","inverse","beta","to2DArray","columns","fittedValues","residuals","clone","addM","neg","variance","map","ri","Math","pow","reduce","a","b","stdError","sqrt","stdErrorMatrix","mul","stdErrors","diagonal","d","tStats","i","predict","isArray","_predict","length","isMatrix","setRow","getRow","TypeError","result","j","score","Error","toJSON","name","summary","regressionStatistics","standardError","observations","variables","label","coefficients","tStat","undefined","load","model"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/ml-regression-multivariate-linear/src/index.js"],"sourcesContent":["import { Matrix, SVD, pseudoInverse } from 'ml-matrix';\n\nexport default class MultivariateLinearRegression {\n  constructor(x, y, options = {}) {\n    const { intercept = true, statistics = true } = options;\n    this.statistics = statistics;\n    if (x === true) {\n      this.weights = y.weights;\n      this.inputs = y.inputs;\n      this.outputs = y.outputs;\n      this.intercept = y.intercept;\n    } else {\n      x = new Matrix(x);\n      y = new Matrix(y);\n      if (intercept) {\n        x.addColumn(new Array(x.rows).fill(1));\n      }\n      let xt = x.transpose();\n      const xx = xt.mmul(x);\n      const xy = xt.mmul(y);\n      const invxx = new SVD(xx).inverse();\n      const beta = xy.transpose().mmul(invxx).transpose();\n      this.weights = beta.to2DArray();\n      this.inputs = x.columns;\n      this.outputs = y.columns;\n      if (intercept) this.inputs--;\n      this.intercept = intercept;\n      if (statistics) {\n        /*\n         * Let's add some basic statistics about the beta's to be able to interpret them.\n         * source: http://dept.stat.lsa.umich.edu/~kshedden/Courses/Stat401/Notes/401-multreg.pdf\n         * validated against Excel Regression AddIn\n         * test: \"datamining statistics test\"\n         */\n        const fittedValues = x.mmul(beta);\n        const residuals = y.clone().addM(fittedValues.neg());\n        const variance =\n          residuals\n            .to2DArray()\n            .map((ri) => Math.pow(ri[0], 2))\n            .reduce((a, b) => a + b) /\n          (y.rows - x.columns);\n        this.stdError = Math.sqrt(variance);\n        this.stdErrorMatrix = pseudoInverse(xx).mul(variance);\n        this.stdErrors = this.stdErrorMatrix\n          .diagonal()\n          .map((d) => Math.sqrt(d));\n        this.tStats = this.weights.map((d, i) =>\n          this.stdErrors[i] === 0 ? 0 : d[0] / this.stdErrors[i],\n        );\n      }\n    }\n  }\n\n  predict(x) {\n    if (Array.isArray(x)) {\n      if (typeof x[0] === 'number') {\n        return this._predict(x);\n      } else if (Array.isArray(x[0])) {\n        const y = new Array(x.length);\n        for (let i = 0; i < x.length; i++) {\n          y[i] = this._predict(x[i]);\n        }\n        return y;\n      }\n    } else if (Matrix.isMatrix(x)) {\n      const y = new Matrix(x.rows, this.outputs);\n      for (let i = 0; i < x.rows; i++) {\n        y.setRow(i, this._predict(x.getRow(i)));\n      }\n      return y;\n    }\n    throw new TypeError('x must be a matrix or array of numbers');\n  }\n\n  _predict(x) {\n    const result = new Array(this.outputs);\n    if (this.intercept) {\n      for (let i = 0; i < this.outputs; i++) {\n        result[i] = this.weights[this.inputs][i];\n      }\n    } else {\n      result.fill(0);\n    }\n    for (let i = 0; i < this.inputs; i++) {\n      for (let j = 0; j < this.outputs; j++) {\n        result[j] += this.weights[i][j] * x[i];\n      }\n    }\n    return result;\n  }\n\n  score() {\n    throw new Error('score method is not implemented yet');\n  }\n\n  toJSON() {\n    return {\n      name: 'multivariateLinearRegression',\n      weights: this.weights,\n      inputs: this.inputs,\n      outputs: this.outputs,\n      intercept: this.intercept,\n      summary: this.statistics\n        ? {\n            regressionStatistics: {\n              standardError: this.stdError,\n              observations: this.outputs,\n            },\n            variables: this.weights.map((d, i) => {\n              return {\n                label:\n                  i === this.weights.length - 1\n                    ? 'Intercept'\n                    : `X Variable ${i + 1}`,\n                coefficients: d,\n                standardError: this.stdErrors[i],\n                tStat: this.tStats[i],\n              };\n            }),\n          }\n        : undefined,\n    };\n  }\n\n  static load(model) {\n    if (model.name !== 'multivariateLinearRegression') {\n      throw new Error('not a MLR model');\n    }\n    return new MultivariateLinearRegression(true, model);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}