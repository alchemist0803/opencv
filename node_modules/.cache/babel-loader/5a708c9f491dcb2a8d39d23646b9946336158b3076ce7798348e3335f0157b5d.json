{"ast":null,"code":"import RoiMap from '../RoiMap';\n\n/**\n * @memberof RoiManager\n * @instance\n * @param {object} [options]\n * @param {boolean} [options.allowCorner=true]\n * @param {boolean} [options.onlyTop=false]\n * @param {boolean} [options.invert=false]\n * @return {RoiMap}\n */\nexport default function fromMaxima(options = {}) {\n  let {\n    allowCorner = true,\n    onlyTop = false,\n    invert = false\n  } = options;\n  let image = this;\n  image.checkProcessable('fromMaxima', {\n    components: [1]\n  });\n  const PROCESS_TOP = 1;\n  const PROCESS_NORMAL = 2;\n\n  // split will always return an array of images\n  let positiveID = 0;\n  let negativeID = 0;\n  let data = new Int16Array(image.size); // maxValue: 32767, minValue: -32768\n  let processed = new Int8Array(image.size);\n  let variations = new Float32Array(image.size);\n  let MAX_ARRAY = 0x0fffff; // should be enough for most of the cases\n  let xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n  let yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  let from = 0;\n  let to = 0;\n  let xToProcessTop = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n  let yToProcessTop = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  let fromTop = 0;\n  let toTop = 0;\n  appendMaxima(image, {\n    maxima: !invert\n  });\n  while (from < to) {\n    let currentX = xToProcess[from & MAX_ARRAY];\n    let currentY = yToProcess[from & MAX_ARRAY];\n    process(currentX, currentY, PROCESS_NORMAL);\n    from++;\n  }\n  return new RoiMap(image, data);\n\n  // we will look for the maxima (or minima) that is present in the picture\n  // a maxima is a point that is surrounded by lower values\n  // should deal with allowCorner and invert\n  function appendMaxima({\n    maxima = true\n  }) {\n    for (let y = 1; y < image.height - 1; y++) {\n      for (let x = 1; x < image.width - 1; x++) {\n        let index = x + y * image.width;\n        if (processed[index] === 0) {\n          let currentValue = maxima ? image.data[index] : -image.data[x + y * image.width];\n          if (image.data[y * image.width + x - 1] > currentValue) {\n            // LEFT\n            continue;\n          }\n          if (image.data[y * image.width + x + 1] > currentValue) {\n            // RIGHT\n            continue;\n          }\n          if (image.data[(y - 1) * image.width + x] > currentValue) {\n            // TOP\n            continue;\n          }\n          if (image.data[(y + 1) * image.width + x] > currentValue) {\n            // BOTTOM\n            continue;\n          }\n          if (allowCorner) {\n            if (image.data[(y - 1) * image.width + x - 1] > currentValue) {\n              // LEFT TOP\n              continue;\n            }\n            if (image.data[(y - 1) * image.width + x + 1] > currentValue) {\n              // RIGHT TOP\n              continue;\n            }\n            if (image.data[(y + 1) * image.width + x - 1] > currentValue) {\n              // LEFT BOTTOM\n              continue;\n            }\n            if (image.data[(y + 1) * image.width + x + 1] > currentValue) {\n              // RIGHT BOTTOM\n              continue;\n            }\n          }\n          data[index] = maxima ? ++positiveID : --negativeID;\n          let valid = processTop(x, y, PROCESS_TOP);\n          if (!valid) {\n            if (maxima) {\n              --positiveID;\n            } else {\n              ++negativeID;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // we will try to get all the points of the top (same value)\n  // and to check if the whole group is surrounded by lower value\n  // as soon as one of them if not part we need to reverse the process\n  // and just for get those points\n  function processTop(xToProcess, yToProcess) {\n    let currentTo = to; // in case if fails we come back\n    fromTop = 0;\n    toTop = 1;\n    xToProcessTop[0] = xToProcess;\n    yToProcessTop[0] = yToProcess;\n    let valid = true;\n    while (fromTop < toTop) {\n      let currentX = xToProcessTop[fromTop & MAX_ARRAY];\n      let currentY = yToProcessTop[fromTop & MAX_ARRAY];\n      valid &= process(currentX, currentY, PROCESS_TOP);\n      fromTop++;\n    }\n    if (!valid) {\n      // need to clear all the calculated data because the top is not surrounded by negative values\n      for (let i = 0; i < toTop; i++) {\n        let currentX = xToProcessTop[i & MAX_ARRAY];\n        let currentY = yToProcessTop[i & MAX_ARRAY];\n        let index = currentY * image.width + currentX;\n        data[index] = 0;\n      }\n      to = currentTo;\n    }\n    return valid;\n  }\n\n  /*\n     For a specific point we will check the points around, increase the area of interests and add\n     them to the processing list\n     type=0 : top\n     type=1 : normal\n     */\n  function process(xCenter, yCenter, type) {\n    let currentID = data[yCenter * image.width + xCenter];\n    let currentValue = image.data[yCenter * image.width + xCenter];\n    for (let y = yCenter - 1; y <= yCenter + 1; y++) {\n      for (let x = xCenter - 1; x <= xCenter + 1; x++) {\n        let index = y * image.width + x;\n        if (processed[index] === 0) {\n          processed[index] = 1;\n          // we store the variation compare to the parent pixel\n          variations[index] = image.data[index] - currentValue;\n          switch (type) {\n            case PROCESS_TOP:\n              if (variations[index] === 0) {\n                // we look for maxima\n                // if we are next to a border ... it is not surrounded !\n                if (x === 0 || y === 0 || x === image.width - 1 || y === image.height - 1) {\n                  return false;\n                }\n                data[index] = currentID;\n                xToProcessTop[toTop & MAX_ARRAY] = x;\n                yToProcessTop[toTop & MAX_ARRAY] = y;\n                toTop++;\n              } else if (variations[index] > 0) {\n                // not a global maximum\n                return false;\n              } else {\n                // a point we will have to process\n                if (!onlyTop) {\n                  data[index] = currentID;\n                  xToProcess[to & MAX_ARRAY] = x;\n                  yToProcess[to & MAX_ARRAY] = y;\n                  to++;\n                }\n              }\n              break;\n            case PROCESS_NORMAL:\n              if (variations[index] <= 0) {\n                // we look for maxima\n                data[index] = currentID;\n                xToProcess[to & MAX_ARRAY] = x;\n                yToProcess[to & MAX_ARRAY] = y;\n                to++;\n              }\n              break;\n            default:\n              throw new Error('unreachable');\n          }\n        }\n      }\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["RoiMap","fromMaxima","options","allowCorner","onlyTop","invert","image","checkProcessable","components","PROCESS_TOP","PROCESS_NORMAL","positiveID","negativeID","data","Int16Array","size","processed","Int8Array","variations","Float32Array","MAX_ARRAY","xToProcess","Uint16Array","yToProcess","from","to","xToProcessTop","yToProcessTop","fromTop","toTop","appendMaxima","maxima","currentX","currentY","process","y","height","x","width","index","currentValue","valid","processTop","currentTo","i","xCenter","yCenter","type","currentID","Error"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/roi/creator/fromMaxima.js"],"sourcesContent":["import RoiMap from '../RoiMap';\n\n/**\n * @memberof RoiManager\n * @instance\n * @param {object} [options]\n * @param {boolean} [options.allowCorner=true]\n * @param {boolean} [options.onlyTop=false]\n * @param {boolean} [options.invert=false]\n * @return {RoiMap}\n */\nexport default function fromMaxima(options = {}) {\n  let { allowCorner = true, onlyTop = false, invert = false } = options;\n\n  let image = this;\n  image.checkProcessable('fromMaxima', { components: [1] });\n\n  const PROCESS_TOP = 1;\n  const PROCESS_NORMAL = 2;\n\n  // split will always return an array of images\n  let positiveID = 0;\n  let negativeID = 0;\n\n  let data = new Int16Array(image.size); // maxValue: 32767, minValue: -32768\n  let processed = new Int8Array(image.size);\n  let variations = new Float32Array(image.size);\n\n  let MAX_ARRAY = 0x0fffff; // should be enough for most of the cases\n  let xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n  let yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  let from = 0;\n  let to = 0;\n\n  let xToProcessTop = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n  let yToProcessTop = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  let fromTop = 0;\n  let toTop = 0;\n\n  appendMaxima(image, { maxima: !invert });\n\n  while (from < to) {\n    let currentX = xToProcess[from & MAX_ARRAY];\n    let currentY = yToProcess[from & MAX_ARRAY];\n    process(currentX, currentY, PROCESS_NORMAL);\n    from++;\n  }\n\n  return new RoiMap(image, data);\n\n  // we will look for the maxima (or minima) that is present in the picture\n  // a maxima is a point that is surrounded by lower values\n  // should deal with allowCorner and invert\n  function appendMaxima({ maxima = true }) {\n    for (let y = 1; y < image.height - 1; y++) {\n      for (let x = 1; x < image.width - 1; x++) {\n        let index = x + y * image.width;\n        if (processed[index] === 0) {\n          let currentValue = maxima\n            ? image.data[index]\n            : -image.data[x + y * image.width];\n          if (image.data[y * image.width + x - 1] > currentValue) {\n            // LEFT\n            continue;\n          }\n          if (image.data[y * image.width + x + 1] > currentValue) {\n            // RIGHT\n            continue;\n          }\n          if (image.data[(y - 1) * image.width + x] > currentValue) {\n            // TOP\n            continue;\n          }\n          if (image.data[(y + 1) * image.width + x] > currentValue) {\n            // BOTTOM\n            continue;\n          }\n          if (allowCorner) {\n            if (image.data[(y - 1) * image.width + x - 1] > currentValue) {\n              // LEFT TOP\n              continue;\n            }\n            if (image.data[(y - 1) * image.width + x + 1] > currentValue) {\n              // RIGHT TOP\n              continue;\n            }\n            if (image.data[(y + 1) * image.width + x - 1] > currentValue) {\n              // LEFT BOTTOM\n              continue;\n            }\n            if (image.data[(y + 1) * image.width + x + 1] > currentValue) {\n              // RIGHT BOTTOM\n              continue;\n            }\n          }\n\n          data[index] = maxima ? ++positiveID : --negativeID;\n\n          let valid = processTop(x, y, PROCESS_TOP);\n          if (!valid) {\n            if (maxima) {\n              --positiveID;\n            } else {\n              ++negativeID;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // we will try to get all the points of the top (same value)\n  // and to check if the whole group is surrounded by lower value\n  // as soon as one of them if not part we need to reverse the process\n  // and just for get those points\n  function processTop(xToProcess, yToProcess) {\n    let currentTo = to; // in case if fails we come back\n    fromTop = 0;\n    toTop = 1;\n    xToProcessTop[0] = xToProcess;\n    yToProcessTop[0] = yToProcess;\n    let valid = true;\n    while (fromTop < toTop) {\n      let currentX = xToProcessTop[fromTop & MAX_ARRAY];\n      let currentY = yToProcessTop[fromTop & MAX_ARRAY];\n      valid &= process(currentX, currentY, PROCESS_TOP);\n      fromTop++;\n    }\n    if (!valid) {\n      // need to clear all the calculated data because the top is not surrounded by negative values\n      for (let i = 0; i < toTop; i++) {\n        let currentX = xToProcessTop[i & MAX_ARRAY];\n        let currentY = yToProcessTop[i & MAX_ARRAY];\n        let index = currentY * image.width + currentX;\n        data[index] = 0;\n      }\n      to = currentTo;\n    }\n    return valid;\n  }\n\n  /*\n     For a specific point we will check the points around, increase the area of interests and add\n     them to the processing list\n     type=0 : top\n     type=1 : normal\n     */\n  function process(xCenter, yCenter, type) {\n    let currentID = data[yCenter * image.width + xCenter];\n    let currentValue = image.data[yCenter * image.width + xCenter];\n    for (let y = yCenter - 1; y <= yCenter + 1; y++) {\n      for (let x = xCenter - 1; x <= xCenter + 1; x++) {\n        let index = y * image.width + x;\n        if (processed[index] === 0) {\n          processed[index] = 1;\n          // we store the variation compare to the parent pixel\n          variations[index] = image.data[index] - currentValue;\n          switch (type) {\n            case PROCESS_TOP:\n              if (variations[index] === 0) {\n                // we look for maxima\n                // if we are next to a border ... it is not surrounded !\n                if (\n                  x === 0 ||\n                  y === 0 ||\n                  x === image.width - 1 ||\n                  y === image.height - 1\n                ) {\n                  return false;\n                }\n                data[index] = currentID;\n                xToProcessTop[toTop & MAX_ARRAY] = x;\n                yToProcessTop[toTop & MAX_ARRAY] = y;\n                toTop++;\n              } else if (variations[index] > 0) {\n                // not a global maximum\n                return false;\n              } else {\n                // a point we will have to process\n                if (!onlyTop) {\n                  data[index] = currentID;\n                  xToProcess[to & MAX_ARRAY] = x;\n                  yToProcess[to & MAX_ARRAY] = y;\n                  to++;\n                }\n              }\n              break;\n            case PROCESS_NORMAL:\n              if (variations[index] <= 0) {\n                // we look for maxima\n                data[index] = currentID;\n                xToProcess[to & MAX_ARRAY] = x;\n                yToProcess[to & MAX_ARRAY] = y;\n                to++;\n              }\n              break;\n            default:\n              throw new Error('unreachable');\n          }\n        }\n      }\n    }\n    return true;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}