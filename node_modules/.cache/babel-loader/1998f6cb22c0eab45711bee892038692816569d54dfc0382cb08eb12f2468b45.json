{"ast":null,"code":"import RoiMap from '../RoiMap';\n\n/**\n * @memberof RoiManager\n * @instance\n * @param {Image} mask\n * @param {object} [options]\n * @return {RoiMap}\n */\nexport default function fromMask(mask, options = {}) {\n  const {\n    allowCorners = false\n  } = options;\n  const MAX_ARRAY = 0x00ffff; // 65535 should be enough for most of the cases\n\n  // based on a binary image we will create plenty of small images\n  let data = new Int16Array(mask.size); // maxValue: 32767, minValue: -32768\n\n  // split will always return an array of images\n  let positiveID = 0;\n  let negativeID = 0;\n  let xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n  let yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  for (let x = 0; x < mask.width; x++) {\n    for (let y = 0; y < mask.height; y++) {\n      if (data[y * mask.width + x] === 0) {\n        // need to process the whole surface\n        analyseSurface(x, y);\n      }\n    }\n  }\n  function analyseSurface(x, y) {\n    let from = 0;\n    let to = 0;\n    let targetState = mask.getBitXY(x, y);\n    let id = targetState ? ++positiveID : --negativeID;\n    if (positiveID > 32767 || negativeID < -32768) {\n      throw new Error('Too many regions of interest');\n    }\n    xToProcess[0] = x;\n    yToProcess[0] = y;\n    while (from <= to) {\n      let currentX = xToProcess[from & MAX_ARRAY];\n      let currentY = yToProcess[from & MAX_ARRAY];\n      data[currentY * mask.width + currentX] = id;\n      // need to check all around mask pixel\n      if (currentX > 0 && data[currentY * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY) === targetState) {\n        // LEFT\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX - 1;\n        yToProcess[to & MAX_ARRAY] = currentY;\n        data[currentY * mask.width + currentX - 1] = -32768;\n      }\n      if (currentY > 0 && data[(currentY - 1) * mask.width + currentX] === 0 && mask.getBitXY(currentX, currentY - 1) === targetState) {\n        // TOP\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX;\n        yToProcess[to & MAX_ARRAY] = currentY - 1;\n        data[(currentY - 1) * mask.width + currentX] = -32768;\n      }\n      if (currentX < mask.width - 1 && data[currentY * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY) === targetState) {\n        // RIGHT\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX + 1;\n        yToProcess[to & MAX_ARRAY] = currentY;\n        data[currentY * mask.width + currentX + 1] = -32768;\n      }\n      if (currentY < mask.height - 1 && data[(currentY + 1) * mask.width + currentX] === 0 && mask.getBitXY(currentX, currentY + 1) === targetState) {\n        // BOTTOM\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX;\n        yToProcess[to & MAX_ARRAY] = currentY + 1;\n        data[(currentY + 1) * mask.width + currentX] = -32768;\n      }\n      if (allowCorners) {\n        if (currentX > 0 && currentY > 0 && data[(currentY - 1) * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY - 1) === targetState) {\n          // TOP LEFT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX - 1;\n          yToProcess[to & MAX_ARRAY] = currentY - 1;\n          data[(currentY - 1) * mask.width + currentX - 1] = -32768;\n        }\n        if (currentX < mask.width - 1 && currentY > 0 && data[(currentY - 1) * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY - 1) === targetState) {\n          // TOP RIGHT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX + 1;\n          yToProcess[to & MAX_ARRAY] = currentY - 1;\n          data[(currentY - 1) * mask.width + currentX + 1] = -32768;\n        }\n        if (currentX > 0 && currentY < mask.height - 1 && data[(currentY + 1) * mask.width + currentX - 1] === 0 && mask.getBitXY(currentX - 1, currentY + 1) === targetState) {\n          // BOTTOM LEFT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX - 1;\n          yToProcess[to & MAX_ARRAY] = currentY + 1;\n          data[(currentY + 1) * mask.width + currentX - 1] = -32768;\n        }\n        if (currentX < mask.width - 1 && currentY < mask.height - 1 && data[(currentY + 1) * mask.width + currentX + 1] === 0 && mask.getBitXY(currentX + 1, currentY + 1) === targetState) {\n          // BOTTOM RIGHT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX + 1;\n          yToProcess[to & MAX_ARRAY] = currentY + 1;\n          data[(currentY + 1) * mask.width + currentX + 1] = -32768;\n        }\n      }\n      from++;\n      if (to - from > MAX_ARRAY) {\n        throw new Error('analyseMask can not finish, the array to manage internal data is not big enough.' + 'You could improve mask by changing MAX_ARRAY');\n      }\n    }\n  }\n  return new RoiMap(mask, data);\n}","map":{"version":3,"names":["RoiMap","fromMask","mask","options","allowCorners","MAX_ARRAY","data","Int16Array","size","positiveID","negativeID","xToProcess","Uint16Array","yToProcess","x","width","y","height","analyseSurface","from","to","targetState","getBitXY","id","Error","currentX","currentY"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/roi/creator/fromMask.js"],"sourcesContent":["import RoiMap from '../RoiMap';\n\n/**\n * @memberof RoiManager\n * @instance\n * @param {Image} mask\n * @param {object} [options]\n * @return {RoiMap}\n */\nexport default function fromMask(mask, options = {}) {\n  const { allowCorners = false } = options;\n\n  const MAX_ARRAY = 0x00ffff; // 65535 should be enough for most of the cases\n\n  // based on a binary image we will create plenty of small images\n  let data = new Int16Array(mask.size); // maxValue: 32767, minValue: -32768\n\n  // split will always return an array of images\n  let positiveID = 0;\n  let negativeID = 0;\n\n  let xToProcess = new Uint16Array(MAX_ARRAY + 1); // assign dynamically ????\n  let yToProcess = new Uint16Array(MAX_ARRAY + 1); // mask +1 is of course mandatory !!!\n\n  for (let x = 0; x < mask.width; x++) {\n    for (let y = 0; y < mask.height; y++) {\n      if (data[y * mask.width + x] === 0) {\n        // need to process the whole surface\n        analyseSurface(x, y);\n      }\n    }\n  }\n\n  function analyseSurface(x, y) {\n    let from = 0;\n    let to = 0;\n    let targetState = mask.getBitXY(x, y);\n    let id = targetState ? ++positiveID : --negativeID;\n    if (positiveID > 32767 || negativeID < -32768) {\n      throw new Error('Too many regions of interest');\n    }\n    xToProcess[0] = x;\n    yToProcess[0] = y;\n    while (from <= to) {\n      let currentX = xToProcess[from & MAX_ARRAY];\n      let currentY = yToProcess[from & MAX_ARRAY];\n      data[currentY * mask.width + currentX] = id;\n      // need to check all around mask pixel\n      if (\n        currentX > 0 &&\n        data[currentY * mask.width + currentX - 1] === 0 &&\n        mask.getBitXY(currentX - 1, currentY) === targetState\n      ) {\n        // LEFT\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX - 1;\n        yToProcess[to & MAX_ARRAY] = currentY;\n        data[currentY * mask.width + currentX - 1] = -32768;\n      }\n      if (\n        currentY > 0 &&\n        data[(currentY - 1) * mask.width + currentX] === 0 &&\n        mask.getBitXY(currentX, currentY - 1) === targetState\n      ) {\n        // TOP\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX;\n        yToProcess[to & MAX_ARRAY] = currentY - 1;\n        data[(currentY - 1) * mask.width + currentX] = -32768;\n      }\n      if (\n        currentX < mask.width - 1 &&\n        data[currentY * mask.width + currentX + 1] === 0 &&\n        mask.getBitXY(currentX + 1, currentY) === targetState\n      ) {\n        // RIGHT\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX + 1;\n        yToProcess[to & MAX_ARRAY] = currentY;\n        data[currentY * mask.width + currentX + 1] = -32768;\n      }\n      if (\n        currentY < mask.height - 1 &&\n        data[(currentY + 1) * mask.width + currentX] === 0 &&\n        mask.getBitXY(currentX, currentY + 1) === targetState\n      ) {\n        // BOTTOM\n        to++;\n        xToProcess[to & MAX_ARRAY] = currentX;\n        yToProcess[to & MAX_ARRAY] = currentY + 1;\n        data[(currentY + 1) * mask.width + currentX] = -32768;\n      }\n      if (allowCorners) {\n        if (\n          currentX > 0 &&\n          currentY > 0 &&\n          data[(currentY - 1) * mask.width + currentX - 1] === 0 &&\n          mask.getBitXY(currentX - 1, currentY - 1) === targetState\n        ) {\n          // TOP LEFT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX - 1;\n          yToProcess[to & MAX_ARRAY] = currentY - 1;\n          data[(currentY - 1) * mask.width + currentX - 1] = -32768;\n        }\n        if (\n          currentX < mask.width - 1 &&\n          currentY > 0 &&\n          data[(currentY - 1) * mask.width + currentX + 1] === 0 &&\n          mask.getBitXY(currentX + 1, currentY - 1) === targetState\n        ) {\n          // TOP RIGHT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX + 1;\n          yToProcess[to & MAX_ARRAY] = currentY - 1;\n          data[(currentY - 1) * mask.width + currentX + 1] = -32768;\n        }\n        if (\n          currentX > 0 &&\n          currentY < mask.height - 1 &&\n          data[(currentY + 1) * mask.width + currentX - 1] === 0 &&\n          mask.getBitXY(currentX - 1, currentY + 1) === targetState\n        ) {\n          // BOTTOM LEFT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX - 1;\n          yToProcess[to & MAX_ARRAY] = currentY + 1;\n          data[(currentY + 1) * mask.width + currentX - 1] = -32768;\n        }\n        if (\n          currentX < mask.width - 1 &&\n          currentY < mask.height - 1 &&\n          data[(currentY + 1) * mask.width + currentX + 1] === 0 &&\n          mask.getBitXY(currentX + 1, currentY + 1) === targetState\n        ) {\n          // BOTTOM RIGHT\n          to++;\n          xToProcess[to & MAX_ARRAY] = currentX + 1;\n          yToProcess[to & MAX_ARRAY] = currentY + 1;\n          data[(currentY + 1) * mask.width + currentX + 1] = -32768;\n        }\n      }\n\n      from++;\n\n      if (to - from > MAX_ARRAY) {\n        throw new Error(\n          'analyseMask can not finish, the array to manage internal data is not big enough.' +\n            'You could improve mask by changing MAX_ARRAY',\n        );\n      }\n    }\n  }\n\n  return new RoiMap(mask, data);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}