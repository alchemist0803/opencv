{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Zack, G. W., Rogers, W. E. and Latt, S. A., 1977,\n// Automatic Measurement of Sister Chromatid Exchange Frequency,\n// Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753\n//\n//  modified from Johannes Schindelin plugin\nexport default function triangle(histogram) {\n  // find min and max\n  let min = 0;\n  let dmax = 0;\n  let max = 0;\n  let min2 = 0;\n  for (let i = 0; i < histogram.length; i++) {\n    if (histogram[i] > 0) {\n      min = i;\n      break;\n    }\n  }\n  if (min > 0) {\n    // line to the (p==0) point, not to histogram[min]\n    min--;\n  }\n\n  // The Triangle algorithm cannot tell whether the data is skewed to one side or another.\n  // This causes a problem as there are 2 possible thresholds between the max and the 2 extremes\n  // of the histogram.\n  // Here I propose to find out to which side of the max point the data is furthest, and use that as\n  //  the other extreme.\n  for (let i = histogram.length - 1; i > 0; i--) {\n    if (histogram[i] > 0) {\n      min2 = i;\n      break;\n    }\n  }\n  if (min2 < histogram.length - 1) {\n    // line to the (p==0) point, not to data[min]\n    min2++;\n  }\n  for (let i = 0; i < histogram.length; i++) {\n    if (histogram[i] > dmax) {\n      max = i;\n      dmax = histogram[i];\n    }\n  }\n\n  // find which is the furthest side\n  let inverted = false;\n  if (max - min < min2 - max) {\n    // reverse the histogram\n    inverted = true;\n    let left = 0; // index of leftmost element\n    let right = histogram.length - 1; // index of rightmost element\n    while (left < right) {\n      // exchange the left and right elements\n      let temp = histogram[left];\n      histogram[left] = histogram[right];\n      histogram[right] = temp;\n      // move the bounds toward the center\n      left++;\n      right--;\n    }\n    min = histogram.length - 1 - min2;\n    max = histogram.length - 1 - max;\n  }\n  if (min === max) {\n    return min;\n  }\n\n  // describe line by nx * x + ny * y - d = 0\n  let nx, ny, d;\n  // nx is just the max frequency as the other point has freq=0\n  nx = histogram[max]; // -min; // data[min]; //  lowest value bmin = (p=0)% in the image\n  ny = min - max;\n  d = Math.sqrt(nx * nx + ny * ny);\n  nx /= d;\n  ny /= d;\n  d = nx * min + ny * histogram[min];\n\n  // find split point\n  let split = min;\n  let splitDistance = 0;\n  for (let i = min + 1; i <= max; i++) {\n    let newDistance = nx * i + ny * histogram[i] - d;\n    if (newDistance > splitDistance) {\n      split = i;\n      splitDistance = newDistance;\n    }\n  }\n  split--;\n  if (inverted) {\n    // The histogram might be used for something else, so let's reverse it back\n    let left = 0;\n    let right = histogram.length - 1;\n    while (left < right) {\n      let temp = histogram[left];\n      histogram[left] = histogram[right];\n      histogram[right] = temp;\n      left++;\n      right--;\n    }\n    return histogram.length - 1 - split;\n  } else {\n    return split;\n  }\n}","map":{"version":3,"names":["triangle","histogram","min","dmax","max","min2","i","length","inverted","left","right","temp","nx","ny","d","Math","sqrt","split","splitDistance","newDistance"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/triangle.js"],"sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Zack, G. W., Rogers, W. E. and Latt, S. A., 1977,\n// Automatic Measurement of Sister Chromatid Exchange Frequency,\n// Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753\n//\n//  modified from Johannes Schindelin plugin\nexport default function triangle(histogram) {\n  // find min and max\n  let min = 0;\n  let dmax = 0;\n  let max = 0;\n  let min2 = 0;\n  for (let i = 0; i < histogram.length; i++) {\n    if (histogram[i] > 0) {\n      min = i;\n      break;\n    }\n  }\n  if (min > 0) {\n    // line to the (p==0) point, not to histogram[min]\n    min--;\n  }\n\n  // The Triangle algorithm cannot tell whether the data is skewed to one side or another.\n  // This causes a problem as there are 2 possible thresholds between the max and the 2 extremes\n  // of the histogram.\n  // Here I propose to find out to which side of the max point the data is furthest, and use that as\n  //  the other extreme.\n  for (let i = histogram.length - 1; i > 0; i--) {\n    if (histogram[i] > 0) {\n      min2 = i;\n      break;\n    }\n  }\n  if (min2 < histogram.length - 1) {\n    // line to the (p==0) point, not to data[min]\n    min2++;\n  }\n\n  for (let i = 0; i < histogram.length; i++) {\n    if (histogram[i] > dmax) {\n      max = i;\n      dmax = histogram[i];\n    }\n  }\n\n  // find which is the furthest side\n  let inverted = false;\n  if (max - min < min2 - max) {\n    // reverse the histogram\n    inverted = true;\n    let left = 0; // index of leftmost element\n    let right = histogram.length - 1; // index of rightmost element\n    while (left < right) {\n      // exchange the left and right elements\n      let temp = histogram[left];\n      histogram[left] = histogram[right];\n      histogram[right] = temp;\n      // move the bounds toward the center\n      left++;\n      right--;\n    }\n    min = histogram.length - 1 - min2;\n    max = histogram.length - 1 - max;\n  }\n\n  if (min === max) {\n    return min;\n  }\n\n  // describe line by nx * x + ny * y - d = 0\n  let nx, ny, d;\n  // nx is just the max frequency as the other point has freq=0\n  nx = histogram[max]; // -min; // data[min]; //  lowest value bmin = (p=0)% in the image\n  ny = min - max;\n  d = Math.sqrt(nx * nx + ny * ny);\n  nx /= d;\n  ny /= d;\n  d = nx * min + ny * histogram[min];\n\n  // find split point\n  let split = min;\n  let splitDistance = 0;\n  for (let i = min + 1; i <= max; i++) {\n    let newDistance = nx * i + ny * histogram[i] - d;\n    if (newDistance > splitDistance) {\n      split = i;\n      splitDistance = newDistance;\n    }\n  }\n  split--;\n\n  if (inverted) {\n    // The histogram might be used for something else, so let's reverse it back\n    let left = 0;\n    let right = histogram.length - 1;\n    while (left < right) {\n      let temp = histogram[left];\n      histogram[left] = histogram[right];\n      histogram[right] = temp;\n      left++;\n      right--;\n    }\n    return histogram.length - 1 - split;\n  } else {\n    return split;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}