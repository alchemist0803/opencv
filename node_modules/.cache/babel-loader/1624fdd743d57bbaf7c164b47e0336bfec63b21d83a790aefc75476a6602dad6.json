{"ast":null,"code":"import newArray from 'new-array';\nimport { validateArrayOfChannels } from '../../util/channel';\n\n/**\n * Level the image for by default have the minimal and maximal values.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {string} [options.algorithm='range']\n * @param {SelectedChannels} [options.channels] Specify which channels should be processed\n * @param {number} [options.min=this.min] minimal value after levelling\n * @param {number} [options.max=this.max] maximal value after levelling\n * @return {this}\n */\nexport default function level(options = {}) {\n  let {\n    algorithm = 'range',\n    channels,\n    min = this.min,\n    max = this.max\n  } = options;\n  this.checkProcessable('level', {\n    bitDepth: [8, 16, 32]\n  });\n  channels = validateArrayOfChannels(this, {\n    channels: channels\n  });\n  if (channels.length !== this.channel) {\n    // if we process only part of the channels and the min or max length corresponds to the number of channels\n    // we need to take the corresponding values\n    if (Array.isArray(min) && min.length === this.channels) {\n      min = min.filter((a, index) => channels.includes(index));\n    }\n    if (Array.isArray(max) && max.length === this.channels) {\n      max = max.filter((a, index) => channels.includes(index));\n    }\n  }\n  switch (algorithm) {\n    case 'range':\n      if (min < 0) {\n        min = 0;\n      }\n      if (max > this.maxValue) {\n        max = this.maxValue;\n      }\n      if (!Array.isArray(min)) {\n        min = newArray(channels.length, min);\n      }\n      if (!Array.isArray(max)) {\n        max = newArray(channels.length, max);\n      }\n      processImage(this, min, max, channels);\n      break;\n    default:\n      throw new Error(`level: algorithm not implement: ${algorithm}`);\n  }\n  return this;\n}\nfunction processImage(image, min, max, channels) {\n  let delta = 1e-5; // sorry no better value that this \"best guess\"\n  let factor = new Array(channels.length);\n  for (let i = 0; i < channels.length; i++) {\n    if (min[i] === 0 && max[i] === image.maxValue) {\n      factor[i] = 0;\n    } else if (max[i] === min[i]) {\n      factor[i] = 0;\n    } else {\n      factor[i] = (image.maxValue + 1 - delta) / (max[i] - min[i]);\n    }\n    min[i] += (0.5 - delta / 2) / factor[i];\n  }\n\n  /*\n     Note on border effect\n     For 8 bits images we should calculate for the space between -0.5 and 255.5\n     so that after ronding the first and last points still have the same population\n     But doing this we need to deal with Math.round that gives 256 if the value is 255.5\n     */\n\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n    if (factor[j] !== 0) {\n      for (let i = 0; i < image.data.length; i += image.channels) {\n        image.data[i + c] = Math.min(Math.max(0, (image.data[i + c] - min[j]) * factor[j] + 0.5 | 0), image.maxValue);\n      }\n    }\n  }\n}","map":{"version":3,"names":["newArray","validateArrayOfChannels","level","options","algorithm","channels","min","max","checkProcessable","bitDepth","length","channel","Array","isArray","filter","a","index","includes","maxValue","processImage","Error","image","delta","factor","i","j","c","data","Math"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/filter/level.js"],"sourcesContent":["import newArray from 'new-array';\n\nimport { validateArrayOfChannels } from '../../util/channel';\n\n/**\n * Level the image for by default have the minimal and maximal values.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {string} [options.algorithm='range']\n * @param {SelectedChannels} [options.channels] Specify which channels should be processed\n * @param {number} [options.min=this.min] minimal value after levelling\n * @param {number} [options.max=this.max] maximal value after levelling\n * @return {this}\n */\nexport default function level(options = {}) {\n  let {\n    algorithm = 'range',\n    channels,\n    min = this.min,\n    max = this.max,\n  } = options;\n\n  this.checkProcessable('level', {\n    bitDepth: [8, 16, 32],\n  });\n\n  channels = validateArrayOfChannels(this, { channels: channels });\n\n  if (channels.length !== this.channel) {\n    // if we process only part of the channels and the min or max length corresponds to the number of channels\n    // we need to take the corresponding values\n    if (Array.isArray(min) && min.length === this.channels) {\n      min = min.filter((a, index) => channels.includes(index));\n    }\n    if (Array.isArray(max) && max.length === this.channels) {\n      max = max.filter((a, index) => channels.includes(index));\n    }\n  }\n\n  switch (algorithm) {\n    case 'range':\n      if (min < 0) {\n        min = 0;\n      }\n      if (max > this.maxValue) {\n        max = this.maxValue;\n      }\n\n      if (!Array.isArray(min)) {\n        min = newArray(channels.length, min);\n      }\n      if (!Array.isArray(max)) {\n        max = newArray(channels.length, max);\n      }\n\n      processImage(this, min, max, channels);\n      break;\n\n    default:\n      throw new Error(`level: algorithm not implement: ${algorithm}`);\n  }\n\n  return this;\n}\n\nfunction processImage(image, min, max, channels) {\n  let delta = 1e-5; // sorry no better value that this \"best guess\"\n  let factor = new Array(channels.length);\n\n  for (let i = 0; i < channels.length; i++) {\n    if (min[i] === 0 && max[i] === image.maxValue) {\n      factor[i] = 0;\n    } else if (max[i] === min[i]) {\n      factor[i] = 0;\n    } else {\n      factor[i] = (image.maxValue + 1 - delta) / (max[i] - min[i]);\n    }\n    min[i] += (0.5 - delta / 2) / factor[i];\n  }\n\n  /*\n     Note on border effect\n     For 8 bits images we should calculate for the space between -0.5 and 255.5\n     so that after ronding the first and last points still have the same population\n     But doing this we need to deal with Math.round that gives 256 if the value is 255.5\n     */\n\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n    if (factor[j] !== 0) {\n      for (let i = 0; i < image.data.length; i += image.channels) {\n        image.data[i + c] = Math.min(\n          Math.max(0, ((image.data[i + c] - min[j]) * factor[j] + 0.5) | 0),\n          image.maxValue,\n        );\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}