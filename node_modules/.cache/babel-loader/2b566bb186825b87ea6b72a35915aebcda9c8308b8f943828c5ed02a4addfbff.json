{"ast":null,"code":"/**\n * Paint a polyline defined by an array of points.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>} [options.color=[max,0,0]] - Array of 3 elements (R, G, B), default is red.\n * @param {boolean} [options.closed=false] - Close the polyline.\n * @return {this} The original painted image\n */\nexport default function paintPolyline(points, options = {}) {\n  let {\n    color = [this.maxValue, 0, 0],\n    closed = false\n  } = options;\n  this.checkProcessable('paintPoints', {\n    bitDepth: [1, 8, 16]\n  });\n  let numberChannels = Math.min(this.channels, color.length);\n  for (let i = 0; i < points.length - 1 + closed; i++) {\n    let from = points[i];\n    let to = points[(i + 1) % points.length];\n    let dx = to[0] - from[0];\n    let dy = to[1] - from[1];\n    let steps = Math.max(Math.abs(dx), Math.abs(dy));\n    let xIncrement = dx / steps;\n    let yIncrement = dy / steps;\n    let x = from[0];\n    let y = from[1];\n    for (let j = 0; j <= steps; j++) {\n      let xPoint = Math.round(x);\n      let yPoint = Math.round(y);\n      if (xPoint >= 0 && yPoint >= 0 && xPoint < this.width && yPoint < this.height) {\n        if (this.bitDepth === 1) {\n          this.setBitXY(xPoint, yPoint);\n        } else {\n          let position = (xPoint + yPoint * this.width) * this.channels;\n          for (let channel = 0; channel < numberChannels; channel++) {\n            this.data[position + channel] = color[channel];\n          }\n        }\n      }\n      x = x + xIncrement;\n      y = y + yIncrement;\n    }\n  }\n  return this;\n}","map":{"version":3,"names":["paintPolyline","points","options","color","maxValue","closed","checkProcessable","bitDepth","numberChannels","Math","min","channels","length","i","from","to","dx","dy","steps","max","abs","xIncrement","yIncrement","x","y","j","xPoint","round","yPoint","width","height","setBitXY","position","channel","data"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/operator/paintPolyline.js"],"sourcesContent":["/**\n * Paint a polyline defined by an array of points.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>} [options.color=[max,0,0]] - Array of 3 elements (R, G, B), default is red.\n * @param {boolean} [options.closed=false] - Close the polyline.\n * @return {this} The original painted image\n */\nexport default function paintPolyline(points, options = {}) {\n  let { color = [this.maxValue, 0, 0], closed = false } = options;\n\n  this.checkProcessable('paintPoints', {\n    bitDepth: [1, 8, 16],\n  });\n\n  let numberChannels = Math.min(this.channels, color.length);\n\n  for (let i = 0; i < points.length - 1 + closed; i++) {\n    let from = points[i];\n    let to = points[(i + 1) % points.length];\n\n    let dx = to[0] - from[0];\n    let dy = to[1] - from[1];\n    let steps = Math.max(Math.abs(dx), Math.abs(dy));\n\n    let xIncrement = dx / steps;\n    let yIncrement = dy / steps;\n\n    let x = from[0];\n    let y = from[1];\n\n    for (let j = 0; j <= steps; j++) {\n      let xPoint = Math.round(x);\n      let yPoint = Math.round(y);\n      if (\n        xPoint >= 0 &&\n        yPoint >= 0 &&\n        xPoint < this.width &&\n        yPoint < this.height\n      ) {\n        if (this.bitDepth === 1) {\n          this.setBitXY(xPoint, yPoint);\n        } else {\n          let position = (xPoint + yPoint * this.width) * this.channels;\n          for (let channel = 0; channel < numberChannels; channel++) {\n            this.data[position + channel] = color[channel];\n          }\n        }\n      }\n\n      x = x + xIncrement;\n      y = y + yIncrement;\n    }\n  }\n\n  return this;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,aAAaA,CAACC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC1D,IAAI;IAAEC,KAAK,GAAG,CAAC,IAAI,CAACC,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;IAAEC,MAAM,GAAG;EAAM,CAAC,GAAGH,OAAO;EAE/D,IAAI,CAACI,gBAAgB,CAAC,aAAa,EAAE;IACnCC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;EACrB,CAAC,CAAC;EAEF,IAAIC,cAAc,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACC,QAAQ,EAAER,KAAK,CAACS,MAAM,CAAC;EAE1D,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,MAAM,CAACW,MAAM,GAAG,CAAC,GAAGP,MAAM,EAAEQ,CAAC,EAAE,EAAE;IACnD,IAAIC,IAAI,GAAGb,MAAM,CAACY,CAAC,CAAC;IACpB,IAAIE,EAAE,GAAGd,MAAM,CAAC,CAACY,CAAC,GAAG,CAAC,IAAIZ,MAAM,CAACW,MAAM,CAAC;IAExC,IAAII,EAAE,GAAGD,EAAE,CAAC,CAAC,CAAC,GAAGD,IAAI,CAAC,CAAC,CAAC;IACxB,IAAIG,EAAE,GAAGF,EAAE,CAAC,CAAC,CAAC,GAAGD,IAAI,CAAC,CAAC,CAAC;IACxB,IAAII,KAAK,GAAGT,IAAI,CAACU,GAAG,CAACV,IAAI,CAACW,GAAG,CAACJ,EAAE,CAAC,EAAEP,IAAI,CAACW,GAAG,CAACH,EAAE,CAAC,CAAC;IAEhD,IAAII,UAAU,GAAGL,EAAE,GAAGE,KAAK;IAC3B,IAAII,UAAU,GAAGL,EAAE,GAAGC,KAAK;IAE3B,IAAIK,CAAC,GAAGT,IAAI,CAAC,CAAC,CAAC;IACf,IAAIU,CAAC,GAAGV,IAAI,CAAC,CAAC,CAAC;IAEf,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIP,KAAK,EAAEO,CAAC,EAAE,EAAE;MAC/B,IAAIC,MAAM,GAAGjB,IAAI,CAACkB,KAAK,CAACJ,CAAC,CAAC;MAC1B,IAAIK,MAAM,GAAGnB,IAAI,CAACkB,KAAK,CAACH,CAAC,CAAC;MAC1B,IACEE,MAAM,IAAI,CAAC,IACXE,MAAM,IAAI,CAAC,IACXF,MAAM,GAAG,IAAI,CAACG,KAAK,IACnBD,MAAM,GAAG,IAAI,CAACE,MAAM,EACpB;QACA,IAAI,IAAI,CAACvB,QAAQ,KAAK,CAAC,EAAE;UACvB,IAAI,CAACwB,QAAQ,CAACL,MAAM,EAAEE,MAAM,CAAC;QAC/B,CAAC,MAAM;UACL,IAAII,QAAQ,GAAG,CAACN,MAAM,GAAGE,MAAM,GAAG,IAAI,CAACC,KAAK,IAAI,IAAI,CAAClB,QAAQ;UAC7D,KAAK,IAAIsB,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAGzB,cAAc,EAAEyB,OAAO,EAAE,EAAE;YACzD,IAAI,CAACC,IAAI,CAACF,QAAQ,GAAGC,OAAO,CAAC,GAAG9B,KAAK,CAAC8B,OAAO,CAAC;UAChD;QACF;MACF;MAEAV,CAAC,GAAGA,CAAC,GAAGF,UAAU;MAClBG,CAAC,GAAGA,CAAC,GAAGF,UAAU;IACpB;EACF;EAEA,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}