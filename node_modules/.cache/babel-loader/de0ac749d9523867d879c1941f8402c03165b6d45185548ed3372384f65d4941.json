{"ast":null,"code":"import * as Model from '../image/model/model';\n\n/**\n * Specify which channels should be processed\n * * undefined : we take all the channels but alpha\n * * number : this specific channel\n * * string : converted to a channel based on rgb, cmyk, hsl or hsv (one letter code)\n * * [number] : array of channels as numbers\n * * [string] : array of channels as one letter string\n * @typedef {undefined|number|string|Array<number>|Array<string>} SelectedChannels\n */\n\nexport function validateArrayOfChannels(image, options = {}) {\n  let {\n    channels,\n    allowAlpha,\n    // are we allowing the selection of an alpha channel ?\n    defaultAlpha // if no channels are selected should we take the alpha channel ?\n  } = options;\n  if (typeof allowAlpha !== 'boolean') {\n    allowAlpha = true;\n  }\n  if (typeof channels === 'undefined') {\n    return allChannels(image, defaultAlpha);\n  } else {\n    return validateChannels(image, channels, allowAlpha);\n  }\n}\nfunction allChannels(image, defaultAlpha) {\n  let length = defaultAlpha ? image.channels : image.components;\n  let array = new Array(length);\n  for (let i = 0; i < length; i++) {\n    array[i] = i;\n  }\n  return array;\n}\nfunction validateChannels(image, channels, allowAlpha) {\n  if (!Array.isArray(channels)) {\n    channels = [channels];\n  }\n  for (let c = 0; c < channels.length; c++) {\n    channels[c] = validateChannel(image, channels[c], allowAlpha);\n  }\n  return channels;\n}\nexport function validateChannel(image, channel, allowAlpha = true) {\n  if (channel === undefined) {\n    throw new RangeError(`validateChannel : the channel has to be >=0 and <${image.channels}`);\n  }\n  if (typeof channel === 'string') {\n    switch (image.colorModel) {\n      case Model.GREY:\n        break;\n      case Model.RGB:\n        if ('rgb'.includes(channel)) {\n          switch (channel) {\n            case 'r':\n              channel = 0;\n              break;\n            case 'g':\n              channel = 1;\n              break;\n            case 'b':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n        break;\n      case Model.HSL:\n        if ('hsl'.includes(channel)) {\n          switch (channel) {\n            case 'h':\n              channel = 0;\n              break;\n            case 's':\n              channel = 1;\n              break;\n            case 'l':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n        break;\n      case Model.HSV:\n        if ('hsv'.includes(channel)) {\n          switch (channel) {\n            case 'h':\n              channel = 0;\n              break;\n            case 's':\n              channel = 1;\n              break;\n            case 'v':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n        break;\n      case Model.CMYK:\n        if ('cmyk'.includes(channel)) {\n          switch (channel) {\n            case 'c':\n              channel = 0;\n              break;\n            case 'm':\n              channel = 1;\n              break;\n            case 'y':\n              channel = 2;\n              break;\n            case 'k':\n              channel = 3;\n              break;\n            // no default\n          }\n        }\n        break;\n      default:\n        throw new Error(`Unexpected color model: ${image.colorModel}`);\n    }\n    if (channel === 'a') {\n      if (!image.alpha) {\n        throw new Error('validateChannel : the image does not contain alpha channel');\n      }\n      channel = image.components;\n    }\n    if (typeof channel === 'string') {\n      throw new Error(`validateChannel : undefined channel: ${channel}`);\n    }\n  }\n  if (channel >= image.channels) {\n    throw new RangeError(`validateChannel : the channel has to be >=0 and <${image.channels}`);\n  }\n  if (!allowAlpha && channel >= image.components) {\n    throw new RangeError('validateChannel : alpha channel may not be selected');\n  }\n  return channel;\n}","map":{"version":3,"names":["Model","validateArrayOfChannels","image","options","channels","allowAlpha","defaultAlpha","allChannels","validateChannels","length","components","array","Array","i","isArray","c","validateChannel","channel","undefined","RangeError","colorModel","GREY","RGB","includes","HSL","HSV","CMYK","Error","alpha"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/util/channel.js"],"sourcesContent":["import * as Model from '../image/model/model';\n\n/**\n * Specify which channels should be processed\n * * undefined : we take all the channels but alpha\n * * number : this specific channel\n * * string : converted to a channel based on rgb, cmyk, hsl or hsv (one letter code)\n * * [number] : array of channels as numbers\n * * [string] : array of channels as one letter string\n * @typedef {undefined|number|string|Array<number>|Array<string>} SelectedChannels\n */\n\nexport function validateArrayOfChannels(image, options = {}) {\n  let {\n    channels,\n    allowAlpha, // are we allowing the selection of an alpha channel ?\n    defaultAlpha, // if no channels are selected should we take the alpha channel ?\n  } = options;\n\n  if (typeof allowAlpha !== 'boolean') {\n    allowAlpha = true;\n  }\n\n  if (typeof channels === 'undefined') {\n    return allChannels(image, defaultAlpha);\n  } else {\n    return validateChannels(image, channels, allowAlpha);\n  }\n}\n\nfunction allChannels(image, defaultAlpha) {\n  let length = defaultAlpha ? image.channels : image.components;\n  let array = new Array(length);\n  for (let i = 0; i < length; i++) {\n    array[i] = i;\n  }\n  return array;\n}\n\nfunction validateChannels(image, channels, allowAlpha) {\n  if (!Array.isArray(channels)) {\n    channels = [channels];\n  }\n  for (let c = 0; c < channels.length; c++) {\n    channels[c] = validateChannel(image, channels[c], allowAlpha);\n  }\n  return channels;\n}\n\nexport function validateChannel(image, channel, allowAlpha = true) {\n  if (channel === undefined) {\n    throw new RangeError(\n      `validateChannel : the channel has to be >=0 and <${image.channels}`,\n    );\n  }\n\n  if (typeof channel === 'string') {\n    switch (image.colorModel) {\n      case Model.GREY:\n        break;\n      case Model.RGB:\n        if ('rgb'.includes(channel)) {\n          switch (channel) {\n            case 'r':\n              channel = 0;\n              break;\n            case 'g':\n              channel = 1;\n              break;\n            case 'b':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n        break;\n      case Model.HSL:\n        if ('hsl'.includes(channel)) {\n          switch (channel) {\n            case 'h':\n              channel = 0;\n              break;\n            case 's':\n              channel = 1;\n              break;\n            case 'l':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n        break;\n      case Model.HSV:\n        if ('hsv'.includes(channel)) {\n          switch (channel) {\n            case 'h':\n              channel = 0;\n              break;\n            case 's':\n              channel = 1;\n              break;\n            case 'v':\n              channel = 2;\n              break;\n            // no default\n          }\n        }\n        break;\n      case Model.CMYK:\n        if ('cmyk'.includes(channel)) {\n          switch (channel) {\n            case 'c':\n              channel = 0;\n              break;\n            case 'm':\n              channel = 1;\n              break;\n            case 'y':\n              channel = 2;\n              break;\n            case 'k':\n              channel = 3;\n              break;\n            // no default\n          }\n        }\n        break;\n      default:\n        throw new Error(`Unexpected color model: ${image.colorModel}`);\n    }\n\n    if (channel === 'a') {\n      if (!image.alpha) {\n        throw new Error(\n          'validateChannel : the image does not contain alpha channel',\n        );\n      }\n      channel = image.components;\n    }\n\n    if (typeof channel === 'string') {\n      throw new Error(`validateChannel : undefined channel: ${channel}`);\n    }\n  }\n\n  if (channel >= image.channels) {\n    throw new RangeError(\n      `validateChannel : the channel has to be >=0 and <${image.channels}`,\n    );\n  }\n\n  if (!allowAlpha && channel >= image.components) {\n    throw new RangeError('validateChannel : alpha channel may not be selected');\n  }\n\n  return channel;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}