{"ast":null,"code":"import { Matrix, SVD } from 'ml-matrix';\nimport BaseRegression from 'ml-regression-base';\nconst defaultOptions = {\n  order: 2\n};\n// Implements the Kernel ridge regression algorithm.\n// http://www.ics.uci.edu/~welling/classnotes/papers_class/Kernel-Ridge.pdf\nexport default class PolynomialFitRegression2D extends BaseRegression {\n  /**\n   * Constructor for the 2D polynomial fitting\n   *\n   * @param inputs\n   * @param outputs\n   * @param options\n   * @constructor\n   */\n  constructor(inputs, outputs, options) {\n    super();\n    if (inputs === true) {\n      // reloading model\n      this.coefficients = Matrix.columnVector(outputs.coefficients);\n      this.order = outputs.order;\n      if (outputs.r) {\n        this.r = outputs.r;\n        this.r2 = outputs.r2;\n      }\n      if (outputs.chi2) {\n        this.chi2 = outputs.chi2;\n      }\n    } else {\n      options = Object.assign({}, defaultOptions, options);\n      this.order = options.order;\n      this.coefficients = [];\n      this.X = inputs;\n      this.y = outputs;\n      this.train(this.X, this.y, options);\n    }\n  }\n\n  /**\n   * Function that fits the model given the data(X) and predictions(y).\n   * The third argument is an object with the following options:\n   * * order: order of the polynomial to fit.\n   *\n   * @param {Matrix} X - A matrix with n rows and 2 columns.\n   * @param {Matrix} y - A vector of the prediction values.\n   */\n  train(X, y) {\n    if (!Matrix.isMatrix(X)) X = new Matrix(X);\n    if (!Matrix.isMatrix(y)) y = Matrix.columnVector(y);\n    if (y.rows !== X.rows) {\n      y = y.transpose();\n    }\n    if (X.columns !== 2) {\n      throw new RangeError(`You give X with ${X.columns} columns and it must be 2`);\n    }\n    if (X.rows !== y.rows) {\n      throw new RangeError('X and y must have the same rows');\n    }\n    var examples = X.rows;\n    var coefficients = (this.order + 2) * (this.order + 1) / 2;\n    this.coefficients = new Array(coefficients);\n    var x1 = X.getColumnVector(0);\n    var x2 = X.getColumnVector(1);\n    var scaleX1 = 1.0 / x1.clone().abs().max();\n    var scaleX2 = 1.0 / x2.clone().abs().max();\n    var scaleY = 1.0 / y.clone().abs().max();\n    x1.mulColumn(0, scaleX1);\n    x2.mulColumn(0, scaleX2);\n    y.mulColumn(0, scaleY);\n    var A = new Matrix(examples, coefficients);\n    var col = 0;\n    for (var i = 0; i <= this.order; ++i) {\n      var limit = this.order - i;\n      for (var j = 0; j <= limit; ++j) {\n        var result = powColVector(x1, i).mulColumnVector(powColVector(x2, j));\n        A.setColumn(col, result);\n        col++;\n      }\n    }\n    var svd = new SVD(A.transpose(), {\n      computeLeftSingularVectors: true,\n      computeRightSingularVectors: true,\n      autoTranspose: false\n    });\n    var qqs = Matrix.rowVector(svd.diagonal);\n    qqs = qqs.apply(function (i, j) {\n      if (this.get(i, j) >= 1e-15) this.set(i, j, 1 / this.get(i, j));else this.set(i, j, 0);\n    });\n    var qqs1 = Matrix.zeros(examples, coefficients);\n    for (i = 0; i < coefficients; ++i) {\n      qqs1.set(i, i, qqs.get(0, i));\n    }\n    qqs = qqs1;\n    var U = svd.rightSingularVectors;\n    var V = svd.leftSingularVectors;\n    this.coefficients = V.mmul(qqs.transpose()).mmul(U.transpose()).mmul(y);\n    col = 0;\n    for (i = 0; i <= coefficients; ++i) {\n      limit = this.order - i;\n      for (j = 0; j <= limit; ++j) {\n        this.coefficients.set(col, 0, this.coefficients.get(col, 0) * Math.pow(scaleX1, i) * Math.pow(scaleX2, j) / scaleY);\n        col++;\n      }\n    }\n  }\n  _predict(newInputs) {\n    var x1 = newInputs[0];\n    var x2 = newInputs[1];\n    var y = 0;\n    var column = 0;\n    for (var i = 0; i <= this.order; i++) {\n      for (var j = 0; j <= this.order - i; j++) {\n        y += Math.pow(x1, i) * Math.pow(x2, j) * this.coefficients.get(column, 0);\n        column++;\n      }\n    }\n    return y;\n  }\n  toJSON() {\n    return {\n      name: 'polyfit2D',\n      order: this.order,\n      coefficients: this.coefficients\n    };\n  }\n  static load(json) {\n    if (json.name !== 'polyfit2D') {\n      throw new TypeError('not a polyfit2D model');\n    }\n    return new PolynomialFitRegression2D(true, json);\n  }\n}\n\n/**\n * Function that given a column vector return this: vector^power\n *\n * @param x - Column vector.\n * @param power - Pow number.\n * @return {Suite|Matrix}\n */\nfunction powColVector(x, power) {\n  var result = x.clone();\n  for (var i = 0; i < x.rows; ++i) {\n    result.set(i, 0, Math.pow(result.get(i, 0), power));\n  }\n  return result;\n}","map":{"version":3,"names":["Matrix","SVD","BaseRegression","defaultOptions","order","PolynomialFitRegression2D","constructor","inputs","outputs","options","coefficients","columnVector","r","r2","chi2","Object","assign","X","y","train","isMatrix","rows","transpose","columns","RangeError","examples","Array","x1","getColumnVector","x2","scaleX1","clone","abs","max","scaleX2","scaleY","mulColumn","A","col","i","limit","j","result","powColVector","mulColumnVector","setColumn","svd","computeLeftSingularVectors","computeRightSingularVectors","autoTranspose","qqs","rowVector","diagonal","apply","get","set","qqs1","zeros","U","rightSingularVectors","V","leftSingularVectors","mmul","Math","pow","_predict","newInputs","column","toJSON","name","load","json","TypeError","x","power"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/ml-regression/src/regression/poly-fit-regression2d.js"],"sourcesContent":["import { Matrix, SVD } from 'ml-matrix';\nimport BaseRegression from 'ml-regression-base';\n\nconst defaultOptions = {\n  order: 2\n};\n// Implements the Kernel ridge regression algorithm.\n// http://www.ics.uci.edu/~welling/classnotes/papers_class/Kernel-Ridge.pdf\nexport default class PolynomialFitRegression2D extends BaseRegression {\n  /**\n   * Constructor for the 2D polynomial fitting\n   *\n   * @param inputs\n   * @param outputs\n   * @param options\n   * @constructor\n   */\n  constructor(inputs, outputs, options) {\n    super();\n    if (inputs === true) {\n      // reloading model\n      this.coefficients = Matrix.columnVector(outputs.coefficients);\n      this.order = outputs.order;\n      if (outputs.r) {\n        this.r = outputs.r;\n        this.r2 = outputs.r2;\n      }\n      if (outputs.chi2) {\n        this.chi2 = outputs.chi2;\n      }\n    } else {\n      options = Object.assign({}, defaultOptions, options);\n      this.order = options.order;\n      this.coefficients = [];\n      this.X = inputs;\n      this.y = outputs;\n\n      this.train(this.X, this.y, options);\n    }\n  }\n\n  /**\n   * Function that fits the model given the data(X) and predictions(y).\n   * The third argument is an object with the following options:\n   * * order: order of the polynomial to fit.\n   *\n   * @param {Matrix} X - A matrix with n rows and 2 columns.\n   * @param {Matrix} y - A vector of the prediction values.\n   */\n  train(X, y) {\n    if (!Matrix.isMatrix(X)) X = new Matrix(X);\n    if (!Matrix.isMatrix(y)) y = Matrix.columnVector(y);\n\n    if (y.rows !== X.rows) {\n      y = y.transpose();\n    }\n\n    if (X.columns !== 2) {\n      throw new RangeError(\n        `You give X with ${X.columns} columns and it must be 2`\n      );\n    }\n    if (X.rows !== y.rows) {\n      throw new RangeError('X and y must have the same rows');\n    }\n\n    var examples = X.rows;\n    var coefficients = ((this.order + 2) * (this.order + 1)) / 2;\n    this.coefficients = new Array(coefficients);\n\n    var x1 = X.getColumnVector(0);\n    var x2 = X.getColumnVector(1);\n\n    var scaleX1 =\n      1.0 /\n      x1\n        .clone()\n        .abs()\n        .max();\n    var scaleX2 =\n      1.0 /\n      x2\n        .clone()\n        .abs()\n        .max();\n    var scaleY =\n      1.0 /\n      y\n        .clone()\n        .abs()\n        .max();\n\n    x1.mulColumn(0, scaleX1);\n    x2.mulColumn(0, scaleX2);\n    y.mulColumn(0, scaleY);\n\n    var A = new Matrix(examples, coefficients);\n    var col = 0;\n\n    for (var i = 0; i <= this.order; ++i) {\n      var limit = this.order - i;\n      for (var j = 0; j <= limit; ++j) {\n        var result = powColVector(x1, i).mulColumnVector(powColVector(x2, j));\n        A.setColumn(col, result);\n        col++;\n      }\n    }\n\n    var svd = new SVD(A.transpose(), {\n      computeLeftSingularVectors: true,\n      computeRightSingularVectors: true,\n      autoTranspose: false\n    });\n\n    var qqs = Matrix.rowVector(svd.diagonal);\n    qqs = qqs.apply(function (i, j) {\n      if (this.get(i, j) >= 1e-15) this.set(i, j, 1 / this.get(i, j));\n      else this.set(i, j, 0);\n    });\n\n    var qqs1 = Matrix.zeros(examples, coefficients);\n    for (i = 0; i < coefficients; ++i) {\n      qqs1.set(i, i, qqs.get(0, i));\n    }\n\n    qqs = qqs1;\n\n    var U = svd.rightSingularVectors;\n    var V = svd.leftSingularVectors;\n\n    this.coefficients = V.mmul(qqs.transpose())\n      .mmul(U.transpose())\n      .mmul(y);\n\n    col = 0;\n\n    for (i = 0; i <= coefficients; ++i) {\n      limit = this.order - i;\n      for (j = 0; j <= limit; ++j) {\n        this.coefficients.set(\n          col,\n          0,\n          (this.coefficients.get(col, 0) *\n            Math.pow(scaleX1, i) *\n            Math.pow(scaleX2, j)) /\n            scaleY\n        );\n        col++;\n      }\n    }\n  }\n\n  _predict(newInputs) {\n    var x1 = newInputs[0];\n    var x2 = newInputs[1];\n\n    var y = 0;\n    var column = 0;\n\n    for (var i = 0; i <= this.order; i++) {\n      for (var j = 0; j <= this.order - i; j++) {\n        y +=\n          Math.pow(x1, i) * Math.pow(x2, j) * this.coefficients.get(column, 0);\n        column++;\n      }\n    }\n\n    return y;\n  }\n\n  toJSON() {\n    return {\n      name: 'polyfit2D',\n      order: this.order,\n      coefficients: this.coefficients\n    };\n  }\n\n  static load(json) {\n    if (json.name !== 'polyfit2D') {\n      throw new TypeError('not a polyfit2D model');\n    }\n    return new PolynomialFitRegression2D(true, json);\n  }\n}\n\n/**\n * Function that given a column vector return this: vector^power\n *\n * @param x - Column vector.\n * @param power - Pow number.\n * @return {Suite|Matrix}\n */\nfunction powColVector(x, power) {\n  var result = x.clone();\n  for (var i = 0; i < x.rows; ++i) {\n    result.set(i, 0, Math.pow(result.get(i, 0), power));\n  }\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}