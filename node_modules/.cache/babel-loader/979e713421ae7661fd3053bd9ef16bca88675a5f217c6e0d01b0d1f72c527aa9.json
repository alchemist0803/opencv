{"ast":null,"code":"import Image from '../Image';\n\n/**\n * Erosion is one of two fundamental operations (with dilatation) in morphological\n * image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local minimum among the pixels with a kernel value of 1.\n * http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html\n * https://en.wikipedia.org/wiki/Erosion_(morphology)\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.kernel] - The kernel can only have ones and zeros. Default: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n * @param {number} [options.iterations=1] - The number of successive erosions\n * @return {Image}\n */\nexport default function erode(options = {}) {\n  let {\n    kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],\n    iterations = 1\n  } = options;\n  this.checkProcessable('erode', {\n    bitDepth: [1, 8, 16],\n    components: 1,\n    alpha: 0\n  });\n  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {\n    throw new TypeError('erode: The number of rows and columns of the kernel must be odd');\n  }\n  let onlyOnes = true;\n  outer: for (const row of kernel) {\n    for (const value of row) {\n      if (value !== 1) {\n        onlyOnes = false;\n        break outer;\n      }\n    }\n  }\n  let result = this;\n  for (let i = 0; i < iterations; i++) {\n    if (this.bitDepth === 1) {\n      if (onlyOnes) {\n        const newImage = result.clone();\n        result = erodeOnceBinaryOnlyOnes(result, newImage, kernel.length, kernel[0].length);\n      } else {\n        const newImage = Image.createFrom(result);\n        result = erodeOnceBinary(result, newImage, kernel);\n      }\n    } else if (onlyOnes) {\n      const newImage = Image.createFrom(result);\n      result = erodeOnceGreyOnlyOnes(result, newImage, kernel.length, kernel[0].length);\n    } else {\n      const newImage = Image.createFrom(result);\n      result = erodeOnceGrey(result, newImage, kernel);\n    }\n  }\n  return result;\n}\nfunction erodeOnceGrey(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n      for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (i < 0 || j < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getValueXY(i, j, 0);\n          if (value < min) min = value;\n        }\n      }\n      newImage.setValueXY(x, y, 0, min);\n    }\n  }\n  return newImage;\n}\nfunction erodeOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n  const minList = [];\n  for (let x = 0; x < img.width; x++) {\n    minList.push(0);\n  }\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n      for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {\n        const value = img.getValueXY(x, h, 0);\n        if (value < min) {\n          min = value;\n        }\n      }\n      minList[x] = min;\n    }\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n      for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {\n        if (minList[i] < min) {\n          min = minList[i];\n        }\n      }\n      newImage.setValueXY(x, y, 0, min);\n    }\n  }\n  return newImage;\n}\nfunction erodeOnceBinary(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = 1;\n      intLoop: for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (j < 0 || i < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getBitXY(i, j);\n          if (value === 0) {\n            min = 0;\n            break intLoop;\n          }\n        }\n      }\n      if (min === 1) {\n        newImage.setBitXY(x, y);\n      }\n    }\n  }\n  return newImage;\n}\nfunction erodeOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n  const minList = [];\n  for (let x = 0; x < img.width; x++) {\n    minList.push(0);\n  }\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      minList[x] = 1;\n      for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {\n        if (img.getBitXY(x, h) === 0) {\n          minList[x] = 0;\n          break;\n        }\n      }\n    }\n    for (let x = 0; x < img.width; x++) {\n      if (newImage.getBitXY(x, y) === 0) continue;\n      for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {\n        if (minList[i] === 0) {\n          newImage.clearBitXY(x, y);\n          break;\n        }\n      }\n    }\n  }\n  return newImage;\n}","map":{"version":3,"names":["Image","erode","options","kernel","iterations","checkProcessable","bitDepth","components","alpha","columns","rows","TypeError","onlyOnes","outer","row","value","result","i","newImage","clone","erodeOnceBinaryOnlyOnes","length","createFrom","erodeOnceBinary","erodeOnceGreyOnlyOnes","erodeOnceGrey","img","kernelWidth","kernelHeight","radiusX","radiusY","y","height","x","width","min","maxValue","jj","ii","j","getValueXY","setValueXY","minList","push","h","Math","max","intLoop","getBitXY","setBitXY","clearBitXY"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/morphology/erode.js"],"sourcesContent":["import Image from '../Image';\n\n/**\n * Erosion is one of two fundamental operations (with dilatation) in morphological\n * image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local minimum among the pixels with a kernel value of 1.\n * http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html\n * https://en.wikipedia.org/wiki/Erosion_(morphology)\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.kernel] - The kernel can only have ones and zeros. Default: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n * @param {number} [options.iterations=1] - The number of successive erosions\n * @return {Image}\n */\nexport default function erode(options = {}) {\n  let {\n    kernel = [\n      [1, 1, 1],\n      [1, 1, 1],\n      [1, 1, 1],\n    ],\n    iterations = 1,\n  } = options;\n\n  this.checkProcessable('erode', {\n    bitDepth: [1, 8, 16],\n    components: 1,\n    alpha: 0,\n  });\n  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {\n    throw new TypeError(\n      'erode: The number of rows and columns of the kernel must be odd',\n    );\n  }\n\n  let onlyOnes = true;\n  outer: for (const row of kernel) {\n    for (const value of row) {\n      if (value !== 1) {\n        onlyOnes = false;\n        break outer;\n      }\n    }\n  }\n\n  let result = this;\n  for (let i = 0; i < iterations; i++) {\n    if (this.bitDepth === 1) {\n      if (onlyOnes) {\n        const newImage = result.clone();\n        result = erodeOnceBinaryOnlyOnes(\n          result,\n          newImage,\n          kernel.length,\n          kernel[0].length,\n        );\n      } else {\n        const newImage = Image.createFrom(result);\n        result = erodeOnceBinary(result, newImage, kernel);\n      }\n    } else if (onlyOnes) {\n      const newImage = Image.createFrom(result);\n      result = erodeOnceGreyOnlyOnes(\n        result,\n        newImage,\n        kernel.length,\n        kernel[0].length,\n      );\n    } else {\n      const newImage = Image.createFrom(result);\n      result = erodeOnceGrey(result, newImage, kernel);\n    }\n  }\n  return result;\n}\n\nfunction erodeOnceGrey(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n      for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (i < 0 || j < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getValueXY(i, j, 0);\n          if (value < min) min = value;\n        }\n      }\n      newImage.setValueXY(x, y, 0, min);\n    }\n  }\n  return newImage;\n}\n\nfunction erodeOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n\n  const minList = [];\n  for (let x = 0; x < img.width; x++) {\n    minList.push(0);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n      for (\n        let h = Math.max(0, y - radiusY);\n        h < Math.min(img.height, y + radiusY + 1);\n        h++\n      ) {\n        const value = img.getValueXY(x, h, 0);\n        if (value < min) {\n          min = value;\n        }\n      }\n      minList[x] = min;\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      let min = img.maxValue;\n      for (\n        let i = Math.max(0, x - radiusX);\n        i < Math.min(img.width, x + radiusX + 1);\n        i++\n      ) {\n        if (minList[i] < min) {\n          min = minList[i];\n        }\n      }\n      newImage.setValueXY(x, y, 0, min);\n    }\n  }\n  return newImage;\n}\n\nfunction erodeOnceBinary(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let min = 1;\n      intLoop: for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (j < 0 || i < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getBitXY(i, j);\n          if (value === 0) {\n            min = 0;\n            break intLoop;\n          }\n        }\n      }\n      if (min === 1) {\n        newImage.setBitXY(x, y);\n      }\n    }\n  }\n  return newImage;\n}\n\nfunction erodeOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n\n  const minList = [];\n  for (let x = 0; x < img.width; x++) {\n    minList.push(0);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      minList[x] = 1;\n      for (\n        let h = Math.max(0, y - radiusY);\n        h < Math.min(img.height, y + radiusY + 1);\n        h++\n      ) {\n        if (img.getBitXY(x, h) === 0) {\n          minList[x] = 0;\n          break;\n        }\n      }\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      if (newImage.getBitXY(x, y) === 0) continue;\n      for (\n        let i = Math.max(0, x - radiusX);\n        i < Math.min(img.width, x + radiusX + 1);\n        i++\n      ) {\n        if (minList[i] === 0) {\n          newImage.clearBitXY(x, y);\n          break;\n        }\n      }\n    }\n  }\n  return newImage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}