{"ast":null,"code":"import bitMethods from './core/bitMethods';\nimport checkProcessable from './core/checkProcessable';\nimport exportMethods from './core/export';\nimport { extendMethod, extendProperty } from './core/extend';\nimport getRGBAData from './core/getRGBAData';\nimport { getKind, verifyKindDefinition, createPixelArray, getTheoreticalPixelArraySize } from './core/kind';\nimport { RGBA } from './core/kindNames';\nimport load from './core/load';\nimport valueMethods from './core/valueMethods';\nimport extend from './extend';\nimport getImageParameters from './internal/getImageParameters';\nimport RoiManager from './roi/manager';\nconst objectToString = Object.prototype.toString;\n\n/**\n * Class representing an image.\n * This class allows to manipulate easily images directly in the browser or in node.\n *\n * This library is designed to deal with scientific images (8 or 16 bit depth) and will be able to open\n * and process jpeg, png and uncompressed tiff images. It is designed to work in the browser\n * as on the server side in node.\n *\n * An image is characterized by:\n * * width and height\n * * colorModel (RGB, HSL, CMYK, GREY, ...)\n * * components: number of components, Grey scale images will have 1 component while RGB will have 3 and CMYK 4.\n * * alpha: 0 or 1 depending if there is an alpha channel. The\n *      alpha channel define the opacity of each pixel\n * * channels: number of channels (components + alpha)\n * * bitDepth : number of bits to define the intensity of a point.\n *      The values may be 1 for a binary image (mask), 8 for a normal image (each\n *      channel contains values between 0 and 255) and 16 for scientific images\n *      (each channel contains values between 0 and 65535).\n *      The png library and tiff library included in image-js allow to deal correctly with\n *      8 and 16 bit depth images.\n * * position : an array of 2 elements that allows to define a relative position\n *      to a parent image. This will be used in a crop or in the management\n *      of Region Of Interests (Roi) for example\n * * data : an array that contains all the points of the image.\n *      Depending the bitDepth Uint8Array (1 bit), Uint8Array (8 bits),\n *      Uint16Array (16 bits), Float32Array (32 bits)\n *\n * In an image there are pixels and points:\n * * A pixel is an array that has as size the number of channels\n * and that contains all the values that define a particular pixel of the image.\n * * A point is an array of 2 elements that contains the x / y coordinate\n * of a specific pixel of the image\n *\n *\n * @class Image\n * @param {number} [width=1]\n * @param {number} [height=1]\n * @param {Array} [data] - Image data to load\n * @param {object} [options]\n *\n *\n * @example\n * // JavaScript code using Node.js to get some info about the image.\n * // We load the library that was installed using 'npm install image-js'\n * const { Image } = require('image-js');\n *\n * // Loading an image is asynchronous and will return a Promise.\n * Image.load('cat.jpg').then(function (image) {\n *   console.log('Width', image.width);\n *   console.log('Height', image.height);\n *   console.log('colorModel', image.colorModel);\n *   console.log('components', image.components);\n *   console.log('alpha', image.alpha);\n *   console.log('channels', image.channels);\n *   console.log('bitDepth', image.bitDepth);\n * });\n *\n * @example\n * // Convert an image to greyscale\n * const { Image } = require('image-js');\n *\n * Image.load('cat.jpg').then(function (image) {\n *   var grey = image.grey();\n *   grey.save('cat-grey.jpg');\n * });\n *\n * @example\n * // Split an RGB image in its components\n * const { Image } = require('image-js');\n *\n * Image.load('cat.jpg').then(function (image) {\n *   var components = image.split();\n *   components[0].save('cat-red.jpg');\n *   components[1].save('cat-green.jpg');\n *   components[2].save('cat-blur.jpg');\n * });\n *\n *\n * @example\n * // For this example you will need the picture of an ecstasy pill that is available on\n * // wget https://raw.githubusercontent.com/image-js/core/854e70f50d63cc73d2dde1d2020fe61ba1b5ec05/test/img/xtc.png // the goal is to isolate the picture and to get a RGB histogram of the pill.\n * // Practically this allows to classify pills based on the histogram similarity\n * // This work was published at: http://dx.doi.org/10.1016/j.forsciint.2012.10.004\n *\n * const { Image } = require('image-js');\n *\n * const image = await Image.load('xtc.png');\n *\n * const grey = image.grey({\n *   algorithm:'lightness'\n * });\n * // we create a mask, which is basically a binary image\n * // a mask has as source a grey image and we will decide how to determine\n * // the threshold to define what is white and what is black\n * var mask = grey.mask({\n *   algorithm: 'li'\n * });\n *\n * // it is possible to create an array of Region Of Interest (Roi) using\n * // the RoiManager. A RoiManager will be applied on the original image\n * // in order to be able to extract from the original image the regions\n *\n * // the result of this console.log result can directly be pasted\n * // in the browser\n * // console.log(mask.toDataURL());\n *\n *\n * var manager = image.getRoiManager();\n * manager.fromMask(mask);\n * var rois = manager.getRoi({\n *   positive: true,\n *   negative: false,\n *   minSurface: 100\n * });\n *\n * // console.log(rois);\n *\n * // we can sort teh rois by surface\n * // for demonstration we use an arrow function\n * rois.sort((a, b) => b.surface - a.surface);\n *\n * // the first Roi (the biggest is expected to be the pill)\n *\n * var pillMask = rois[0].getMask({\n *   scale: 0.7   // we will scale down the mask to take just the center of the pill and avoid border effects\n * });\n *\n * // image-js remembers the parent of the image and the relative\n * // position of a derived image. This is the case for a crop as\n * // well as for Roi\n *\n * var pill = image.extract(pillMask);\n * pill.save('pill.jpg');\n *\n * var histogram = pill.getHistograms({ maxSlots: 16 });\n *\n * console.log(histogram);\n *\n * @example\n * // Example of use of IJS in the browser\n *\n * <script>\n *  var canvas = document.getElementById('myCanvasID');\n *  var image = IJS.fromCanvas(canvas);\n * </script>\n *\n * @example\n * // Image from matrix of values\n * const [min, max] = d3.extent(temperatures)\n * const colorScaler = d3.scaleSequential([min, max], d3.interpolateRdYlBu);\n *\n * // size = rows * columns * channels\n * const data = new Uint8Array(2*3*3);\n * for (let i = 0; i < temperatures.length; i++) {\n *   const {r, g, b} = d3.rgb(colorScaler(temperatures[i]));\n *   data[i*3] = r;\n *   data[i*3 + 1] = g;\n *   data[i*3 + 2] = b;\n * }\n *\n * const image = new Image(2, 3, data, { kind: 'RGB' });\n * // or\n * const image = new Image({ width: 2, height: 3, data, kind: 'RGB'});\n */\nexport default class Image {\n  constructor(width, height, data, options) {\n    if (arguments.length === 1) {\n      options = width;\n      ({\n        width,\n        height,\n        data\n      } = options);\n    } else if (data && !data.length) {\n      options = data;\n      ({\n        data\n      } = options);\n    }\n    if (width === undefined) width = 1;\n    if (height === undefined) height = 1;\n    if (options === undefined) options = {};\n    if (typeof options !== 'object' || options === null) {\n      throw new TypeError('options must be an object');\n    }\n    if (!Number.isInteger(width) || width <= 0) {\n      throw new RangeError('width must be a positive integer');\n    }\n    if (!Number.isInteger(height) || height <= 0) {\n      throw new RangeError('height must be a positive integer');\n    }\n    const {\n      kind = RGBA\n    } = options;\n    if (typeof kind !== 'string') {\n      throw new TypeError('kind must be a string');\n    }\n    const theKind = getKind(kind);\n    const kindDefinition = Object.assign({}, options);\n    for (const prop in theKind) {\n      if (kindDefinition[prop] === undefined) {\n        kindDefinition[prop] = theKind[prop];\n      }\n    }\n    verifyKindDefinition(kindDefinition);\n    const {\n      components,\n      bitDepth,\n      colorModel\n    } = kindDefinition;\n    const alpha = kindDefinition.alpha + 0;\n    const size = width * height;\n    const channels = components + alpha;\n    const maxValue = bitDepth === 32 ? Number.MAX_VALUE : 2 ** bitDepth - 1;\n    if (data === undefined) {\n      data = createPixelArray(size, components, alpha, channels, bitDepth, maxValue);\n    } else {\n      const expectedLength = getTheoreticalPixelArraySize(size, channels, bitDepth);\n      if (data.length !== expectedLength) {\n        throw new RangeError(`incorrect data size: ${data.length}. Should be ${expectedLength}`);\n      }\n    }\n\n    /**\n     * Width of the image.\n     * @member {number}\n     */\n    this.width = width;\n\n    /**\n     * Height of the image.\n     * @member {number}\n     */\n    this.height = height;\n\n    /**\n     * Typed array holding the image data.\n     * @member {TypedArray}\n     */\n    this.data = data;\n\n    /**\n     * Total number of pixels (width * height).\n     * @member {number}\n     */\n    this.size = size;\n\n    /**\n     * Number of color channels in the image.\n     * A grey image has 1 component. An RGB image has 3 components.\n     * @member {number}\n     */\n    this.components = components;\n\n    /**\n     * Alpha is 1 if there is an alpha channel, 0 otherwise.\n     * @member {number}\n     */\n    this.alpha = alpha;\n\n    /**\n     * Number of bits per value in each channel.\n     * @member {number}\n     */\n    this.bitDepth = bitDepth;\n\n    /**\n     * Maximum value that a pixel can have.\n     * @member {number}\n     */\n    this.maxValue = maxValue;\n\n    /**\n     * Color model of the image.\n     * @member {ColorModel}\n     */\n    this.colorModel = colorModel;\n\n    /**\n     * Total number of channels. Is equal to `image.components + image.alpha`.\n     * @member {number}\n     */\n    this.channels = channels;\n\n    /**\n     * Metadata associated with the image.\n     * @member {object}\n     */\n    this.meta = options.meta || {};\n\n    // TODO review those props\n    Object.defineProperty(this, 'parent', {\n      enumerable: false,\n      writable: true,\n      configurable: true,\n      value: options.parent || null\n    });\n    this.position = options.position || [0, 0];\n    this.computed = null;\n    this.sizes = [this.width, this.height];\n    this.multiplierX = this.channels;\n    this.multiplierY = this.channels * this.width;\n    this.isClamped = this.bitDepth < 32;\n    this.borderSizes = [0, 0]; // when a filter creates a border, it may have impact on future processing like Roi\n  }\n  get [Symbol.toStringTag]() {\n    return 'IJSImage';\n  }\n  static isImage(object) {\n    return objectToString.call(object) === '[object IJSImage]';\n  }\n\n  /**\n   * Creates an image from an HTML Canvas object\n   * @param {Canvas} canvas\n   * @return {Image}\n   */\n  static fromCanvas(canvas) {\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    return new Image(imageData.width, imageData.height, imageData.data);\n  }\n\n  /**\n   * Create a new Image based on the characteristics of another one.\n   * @param {Image} other\n   * @param {object} [options] - Override options to change some parameters\n   * @return {Image}\n   * @example\n   * const newImage = Image.createFrom(image, { width: 100 });\n   */\n  static createFrom(other, options) {\n    const newOptions = getImageParameters(other);\n    Object.assign(newOptions, {\n      parent: other,\n      position: [0, 0]\n    }, options);\n    return new Image(newOptions);\n  }\n\n  /**\n   * Create a new manager for regions of interest based on the current image.\n   * @param {object} [options]\n   * @return {RoiManager}\n   */\n  getRoiManager(options) {\n    return new RoiManager(this, options);\n  }\n\n  /**\n   * Create a copy a the current image, including its data.\n   * @instance\n   * @return {Image}\n   */\n  clone() {\n    const newData = this.data.slice();\n    return new Image(this.width, this.height, newData, this);\n  }\n  apply(filter) {\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        let index = (y * this.width + x) * this.channels;\n        filter.call(this, index);\n      }\n    }\n  }\n}\nvalueMethods(Image);\nbitMethods(Image);\nexportMethods(Image);\nImage.prototype.checkProcessable = checkProcessable;\nImage.prototype.getRGBAData = getRGBAData;\nImage.load = load;\nImage.extendMethod = extendMethod;\nImage.extendProperty = extendProperty;\nextend(Image);","map":{"version":3,"names":["bitMethods","checkProcessable","exportMethods","extendMethod","extendProperty","getRGBAData","getKind","verifyKindDefinition","createPixelArray","getTheoreticalPixelArraySize","RGBA","load","valueMethods","extend","getImageParameters","RoiManager","objectToString","Object","prototype","toString","Image","constructor","width","height","data","options","arguments","length","undefined","TypeError","Number","isInteger","RangeError","kind","theKind","kindDefinition","assign","prop","components","bitDepth","colorModel","alpha","size","channels","maxValue","MAX_VALUE","expectedLength","meta","defineProperty","enumerable","writable","configurable","value","parent","position","computed","sizes","multiplierX","multiplierY","isClamped","borderSizes","Symbol","toStringTag","isImage","object","call","fromCanvas","canvas","ctx","getContext","imageData","getImageData","createFrom","other","newOptions","getRoiManager","clone","newData","slice","apply","filter","y","x","index"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/Image.js"],"sourcesContent":["import bitMethods from './core/bitMethods';\nimport checkProcessable from './core/checkProcessable';\nimport exportMethods from './core/export';\nimport { extendMethod, extendProperty } from './core/extend';\nimport getRGBAData from './core/getRGBAData';\nimport {\n  getKind,\n  verifyKindDefinition,\n  createPixelArray,\n  getTheoreticalPixelArraySize,\n} from './core/kind';\nimport { RGBA } from './core/kindNames';\nimport load from './core/load';\nimport valueMethods from './core/valueMethods';\nimport extend from './extend';\nimport getImageParameters from './internal/getImageParameters';\nimport RoiManager from './roi/manager';\n\nconst objectToString = Object.prototype.toString;\n\n/**\n * Class representing an image.\n * This class allows to manipulate easily images directly in the browser or in node.\n *\n * This library is designed to deal with scientific images (8 or 16 bit depth) and will be able to open\n * and process jpeg, png and uncompressed tiff images. It is designed to work in the browser\n * as on the server side in node.\n *\n * An image is characterized by:\n * * width and height\n * * colorModel (RGB, HSL, CMYK, GREY, ...)\n * * components: number of components, Grey scale images will have 1 component while RGB will have 3 and CMYK 4.\n * * alpha: 0 or 1 depending if there is an alpha channel. The\n *      alpha channel define the opacity of each pixel\n * * channels: number of channels (components + alpha)\n * * bitDepth : number of bits to define the intensity of a point.\n *      The values may be 1 for a binary image (mask), 8 for a normal image (each\n *      channel contains values between 0 and 255) and 16 for scientific images\n *      (each channel contains values between 0 and 65535).\n *      The png library and tiff library included in image-js allow to deal correctly with\n *      8 and 16 bit depth images.\n * * position : an array of 2 elements that allows to define a relative position\n *      to a parent image. This will be used in a crop or in the management\n *      of Region Of Interests (Roi) for example\n * * data : an array that contains all the points of the image.\n *      Depending the bitDepth Uint8Array (1 bit), Uint8Array (8 bits),\n *      Uint16Array (16 bits), Float32Array (32 bits)\n *\n * In an image there are pixels and points:\n * * A pixel is an array that has as size the number of channels\n * and that contains all the values that define a particular pixel of the image.\n * * A point is an array of 2 elements that contains the x / y coordinate\n * of a specific pixel of the image\n *\n *\n * @class Image\n * @param {number} [width=1]\n * @param {number} [height=1]\n * @param {Array} [data] - Image data to load\n * @param {object} [options]\n *\n *\n * @example\n * // JavaScript code using Node.js to get some info about the image.\n * // We load the library that was installed using 'npm install image-js'\n * const { Image } = require('image-js');\n *\n * // Loading an image is asynchronous and will return a Promise.\n * Image.load('cat.jpg').then(function (image) {\n *   console.log('Width', image.width);\n *   console.log('Height', image.height);\n *   console.log('colorModel', image.colorModel);\n *   console.log('components', image.components);\n *   console.log('alpha', image.alpha);\n *   console.log('channels', image.channels);\n *   console.log('bitDepth', image.bitDepth);\n * });\n *\n * @example\n * // Convert an image to greyscale\n * const { Image } = require('image-js');\n *\n * Image.load('cat.jpg').then(function (image) {\n *   var grey = image.grey();\n *   grey.save('cat-grey.jpg');\n * });\n *\n * @example\n * // Split an RGB image in its components\n * const { Image } = require('image-js');\n *\n * Image.load('cat.jpg').then(function (image) {\n *   var components = image.split();\n *   components[0].save('cat-red.jpg');\n *   components[1].save('cat-green.jpg');\n *   components[2].save('cat-blur.jpg');\n * });\n *\n *\n * @example\n * // For this example you will need the picture of an ecstasy pill that is available on\n * // wget https://raw.githubusercontent.com/image-js/core/854e70f50d63cc73d2dde1d2020fe61ba1b5ec05/test/img/xtc.png // the goal is to isolate the picture and to get a RGB histogram of the pill.\n * // Practically this allows to classify pills based on the histogram similarity\n * // This work was published at: http://dx.doi.org/10.1016/j.forsciint.2012.10.004\n *\n * const { Image } = require('image-js');\n *\n * const image = await Image.load('xtc.png');\n *\n * const grey = image.grey({\n *   algorithm:'lightness'\n * });\n * // we create a mask, which is basically a binary image\n * // a mask has as source a grey image and we will decide how to determine\n * // the threshold to define what is white and what is black\n * var mask = grey.mask({\n *   algorithm: 'li'\n * });\n *\n * // it is possible to create an array of Region Of Interest (Roi) using\n * // the RoiManager. A RoiManager will be applied on the original image\n * // in order to be able to extract from the original image the regions\n *\n * // the result of this console.log result can directly be pasted\n * // in the browser\n * // console.log(mask.toDataURL());\n *\n *\n * var manager = image.getRoiManager();\n * manager.fromMask(mask);\n * var rois = manager.getRoi({\n *   positive: true,\n *   negative: false,\n *   minSurface: 100\n * });\n *\n * // console.log(rois);\n *\n * // we can sort teh rois by surface\n * // for demonstration we use an arrow function\n * rois.sort((a, b) => b.surface - a.surface);\n *\n * // the first Roi (the biggest is expected to be the pill)\n *\n * var pillMask = rois[0].getMask({\n *   scale: 0.7   // we will scale down the mask to take just the center of the pill and avoid border effects\n * });\n *\n * // image-js remembers the parent of the image and the relative\n * // position of a derived image. This is the case for a crop as\n * // well as for Roi\n *\n * var pill = image.extract(pillMask);\n * pill.save('pill.jpg');\n *\n * var histogram = pill.getHistograms({ maxSlots: 16 });\n *\n * console.log(histogram);\n *\n * @example\n * // Example of use of IJS in the browser\n *\n * <script>\n *  var canvas = document.getElementById('myCanvasID');\n *  var image = IJS.fromCanvas(canvas);\n * </script>\n *\n * @example\n * // Image from matrix of values\n * const [min, max] = d3.extent(temperatures)\n * const colorScaler = d3.scaleSequential([min, max], d3.interpolateRdYlBu);\n *\n * // size = rows * columns * channels\n * const data = new Uint8Array(2*3*3);\n * for (let i = 0; i < temperatures.length; i++) {\n *   const {r, g, b} = d3.rgb(colorScaler(temperatures[i]));\n *   data[i*3] = r;\n *   data[i*3 + 1] = g;\n *   data[i*3 + 2] = b;\n * }\n *\n * const image = new Image(2, 3, data, { kind: 'RGB' });\n * // or\n * const image = new Image({ width: 2, height: 3, data, kind: 'RGB'});\n */\nexport default class Image {\n  constructor(width, height, data, options) {\n    if (arguments.length === 1) {\n      options = width;\n      ({ width, height, data } = options);\n    } else if (data && !data.length) {\n      options = data;\n      ({ data } = options);\n    }\n    if (width === undefined) width = 1;\n    if (height === undefined) height = 1;\n    if (options === undefined) options = {};\n\n    if (typeof options !== 'object' || options === null) {\n      throw new TypeError('options must be an object');\n    }\n\n    if (!Number.isInteger(width) || width <= 0) {\n      throw new RangeError('width must be a positive integer');\n    }\n    if (!Number.isInteger(height) || height <= 0) {\n      throw new RangeError('height must be a positive integer');\n    }\n\n    const { kind = RGBA } = options;\n    if (typeof kind !== 'string') {\n      throw new TypeError('kind must be a string');\n    }\n    const theKind = getKind(kind);\n    const kindDefinition = Object.assign({}, options);\n    for (const prop in theKind) {\n      if (kindDefinition[prop] === undefined) {\n        kindDefinition[prop] = theKind[prop];\n      }\n    }\n    verifyKindDefinition(kindDefinition);\n\n    const { components, bitDepth, colorModel } = kindDefinition;\n    const alpha = kindDefinition.alpha + 0;\n    const size = width * height;\n    const channels = components + alpha;\n    const maxValue = bitDepth === 32 ? Number.MAX_VALUE : 2 ** bitDepth - 1;\n\n    if (data === undefined) {\n      data = createPixelArray(\n        size,\n        components,\n        alpha,\n        channels,\n        bitDepth,\n        maxValue,\n      );\n    } else {\n      const expectedLength = getTheoreticalPixelArraySize(\n        size,\n        channels,\n        bitDepth,\n      );\n      if (data.length !== expectedLength) {\n        throw new RangeError(\n          `incorrect data size: ${data.length}. Should be ${expectedLength}`,\n        );\n      }\n    }\n\n    /**\n     * Width of the image.\n     * @member {number}\n     */\n    this.width = width;\n\n    /**\n     * Height of the image.\n     * @member {number}\n     */\n    this.height = height;\n\n    /**\n     * Typed array holding the image data.\n     * @member {TypedArray}\n     */\n    this.data = data;\n\n    /**\n     * Total number of pixels (width * height).\n     * @member {number}\n     */\n    this.size = size;\n\n    /**\n     * Number of color channels in the image.\n     * A grey image has 1 component. An RGB image has 3 components.\n     * @member {number}\n     */\n    this.components = components;\n\n    /**\n     * Alpha is 1 if there is an alpha channel, 0 otherwise.\n     * @member {number}\n     */\n    this.alpha = alpha;\n\n    /**\n     * Number of bits per value in each channel.\n     * @member {number}\n     */\n    this.bitDepth = bitDepth;\n\n    /**\n     * Maximum value that a pixel can have.\n     * @member {number}\n     */\n    this.maxValue = maxValue;\n\n    /**\n     * Color model of the image.\n     * @member {ColorModel}\n     */\n    this.colorModel = colorModel;\n\n    /**\n     * Total number of channels. Is equal to `image.components + image.alpha`.\n     * @member {number}\n     */\n    this.channels = channels;\n\n    /**\n     * Metadata associated with the image.\n     * @member {object}\n     */\n    this.meta = options.meta || {};\n\n    // TODO review those props\n    Object.defineProperty(this, 'parent', {\n      enumerable: false,\n      writable: true,\n      configurable: true,\n      value: options.parent || null,\n    });\n    this.position = options.position || [0, 0];\n\n    this.computed = null;\n    this.sizes = [this.width, this.height];\n    this.multiplierX = this.channels;\n    this.multiplierY = this.channels * this.width;\n    this.isClamped = this.bitDepth < 32;\n    this.borderSizes = [0, 0]; // when a filter creates a border, it may have impact on future processing like Roi\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'IJSImage';\n  }\n\n  static isImage(object) {\n    return objectToString.call(object) === '[object IJSImage]';\n  }\n\n  /**\n   * Creates an image from an HTML Canvas object\n   * @param {Canvas} canvas\n   * @return {Image}\n   */\n  static fromCanvas(canvas) {\n    const ctx = canvas.getContext('2d');\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    return new Image(imageData.width, imageData.height, imageData.data);\n  }\n\n  /**\n   * Create a new Image based on the characteristics of another one.\n   * @param {Image} other\n   * @param {object} [options] - Override options to change some parameters\n   * @return {Image}\n   * @example\n   * const newImage = Image.createFrom(image, { width: 100 });\n   */\n  static createFrom(other, options) {\n    const newOptions = getImageParameters(other);\n    Object.assign(\n      newOptions,\n      {\n        parent: other,\n        position: [0, 0],\n      },\n      options,\n    );\n    return new Image(newOptions);\n  }\n\n  /**\n   * Create a new manager for regions of interest based on the current image.\n   * @param {object} [options]\n   * @return {RoiManager}\n   */\n  getRoiManager(options) {\n    return new RoiManager(this, options);\n  }\n\n  /**\n   * Create a copy a the current image, including its data.\n   * @instance\n   * @return {Image}\n   */\n  clone() {\n    const newData = this.data.slice();\n    return new Image(this.width, this.height, newData, this);\n  }\n\n  apply(filter) {\n    for (let y = 0; y < this.height; y++) {\n      for (let x = 0; x < this.width; x++) {\n        let index = (y * this.width + x) * this.channels;\n        filter.call(this, index);\n      }\n    }\n  }\n}\n\nvalueMethods(Image);\nbitMethods(Image);\nexportMethods(Image);\n\nImage.prototype.checkProcessable = checkProcessable;\nImage.prototype.getRGBAData = getRGBAData;\n\nImage.load = load;\nImage.extendMethod = extendMethod;\nImage.extendProperty = extendProperty;\nextend(Image);\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,mBAAmB;AAC1C,OAAOC,gBAAgB,MAAM,yBAAyB;AACtD,OAAOC,aAAa,MAAM,eAAe;AACzC,SAASC,YAAY,EAAEC,cAAc,QAAQ,eAAe;AAC5D,OAAOC,WAAW,MAAM,oBAAoB;AAC5C,SACEC,OAAO,EACPC,oBAAoB,EACpBC,gBAAgB,EAChBC,4BAA4B,QACvB,aAAa;AACpB,SAASC,IAAI,QAAQ,kBAAkB;AACvC,OAAOC,IAAI,MAAM,aAAa;AAC9B,OAAOC,YAAY,MAAM,qBAAqB;AAC9C,OAAOC,MAAM,MAAM,UAAU;AAC7B,OAAOC,kBAAkB,MAAM,+BAA+B;AAC9D,OAAOC,UAAU,MAAM,eAAe;AAEtC,MAAMC,cAAc,GAAGC,MAAM,CAACC,SAAS,CAACC,QAAQ;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}