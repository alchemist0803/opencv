{"ast":null,"code":"import Image from '../Image';\nimport { validInterpolations, checkInterpolation } from '../internal/checks';\nexport default function rotateFree(degrees, options = {}) {\n  const {\n    interpolation = validInterpolations.nearestneighbor,\n    width = this.width,\n    height = this.height\n  } = options;\n  if (typeof degrees !== 'number') {\n    throw new TypeError('degrees must be a number');\n  }\n  const interpolationToUse = (0, checkInterpolation)(interpolation);\n  const radians = degrees * Math.PI / 180;\n  const newWidth = Math.floor(Math.abs(width * Math.cos(radians)) + Math.abs(height * Math.sin(radians)));\n  const newHeight = Math.floor(Math.abs(height * Math.cos(radians)) + Math.abs(width * Math.sin(radians)));\n  const cos = Math.cos(-radians);\n  const sin = Math.sin(-radians);\n  let x0 = newWidth / 2;\n  let y0 = newHeight / 2;\n  if (newWidth % 2 === 0) {\n    x0 = x0 - 0.5;\n    if (newHeight % 2 === 0) {\n      y0 = y0 - 0.5;\n    } else {\n      y0 = Math.floor(y0);\n    }\n  } else {\n    x0 = Math.floor(x0);\n    if (newHeight % 2 === 0) {\n      y0 = y0 - 0.5;\n    } else {\n      y0 = Math.floor(y0);\n    }\n  }\n  const incrementX = Math.floor(width / 2 - x0);\n  const incrementY = Math.floor(height / 2 - y0);\n  if (this.bitDepth === 1) {\n    const newImage = new Image(newWidth, newHeight, {\n      kind: 'BINARY',\n      parent: this\n    });\n    switch (interpolationToUse) {\n      case validInterpolations.nearestneighbor:\n        return rotateBinaryNearestNeighbor(this, newImage, incrementX, incrementY, x0, y0, cos, sin);\n      case validInterpolations.bilinear:\n        return rotateBinaryBilinear(this, newImage, incrementX, incrementY, x0, y0, cos, sin);\n      default:\n        throw new Error(`unsupported rotate interpolation: ${interpolationToUse}`);\n    }\n  } else {\n    const newImage = Image.createFrom(this, {\n      width: newWidth,\n      height: newHeight\n    });\n    switch (interpolationToUse) {\n      case validInterpolations.nearestneighbor:\n        return rotateNearestNeighbor(this, newImage, incrementX, incrementY, x0, y0, cos, sin);\n      case validInterpolations.bilinear:\n        return rotateBilinear(this, newImage, incrementX, incrementY, x0, y0, cos, sin);\n      default:\n        throw new Error(`unsupported rotate interpolation: ${interpolationToUse}`);\n    }\n  }\n}\nfunction rotateNearestNeighbor(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {\n  for (let i = 0; i < newImage.width; i += 1) {\n    for (let j = 0; j < newImage.height; j += 1) {\n      for (let c = 0; c < thisImage.channels; c++) {\n        let x = Math.round((i - x0) * cos - (j - y0) * sin + x0) + incrementX;\n        let y = Math.round((j - y0) * cos + (i - x0) * sin + y0) + incrementY;\n        if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n          if (thisImage.alpha === 1 && c === thisImage.channels - 1) {\n            newImage.setValueXY(i, j, c, 0);\n          } else {\n            newImage.setValueXY(i, j, c, thisImage.maxValue);\n          }\n        } else {\n          newImage.setValueXY(i, j, c, thisImage.getValueXY(x, y, c));\n        }\n      }\n    }\n  }\n  return newImage;\n}\nfunction rotateBinaryNearestNeighbor(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {\n  for (let i = 0; i < newImage.width; i += 1) {\n    for (let j = 0; j < newImage.height; j += 1) {\n      let x = Math.round((i - x0) * cos - (j - y0) * sin + x0) + incrementX;\n      let y = Math.round((j - y0) * cos + (i - x0) * sin + y0) + incrementY;\n      if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height || thisImage.getBitXY(x, y)) {\n        newImage.setBitXY(i, j);\n      }\n    }\n  }\n  return newImage;\n}\nfunction rotateBilinear(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {\n  let stride = thisImage.width * thisImage.channels;\n  for (let j = 0; j < newImage.height; j++) {\n    for (let i = 0; i < newImage.width; i++) {\n      let x = (i - x0) * cos - (j - y0) * sin + x0 + incrementX;\n      let y = (j - y0) * cos + (i - x0) * sin + y0 + incrementY;\n      let x1 = x | 0;\n      let y1 = y | 0;\n      let xDiff = x - x1;\n      let yDiff = y - y1;\n      for (let c = 0; c < thisImage.channels; c++) {\n        if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n          if (thisImage.alpha === 1 && c === thisImage.channels - 1) {\n            newImage.setValueXY(i, j, c, 0);\n          } else {\n            newImage.setValueXY(i, j, c, thisImage.maxValue);\n          }\n        } else {\n          let index = (y1 * thisImage.width + x1) * thisImage.channels + c;\n          let A = thisImage.data[index];\n          let B = thisImage.data[index + thisImage.channels];\n          let C = thisImage.data[index + stride];\n          let D = thisImage.data[index + stride + thisImage.channels];\n          let result = A + xDiff * (B - A) + yDiff * (C - A) + xDiff * yDiff * (A - B - C + D) | 0;\n          newImage.setValueXY(i, j, c, result);\n        }\n      }\n    }\n  }\n  return newImage;\n}\nfunction rotateBinaryBilinear(thisImage, newImage, incrementX, incrementY, x0, y0, cos, sin) {\n  let stride = thisImage.width;\n  for (let j = 0; j < newImage.height; j++) {\n    for (let i = 0; i < newImage.width; i++) {\n      let x = (i - x0) * cos - (j - y0) * sin + x0 + incrementX;\n      let y = (j - y0) * cos + (i - x0) * sin + y0 + incrementY;\n      let x1 = x | 0;\n      let y1 = y | 0;\n      let xDiff = x - x1;\n      let yDiff = y - y1;\n      if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n        newImage.setBitXY(i, j);\n      } else {\n        let index = y1 * thisImage.width + x1;\n        let A = thisImage.getBit(index);\n        let B = thisImage.getBit(index + 1);\n        let C = thisImage.getBit(index + stride);\n        let D = thisImage.getBit(index + 1 + stride);\n        let result = A | xDiff & B - A | yDiff & C - A | xDiff & yDiff & A - B - C + D;\n        if (result > 0) newImage.setBitXY(i, j);\n      }\n    }\n  }\n  return newImage;\n}","map":{"version":3,"names":["Image","validInterpolations","checkInterpolation","rotateFree","degrees","options","interpolation","nearestneighbor","width","height","TypeError","interpolationToUse","radians","Math","PI","newWidth","floor","abs","cos","sin","newHeight","x0","y0","incrementX","incrementY","bitDepth","newImage","kind","parent","rotateBinaryNearestNeighbor","bilinear","rotateBinaryBilinear","Error","createFrom","rotateNearestNeighbor","rotateBilinear","thisImage","i","j","c","channels","x","round","y","alpha","setValueXY","maxValue","getValueXY","getBitXY","setBitXY","stride","x1","y1","xDiff","yDiff","index","A","data","B","C","D","result","getBit"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/rotateFree.js"],"sourcesContent":["import Image from '../Image';\nimport { validInterpolations, checkInterpolation } from '../internal/checks';\n\nexport default function rotateFree(degrees, options = {}) {\n  const {\n    interpolation = validInterpolations.nearestneighbor,\n    width = this.width,\n    height = this.height,\n  } = options;\n\n  if (typeof degrees !== 'number') {\n    throw new TypeError('degrees must be a number');\n  }\n\n  const interpolationToUse = (0, checkInterpolation)(interpolation);\n  const radians = (degrees * Math.PI) / 180;\n  const newWidth = Math.floor(\n    Math.abs(width * Math.cos(radians)) + Math.abs(height * Math.sin(radians)),\n  );\n  const newHeight = Math.floor(\n    Math.abs(height * Math.cos(radians)) + Math.abs(width * Math.sin(radians)),\n  );\n\n  const cos = Math.cos(-radians);\n  const sin = Math.sin(-radians);\n  let x0 = newWidth / 2;\n  let y0 = newHeight / 2;\n\n  if (newWidth % 2 === 0) {\n    x0 = x0 - 0.5;\n\n    if (newHeight % 2 === 0) {\n      y0 = y0 - 0.5;\n    } else {\n      y0 = Math.floor(y0);\n    }\n  } else {\n    x0 = Math.floor(x0);\n\n    if (newHeight % 2 === 0) {\n      y0 = y0 - 0.5;\n    } else {\n      y0 = Math.floor(y0);\n    }\n  }\n\n  const incrementX = Math.floor(width / 2 - x0);\n  const incrementY = Math.floor(height / 2 - y0);\n\n  if (this.bitDepth === 1) {\n    const newImage = new Image(newWidth, newHeight, {\n      kind: 'BINARY',\n      parent: this,\n    });\n\n    switch (interpolationToUse) {\n      case validInterpolations.nearestneighbor:\n        return rotateBinaryNearestNeighbor(\n          this,\n          newImage,\n          incrementX,\n          incrementY,\n          x0,\n          y0,\n          cos,\n          sin,\n        );\n\n      case validInterpolations.bilinear:\n        return rotateBinaryBilinear(\n          this,\n          newImage,\n          incrementX,\n          incrementY,\n          x0,\n          y0,\n          cos,\n          sin,\n        );\n\n      default:\n        throw new Error(\n          `unsupported rotate interpolation: ${interpolationToUse}`,\n        );\n    }\n  } else {\n    const newImage = Image.createFrom(this, {\n      width: newWidth,\n      height: newHeight,\n    });\n\n    switch (interpolationToUse) {\n      case validInterpolations.nearestneighbor:\n        return rotateNearestNeighbor(\n          this,\n          newImage,\n          incrementX,\n          incrementY,\n          x0,\n          y0,\n          cos,\n          sin,\n        );\n\n      case validInterpolations.bilinear:\n        return rotateBilinear(\n          this,\n          newImage,\n          incrementX,\n          incrementY,\n          x0,\n          y0,\n          cos,\n          sin,\n        );\n\n      default:\n        throw new Error(\n          `unsupported rotate interpolation: ${interpolationToUse}`,\n        );\n    }\n  }\n}\n\nfunction rotateNearestNeighbor(\n  thisImage,\n  newImage,\n  incrementX,\n  incrementY,\n  x0,\n  y0,\n  cos,\n  sin,\n) {\n  for (let i = 0; i < newImage.width; i += 1) {\n    for (let j = 0; j < newImage.height; j += 1) {\n      for (let c = 0; c < thisImage.channels; c++) {\n        let x = Math.round((i - x0) * cos - (j - y0) * sin + x0) + incrementX;\n        let y = Math.round((j - y0) * cos + (i - x0) * sin + y0) + incrementY;\n\n        if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n          if (thisImage.alpha === 1 && c === thisImage.channels - 1) {\n            newImage.setValueXY(i, j, c, 0);\n          } else {\n            newImage.setValueXY(i, j, c, thisImage.maxValue);\n          }\n        } else {\n          newImage.setValueXY(i, j, c, thisImage.getValueXY(x, y, c));\n        }\n      }\n    }\n  }\n\n  return newImage;\n}\n\nfunction rotateBinaryNearestNeighbor(\n  thisImage,\n  newImage,\n  incrementX,\n  incrementY,\n  x0,\n  y0,\n  cos,\n  sin,\n) {\n  for (let i = 0; i < newImage.width; i += 1) {\n    for (let j = 0; j < newImage.height; j += 1) {\n      let x = Math.round((i - x0) * cos - (j - y0) * sin + x0) + incrementX;\n      let y = Math.round((j - y0) * cos + (i - x0) * sin + y0) + incrementY;\n\n      if (\n        x < 0 ||\n        x >= thisImage.width ||\n        y < 0 ||\n        y >= thisImage.height ||\n        thisImage.getBitXY(x, y)\n      ) {\n        newImage.setBitXY(i, j);\n      }\n    }\n  }\n\n  return newImage;\n}\n\nfunction rotateBilinear(\n  thisImage,\n  newImage,\n  incrementX,\n  incrementY,\n  x0,\n  y0,\n  cos,\n  sin,\n) {\n  let stride = thisImage.width * thisImage.channels;\n\n  for (let j = 0; j < newImage.height; j++) {\n    for (let i = 0; i < newImage.width; i++) {\n      let x = (i - x0) * cos - (j - y0) * sin + x0 + incrementX;\n      let y = (j - y0) * cos + (i - x0) * sin + y0 + incrementY;\n      let x1 = x | 0;\n      let y1 = y | 0;\n      let xDiff = x - x1;\n      let yDiff = y - y1;\n\n      for (let c = 0; c < thisImage.channels; c++) {\n        if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n          if (thisImage.alpha === 1 && c === thisImage.channels - 1) {\n            newImage.setValueXY(i, j, c, 0);\n          } else {\n            newImage.setValueXY(i, j, c, thisImage.maxValue);\n          }\n        } else {\n          let index = (y1 * thisImage.width + x1) * thisImage.channels + c;\n          let A = thisImage.data[index];\n          let B = thisImage.data[index + thisImage.channels];\n          let C = thisImage.data[index + stride];\n          let D = thisImage.data[index + stride + thisImage.channels];\n          let result =\n            (A +\n              xDiff * (B - A) +\n              yDiff * (C - A) +\n              xDiff * yDiff * (A - B - C + D)) |\n            0;\n          newImage.setValueXY(i, j, c, result);\n        }\n      }\n    }\n  }\n\n  return newImage;\n}\n\nfunction rotateBinaryBilinear(\n  thisImage,\n  newImage,\n  incrementX,\n  incrementY,\n  x0,\n  y0,\n  cos,\n  sin,\n) {\n  let stride = thisImage.width;\n\n  for (let j = 0; j < newImage.height; j++) {\n    for (let i = 0; i < newImage.width; i++) {\n      let x = (i - x0) * cos - (j - y0) * sin + x0 + incrementX;\n      let y = (j - y0) * cos + (i - x0) * sin + y0 + incrementY;\n      let x1 = x | 0;\n      let y1 = y | 0;\n      let xDiff = x - x1;\n      let yDiff = y - y1;\n\n      if (x < 0 || x >= thisImage.width || y < 0 || y >= thisImage.height) {\n        newImage.setBitXY(i, j);\n      } else {\n        let index = y1 * thisImage.width + x1;\n        let A = thisImage.getBit(index);\n        let B = thisImage.getBit(index + 1);\n        let C = thisImage.getBit(index + stride);\n        let D = thisImage.getBit(index + 1 + stride);\n        let result =\n          A |\n          (xDiff & (B - A)) |\n          (yDiff & (C - A)) |\n          (xDiff & yDiff & (A - B - C + D));\n        if (result > 0) newImage.setBitXY(i, j);\n      }\n    }\n  }\n\n  return newImage;\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,UAAU;AAC5B,SAASC,mBAAmB,EAAEC,kBAAkB,QAAQ,oBAAoB;AAE5E,eAAe,SAASC,UAAUA,CAACC,OAAO,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACxD,MAAM;IACJC,aAAa,GAAGL,mBAAmB,CAACM,eAAe;IACnDC,KAAK,GAAG,IAAI,CAACA,KAAK;IAClBC,MAAM,GAAG,IAAI,CAACA;EAChB,CAAC,GAAGJ,OAAO;EAEX,IAAI,OAAOD,OAAO,KAAK,QAAQ,EAAE;IAC/B,MAAM,IAAIM,SAAS,CAAC,0BAA0B,CAAC;EACjD;EAEA,MAAMC,kBAAkB,GAAG,CAAC,CAAC,EAAET,kBAAkB,EAAEI,aAAa,CAAC;EACjE,MAAMM,OAAO,GAAIR,OAAO,GAAGS,IAAI,CAACC,EAAE,GAAI,GAAG;EACzC,MAAMC,QAAQ,GAAGF,IAAI,CAACG,KAAK,CACzBH,IAAI,CAACI,GAAG,CAACT,KAAK,GAAGK,IAAI,CAACK,GAAG,CAACN,OAAO,CAAC,CAAC,GAAGC,IAAI,CAACI,GAAG,CAACR,MAAM,GAAGI,IAAI,CAACM,GAAG,CAACP,OAAO,CAAC,CAC3E,CAAC;EACD,MAAMQ,SAAS,GAAGP,IAAI,CAACG,KAAK,CAC1BH,IAAI,CAACI,GAAG,CAACR,MAAM,GAAGI,IAAI,CAACK,GAAG,CAACN,OAAO,CAAC,CAAC,GAAGC,IAAI,CAACI,GAAG,CAACT,KAAK,GAAGK,IAAI,CAACM,GAAG,CAACP,OAAO,CAAC,CAC3E,CAAC;EAED,MAAMM,GAAG,GAAGL,IAAI,CAACK,GAAG,CAAC,CAACN,OAAO,CAAC;EAC9B,MAAMO,GAAG,GAAGN,IAAI,CAACM,GAAG,CAAC,CAACP,OAAO,CAAC;EAC9B,IAAIS,EAAE,GAAGN,QAAQ,GAAG,CAAC;EACrB,IAAIO,EAAE,GAAGF,SAAS,GAAG,CAAC;EAEtB,IAAIL,QAAQ,GAAG,CAAC,KAAK,CAAC,EAAE;IACtBM,EAAE,GAAGA,EAAE,GAAG,GAAG;IAEb,IAAID,SAAS,GAAG,CAAC,KAAK,CAAC,EAAE;MACvBE,EAAE,GAAGA,EAAE,GAAG,GAAG;IACf,CAAC,MAAM;MACLA,EAAE,GAAGT,IAAI,CAACG,KAAK,CAACM,EAAE,CAAC;IACrB;EACF,CAAC,MAAM;IACLD,EAAE,GAAGR,IAAI,CAACG,KAAK,CAACK,EAAE,CAAC;IAEnB,IAAID,SAAS,GAAG,CAAC,KAAK,CAAC,EAAE;MACvBE,EAAE,GAAGA,EAAE,GAAG,GAAG;IACf,CAAC,MAAM;MACLA,EAAE,GAAGT,IAAI,CAACG,KAAK,CAACM,EAAE,CAAC;IACrB;EACF;EAEA,MAAMC,UAAU,GAAGV,IAAI,CAACG,KAAK,CAACR,KAAK,GAAG,CAAC,GAAGa,EAAE,CAAC;EAC7C,MAAMG,UAAU,GAAGX,IAAI,CAACG,KAAK,CAACP,MAAM,GAAG,CAAC,GAAGa,EAAE,CAAC;EAE9C,IAAI,IAAI,CAACG,QAAQ,KAAK,CAAC,EAAE;IACvB,MAAMC,QAAQ,GAAG,IAAI1B,KAAK,CAACe,QAAQ,EAAEK,SAAS,EAAE;MAC9CO,IAAI,EAAE,QAAQ;MACdC,MAAM,EAAE;IACV,CAAC,CAAC;IAEF,QAAQjB,kBAAkB;MACxB,KAAKV,mBAAmB,CAACM,eAAe;QACtC,OAAOsB,2BAA2B,CAChC,IAAI,EACJH,QAAQ,EACRH,UAAU,EACVC,UAAU,EACVH,EAAE,EACFC,EAAE,EACFJ,GAAG,EACHC,GACF,CAAC;MAEH,KAAKlB,mBAAmB,CAAC6B,QAAQ;QAC/B,OAAOC,oBAAoB,CACzB,IAAI,EACJL,QAAQ,EACRH,UAAU,EACVC,UAAU,EACVH,EAAE,EACFC,EAAE,EACFJ,GAAG,EACHC,GACF,CAAC;MAEH;QACE,MAAM,IAAIa,KAAK,CACb,qCAAqCrB,kBAAkB,EACzD,CAAC;IACL;EACF,CAAC,MAAM;IACL,MAAMe,QAAQ,GAAG1B,KAAK,CAACiC,UAAU,CAAC,IAAI,EAAE;MACtCzB,KAAK,EAAEO,QAAQ;MACfN,MAAM,EAAEW;IACV,CAAC,CAAC;IAEF,QAAQT,kBAAkB;MACxB,KAAKV,mBAAmB,CAACM,eAAe;QACtC,OAAO2B,qBAAqB,CAC1B,IAAI,EACJR,QAAQ,EACRH,UAAU,EACVC,UAAU,EACVH,EAAE,EACFC,EAAE,EACFJ,GAAG,EACHC,GACF,CAAC;MAEH,KAAKlB,mBAAmB,CAAC6B,QAAQ;QAC/B,OAAOK,cAAc,CACnB,IAAI,EACJT,QAAQ,EACRH,UAAU,EACVC,UAAU,EACVH,EAAE,EACFC,EAAE,EACFJ,GAAG,EACHC,GACF,CAAC;MAEH;QACE,MAAM,IAAIa,KAAK,CACb,qCAAqCrB,kBAAkB,EACzD,CAAC;IACL;EACF;AACF;AAEA,SAASuB,qBAAqBA,CAC5BE,SAAS,EACTV,QAAQ,EACRH,UAAU,EACVC,UAAU,EACVH,EAAE,EACFC,EAAE,EACFJ,GAAG,EACHC,GAAG,EACH;EACA,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,QAAQ,CAAClB,KAAK,EAAE6B,CAAC,IAAI,CAAC,EAAE;IAC1C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,QAAQ,CAACjB,MAAM,EAAE6B,CAAC,IAAI,CAAC,EAAE;MAC3C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAACI,QAAQ,EAAED,CAAC,EAAE,EAAE;QAC3C,IAAIE,CAAC,GAAG5B,IAAI,CAAC6B,KAAK,CAAC,CAACL,CAAC,GAAGhB,EAAE,IAAIH,GAAG,GAAG,CAACoB,CAAC,GAAGhB,EAAE,IAAIH,GAAG,GAAGE,EAAE,CAAC,GAAGE,UAAU;QACrE,IAAIoB,CAAC,GAAG9B,IAAI,CAAC6B,KAAK,CAAC,CAACJ,CAAC,GAAGhB,EAAE,IAAIJ,GAAG,GAAG,CAACmB,CAAC,GAAGhB,EAAE,IAAIF,GAAG,GAAGG,EAAE,CAAC,GAAGE,UAAU;QAErE,IAAIiB,CAAC,GAAG,CAAC,IAAIA,CAAC,IAAIL,SAAS,CAAC5B,KAAK,IAAImC,CAAC,GAAG,CAAC,IAAIA,CAAC,IAAIP,SAAS,CAAC3B,MAAM,EAAE;UACnE,IAAI2B,SAAS,CAACQ,KAAK,KAAK,CAAC,IAAIL,CAAC,KAAKH,SAAS,CAACI,QAAQ,GAAG,CAAC,EAAE;YACzDd,QAAQ,CAACmB,UAAU,CAACR,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE,CAAC,CAAC;UACjC,CAAC,MAAM;YACLb,QAAQ,CAACmB,UAAU,CAACR,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEH,SAAS,CAACU,QAAQ,CAAC;UAClD;QACF,CAAC,MAAM;UACLpB,QAAQ,CAACmB,UAAU,CAACR,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEH,SAAS,CAACW,UAAU,CAACN,CAAC,EAAEE,CAAC,EAAEJ,CAAC,CAAC,CAAC;QAC7D;MACF;IACF;EACF;EAEA,OAAOb,QAAQ;AACjB;AAEA,SAASG,2BAA2BA,CAClCO,SAAS,EACTV,QAAQ,EACRH,UAAU,EACVC,UAAU,EACVH,EAAE,EACFC,EAAE,EACFJ,GAAG,EACHC,GAAG,EACH;EACA,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,QAAQ,CAAClB,KAAK,EAAE6B,CAAC,IAAI,CAAC,EAAE;IAC1C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,QAAQ,CAACjB,MAAM,EAAE6B,CAAC,IAAI,CAAC,EAAE;MAC3C,IAAIG,CAAC,GAAG5B,IAAI,CAAC6B,KAAK,CAAC,CAACL,CAAC,GAAGhB,EAAE,IAAIH,GAAG,GAAG,CAACoB,CAAC,GAAGhB,EAAE,IAAIH,GAAG,GAAGE,EAAE,CAAC,GAAGE,UAAU;MACrE,IAAIoB,CAAC,GAAG9B,IAAI,CAAC6B,KAAK,CAAC,CAACJ,CAAC,GAAGhB,EAAE,IAAIJ,GAAG,GAAG,CAACmB,CAAC,GAAGhB,EAAE,IAAIF,GAAG,GAAGG,EAAE,CAAC,GAAGE,UAAU;MAErE,IACEiB,CAAC,GAAG,CAAC,IACLA,CAAC,IAAIL,SAAS,CAAC5B,KAAK,IACpBmC,CAAC,GAAG,CAAC,IACLA,CAAC,IAAIP,SAAS,CAAC3B,MAAM,IACrB2B,SAAS,CAACY,QAAQ,CAACP,CAAC,EAAEE,CAAC,CAAC,EACxB;QACAjB,QAAQ,CAACuB,QAAQ,CAACZ,CAAC,EAAEC,CAAC,CAAC;MACzB;IACF;EACF;EAEA,OAAOZ,QAAQ;AACjB;AAEA,SAASS,cAAcA,CACrBC,SAAS,EACTV,QAAQ,EACRH,UAAU,EACVC,UAAU,EACVH,EAAE,EACFC,EAAE,EACFJ,GAAG,EACHC,GAAG,EACH;EACA,IAAI+B,MAAM,GAAGd,SAAS,CAAC5B,KAAK,GAAG4B,SAAS,CAACI,QAAQ;EAEjD,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,QAAQ,CAACjB,MAAM,EAAE6B,CAAC,EAAE,EAAE;IACxC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,QAAQ,CAAClB,KAAK,EAAE6B,CAAC,EAAE,EAAE;MACvC,IAAII,CAAC,GAAG,CAACJ,CAAC,GAAGhB,EAAE,IAAIH,GAAG,GAAG,CAACoB,CAAC,GAAGhB,EAAE,IAAIH,GAAG,GAAGE,EAAE,GAAGE,UAAU;MACzD,IAAIoB,CAAC,GAAG,CAACL,CAAC,GAAGhB,EAAE,IAAIJ,GAAG,GAAG,CAACmB,CAAC,GAAGhB,EAAE,IAAIF,GAAG,GAAGG,EAAE,GAAGE,UAAU;MACzD,IAAI2B,EAAE,GAAGV,CAAC,GAAG,CAAC;MACd,IAAIW,EAAE,GAAGT,CAAC,GAAG,CAAC;MACd,IAAIU,KAAK,GAAGZ,CAAC,GAAGU,EAAE;MAClB,IAAIG,KAAK,GAAGX,CAAC,GAAGS,EAAE;MAElB,KAAK,IAAIb,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,SAAS,CAACI,QAAQ,EAAED,CAAC,EAAE,EAAE;QAC3C,IAAIE,CAAC,GAAG,CAAC,IAAIA,CAAC,IAAIL,SAAS,CAAC5B,KAAK,IAAImC,CAAC,GAAG,CAAC,IAAIA,CAAC,IAAIP,SAAS,CAAC3B,MAAM,EAAE;UACnE,IAAI2B,SAAS,CAACQ,KAAK,KAAK,CAAC,IAAIL,CAAC,KAAKH,SAAS,CAACI,QAAQ,GAAG,CAAC,EAAE;YACzDd,QAAQ,CAACmB,UAAU,CAACR,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE,CAAC,CAAC;UACjC,CAAC,MAAM;YACLb,QAAQ,CAACmB,UAAU,CAACR,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEH,SAAS,CAACU,QAAQ,CAAC;UAClD;QACF,CAAC,MAAM;UACL,IAAIS,KAAK,GAAG,CAACH,EAAE,GAAGhB,SAAS,CAAC5B,KAAK,GAAG2C,EAAE,IAAIf,SAAS,CAACI,QAAQ,GAAGD,CAAC;UAChE,IAAIiB,CAAC,GAAGpB,SAAS,CAACqB,IAAI,CAACF,KAAK,CAAC;UAC7B,IAAIG,CAAC,GAAGtB,SAAS,CAACqB,IAAI,CAACF,KAAK,GAAGnB,SAAS,CAACI,QAAQ,CAAC;UAClD,IAAImB,CAAC,GAAGvB,SAAS,CAACqB,IAAI,CAACF,KAAK,GAAGL,MAAM,CAAC;UACtC,IAAIU,CAAC,GAAGxB,SAAS,CAACqB,IAAI,CAACF,KAAK,GAAGL,MAAM,GAAGd,SAAS,CAACI,QAAQ,CAAC;UAC3D,IAAIqB,MAAM,GACPL,CAAC,GACAH,KAAK,IAAIK,CAAC,GAAGF,CAAC,CAAC,GACfF,KAAK,IAAIK,CAAC,GAAGH,CAAC,CAAC,GACfH,KAAK,GAAGC,KAAK,IAAIE,CAAC,GAAGE,CAAC,GAAGC,CAAC,GAAGC,CAAC,CAAC,GACjC,CAAC;UACHlC,QAAQ,CAACmB,UAAU,CAACR,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEsB,MAAM,CAAC;QACtC;MACF;IACF;EACF;EAEA,OAAOnC,QAAQ;AACjB;AAEA,SAASK,oBAAoBA,CAC3BK,SAAS,EACTV,QAAQ,EACRH,UAAU,EACVC,UAAU,EACVH,EAAE,EACFC,EAAE,EACFJ,GAAG,EACHC,GAAG,EACH;EACA,IAAI+B,MAAM,GAAGd,SAAS,CAAC5B,KAAK;EAE5B,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,QAAQ,CAACjB,MAAM,EAAE6B,CAAC,EAAE,EAAE;IACxC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,QAAQ,CAAClB,KAAK,EAAE6B,CAAC,EAAE,EAAE;MACvC,IAAII,CAAC,GAAG,CAACJ,CAAC,GAAGhB,EAAE,IAAIH,GAAG,GAAG,CAACoB,CAAC,GAAGhB,EAAE,IAAIH,GAAG,GAAGE,EAAE,GAAGE,UAAU;MACzD,IAAIoB,CAAC,GAAG,CAACL,CAAC,GAAGhB,EAAE,IAAIJ,GAAG,GAAG,CAACmB,CAAC,GAAGhB,EAAE,IAAIF,GAAG,GAAGG,EAAE,GAAGE,UAAU;MACzD,IAAI2B,EAAE,GAAGV,CAAC,GAAG,CAAC;MACd,IAAIW,EAAE,GAAGT,CAAC,GAAG,CAAC;MACd,IAAIU,KAAK,GAAGZ,CAAC,GAAGU,EAAE;MAClB,IAAIG,KAAK,GAAGX,CAAC,GAAGS,EAAE;MAElB,IAAIX,CAAC,GAAG,CAAC,IAAIA,CAAC,IAAIL,SAAS,CAAC5B,KAAK,IAAImC,CAAC,GAAG,CAAC,IAAIA,CAAC,IAAIP,SAAS,CAAC3B,MAAM,EAAE;QACnEiB,QAAQ,CAACuB,QAAQ,CAACZ,CAAC,EAAEC,CAAC,CAAC;MACzB,CAAC,MAAM;QACL,IAAIiB,KAAK,GAAGH,EAAE,GAAGhB,SAAS,CAAC5B,KAAK,GAAG2C,EAAE;QACrC,IAAIK,CAAC,GAAGpB,SAAS,CAAC0B,MAAM,CAACP,KAAK,CAAC;QAC/B,IAAIG,CAAC,GAAGtB,SAAS,CAAC0B,MAAM,CAACP,KAAK,GAAG,CAAC,CAAC;QACnC,IAAII,CAAC,GAAGvB,SAAS,CAAC0B,MAAM,CAACP,KAAK,GAAGL,MAAM,CAAC;QACxC,IAAIU,CAAC,GAAGxB,SAAS,CAAC0B,MAAM,CAACP,KAAK,GAAG,CAAC,GAAGL,MAAM,CAAC;QAC5C,IAAIW,MAAM,GACRL,CAAC,GACAH,KAAK,GAAIK,CAAC,GAAGF,CAAG,GAChBF,KAAK,GAAIK,CAAC,GAAGH,CAAG,GAChBH,KAAK,GAAGC,KAAK,GAAIE,CAAC,GAAGE,CAAC,GAAGC,CAAC,GAAGC,CAAG;QACnC,IAAIC,MAAM,GAAG,CAAC,EAAEnC,QAAQ,CAACuB,QAAQ,CAACZ,CAAC,EAAEC,CAAC,CAAC;MACzC;IACF;EACF;EAEA,OAAOZ,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}