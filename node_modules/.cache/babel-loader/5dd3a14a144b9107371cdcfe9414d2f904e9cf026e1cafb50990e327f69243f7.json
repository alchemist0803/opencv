{"ast":null,"code":"import Image from '../image/Image';\nimport { BINARY } from '../image/core/kindNames';\nimport zerosMatrix from './zerosMatrix';\nconst cross = [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]];\nconst smallCross = [[0, 1, 0], [1, 1, 1], [0, 1, 0]];\n\n/**\n * Class representing a shape\n * @class Shape\n * @param {object} [options]\n * @param {string} [options.kind='cross'] - Predefined matrix shape, 'cross' or 'smallCross'\n * @param {string} [options.shape] - Value may be 'square', 'rectangle', 'circle', 'ellipse' or 'triangle'\n *                                  The size of the shape will be determined by the size, width and height.\n *                                  A Shape is by default filled.\n * @param {number} [options.size]\n * @param {number} [options.width=options.size] - width of the shape. Must be odd.\n * @param {number} [options.height=options.size] - width of the shape. Must be odd.\n * @param {boolean} [options.filled=true] - If false only the border ot the shape is taken into account.\n */\nexport default class Shape {\n  constructor(options = {}) {\n    let {\n      kind = 'cross',\n      shape,\n      size,\n      width,\n      height,\n      filled = true\n    } = options;\n    if (size) {\n      width = size;\n      height = size;\n    }\n    if (shape) {\n      switch (shape.toLowerCase()) {\n        case 'square':\n        case 'rectangle':\n          this.matrix = rectangle(width, height, {\n            filled\n          });\n          break;\n        case 'circle':\n        case 'ellipse':\n          this.matrix = ellipse(width, height, {\n            filled\n          });\n          break;\n        case 'triangle':\n          this.matrix = triangle(width, height, {\n            filled\n          });\n          break;\n        default:\n          throw new Error(`Shape: unexpected shape: ${shape}`);\n      }\n    } else if (kind) {\n      switch (kind.toLowerCase()) {\n        case 'cross':\n          this.matrix = cross;\n          break;\n        case 'smallcross':\n          this.matrix = smallCross;\n          break;\n        default:\n          throw new Error(`Shape: unexpected kind: ${kind}`);\n      }\n    } else {\n      throw new Error('Shape: expected a kind or a shape option');\n    }\n    this.height = this.matrix.length;\n    this.width = this.matrix[0].length;\n    this.halfHeight = this.height / 2 >> 0;\n    this.halfWidth = this.width / 2 >> 0;\n  }\n\n  /**\n   * Returns an array of [x,y] points\n   * @return {Array<Array<number>>} - Array of [x,y] points\n   */\n  getPoints() {\n    let matrix = this.matrix;\n    let points = [];\n    for (let y = 0; y < matrix.length; y++) {\n      for (let x = 0; x < matrix[0].length; x++) {\n        if (matrix[y][x]) {\n          points.push([x - this.halfWidth, y - this.halfHeight]);\n        }\n      }\n    }\n    return points;\n  }\n\n  /**\n   * Returns a Mask (1 bit Image) corresponding to this shape.\n   * @return {Image}\n   */\n  getMask() {\n    let img = new Image(this.width, this.height, {\n      kind: BINARY\n    });\n    for (let y = 0; y < this.matrix.length; y++) {\n      for (let x = 0; x < this.matrix[0].length; x++) {\n        if (this.matrix[y][x]) {\n          img.setBitXY(x, y);\n        }\n      }\n    }\n    return img;\n  }\n}\nfunction rectangle(width, height, options) {\n  const matrix = zerosMatrix(height, width);\n  if (options.filled) {\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        matrix[y][x] = 1;\n      }\n    }\n  } else {\n    for (let y of [0, height - 1]) {\n      for (let x = 0; x < width; x++) {\n        matrix[y][x] = 1;\n      }\n    }\n    for (let y = 0; y < height; y++) {\n      for (let x of [0, width - 1]) {\n        matrix[y][x] = 1;\n      }\n    }\n  }\n  return matrix;\n}\nfunction ellipse(width, height, options) {\n  const matrix = zerosMatrix(height, width, options);\n  let yEven = 1 - height % 2;\n  let xEven = 1 - width % 2;\n  let a = Math.floor((width - 1) / 2); // horizontal ellipse axe\n  let b = Math.floor((height - 1) / 2); // vertical ellipse axe\n  let a2 = a * a;\n  let b2 = b * b;\n  if (options.filled) {\n    for (let y = 0; y <= b; y++) {\n      let shift = Math.floor(Math.sqrt(a2 - a2 * y * y / b2));\n      for (let x = a - shift; x <= a; x++) {\n        matrix[b - y][x] = 1;\n        matrix[b + y + yEven][x] = 1;\n        matrix[b - y][width - x - 1] = 1;\n        matrix[b + y + yEven][width - x - 1] = 1;\n      }\n    }\n  } else {\n    for (let y = 0; y <= b; y++) {\n      let shift = Math.floor(Math.sqrt(a2 - a2 * y * y / b2));\n      let x = a - shift;\n      matrix[b - y][x] = 1;\n      matrix[b + y + yEven][x] = 1;\n      matrix[b - y][width - x - 1] = 1;\n      matrix[b + y + yEven][width - x - 1] = 1;\n    }\n    for (let x = 0; x <= a; x++) {\n      let shift = Math.floor(Math.sqrt(b2 - b2 * x * x / a2));\n      let y = b - shift;\n      matrix[y][a - x] = 1;\n      matrix[y][a + x + xEven] = 1;\n      matrix[height - y - 1][a - x] = 1;\n      matrix[height - y - 1][a + x + xEven] = 1;\n    }\n  }\n  return matrix;\n}\nfunction triangle(width, height, options) {\n  if (!options.filled) {\n    throw new Error('Non filled triangle is not implemented');\n  }\n  const matrix = zerosMatrix(height, width, options);\n  for (let y = 0; y < height; y++) {\n    let shift = Math.floor((1 - y / height) * width / 2);\n    for (let x = shift; x < width - shift; x++) {\n      matrix[y][x] = 1;\n    }\n  }\n  return matrix;\n}","map":{"version":3,"names":["Image","BINARY","zerosMatrix","cross","smallCross","Shape","constructor","options","kind","shape","size","width","height","filled","toLowerCase","matrix","rectangle","ellipse","triangle","Error","length","halfHeight","halfWidth","getPoints","points","y","x","push","getMask","img","setBitXY","yEven","xEven","a","Math","floor","b","a2","b2","shift","sqrt"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/util/Shape.js"],"sourcesContent":["import Image from '../image/Image';\nimport { BINARY } from '../image/core/kindNames';\n\nimport zerosMatrix from './zerosMatrix';\n\nconst cross = [\n  [0, 0, 1, 0, 0],\n  [0, 0, 1, 0, 0],\n  [1, 1, 1, 1, 1],\n  [0, 0, 1, 0, 0],\n  [0, 0, 1, 0, 0],\n];\n\nconst smallCross = [\n  [0, 1, 0],\n  [1, 1, 1],\n  [0, 1, 0],\n];\n\n/**\n * Class representing a shape\n * @class Shape\n * @param {object} [options]\n * @param {string} [options.kind='cross'] - Predefined matrix shape, 'cross' or 'smallCross'\n * @param {string} [options.shape] - Value may be 'square', 'rectangle', 'circle', 'ellipse' or 'triangle'\n *                                  The size of the shape will be determined by the size, width and height.\n *                                  A Shape is by default filled.\n * @param {number} [options.size]\n * @param {number} [options.width=options.size] - width of the shape. Must be odd.\n * @param {number} [options.height=options.size] - width of the shape. Must be odd.\n * @param {boolean} [options.filled=true] - If false only the border ot the shape is taken into account.\n */\nexport default class Shape {\n  constructor(options = {}) {\n    let { kind = 'cross', shape, size, width, height, filled = true } = options;\n    if (size) {\n      width = size;\n      height = size;\n    }\n\n    if (shape) {\n      switch (shape.toLowerCase()) {\n        case 'square':\n        case 'rectangle':\n          this.matrix = rectangle(width, height, { filled });\n          break;\n        case 'circle':\n        case 'ellipse':\n          this.matrix = ellipse(width, height, { filled });\n          break;\n        case 'triangle':\n          this.matrix = triangle(width, height, { filled });\n          break;\n        default:\n          throw new Error(`Shape: unexpected shape: ${shape}`);\n      }\n    } else if (kind) {\n      switch (kind.toLowerCase()) {\n        case 'cross':\n          this.matrix = cross;\n          break;\n        case 'smallcross':\n          this.matrix = smallCross;\n          break;\n        default:\n          throw new Error(`Shape: unexpected kind: ${kind}`);\n      }\n    } else {\n      throw new Error('Shape: expected a kind or a shape option');\n    }\n    this.height = this.matrix.length;\n    this.width = this.matrix[0].length;\n    this.halfHeight = (this.height / 2) >> 0;\n    this.halfWidth = (this.width / 2) >> 0;\n  }\n\n  /**\n   * Returns an array of [x,y] points\n   * @return {Array<Array<number>>} - Array of [x,y] points\n   */\n  getPoints() {\n    let matrix = this.matrix;\n    let points = [];\n    for (let y = 0; y < matrix.length; y++) {\n      for (let x = 0; x < matrix[0].length; x++) {\n        if (matrix[y][x]) {\n          points.push([x - this.halfWidth, y - this.halfHeight]);\n        }\n      }\n    }\n    return points;\n  }\n\n  /**\n   * Returns a Mask (1 bit Image) corresponding to this shape.\n   * @return {Image}\n   */\n  getMask() {\n    let img = new Image(this.width, this.height, {\n      kind: BINARY,\n    });\n    for (let y = 0; y < this.matrix.length; y++) {\n      for (let x = 0; x < this.matrix[0].length; x++) {\n        if (this.matrix[y][x]) {\n          img.setBitXY(x, y);\n        }\n      }\n    }\n    return img;\n  }\n}\n\nfunction rectangle(width, height, options) {\n  const matrix = zerosMatrix(height, width);\n  if (options.filled) {\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        matrix[y][x] = 1;\n      }\n    }\n  } else {\n    for (let y of [0, height - 1]) {\n      for (let x = 0; x < width; x++) {\n        matrix[y][x] = 1;\n      }\n    }\n    for (let y = 0; y < height; y++) {\n      for (let x of [0, width - 1]) {\n        matrix[y][x] = 1;\n      }\n    }\n  }\n\n  return matrix;\n}\n\nfunction ellipse(width, height, options) {\n  const matrix = zerosMatrix(height, width, options);\n  let yEven = 1 - (height % 2);\n  let xEven = 1 - (width % 2);\n  let a = Math.floor((width - 1) / 2); // horizontal ellipse axe\n  let b = Math.floor((height - 1) / 2); // vertical ellipse axe\n  let a2 = a * a;\n  let b2 = b * b;\n  if (options.filled) {\n    for (let y = 0; y <= b; y++) {\n      let shift = Math.floor(Math.sqrt(a2 - (a2 * y * y) / b2));\n      for (let x = a - shift; x <= a; x++) {\n        matrix[b - y][x] = 1;\n        matrix[b + y + yEven][x] = 1;\n        matrix[b - y][width - x - 1] = 1;\n        matrix[b + y + yEven][width - x - 1] = 1;\n      }\n    }\n  } else {\n    for (let y = 0; y <= b; y++) {\n      let shift = Math.floor(Math.sqrt(a2 - (a2 * y * y) / b2));\n      let x = a - shift;\n      matrix[b - y][x] = 1;\n      matrix[b + y + yEven][x] = 1;\n      matrix[b - y][width - x - 1] = 1;\n      matrix[b + y + yEven][width - x - 1] = 1;\n    }\n\n    for (let x = 0; x <= a; x++) {\n      let shift = Math.floor(Math.sqrt(b2 - (b2 * x * x) / a2));\n      let y = b - shift;\n      matrix[y][a - x] = 1;\n      matrix[y][a + x + xEven] = 1;\n      matrix[height - y - 1][a - x] = 1;\n      matrix[height - y - 1][a + x + xEven] = 1;\n    }\n  }\n  return matrix;\n}\n\nfunction triangle(width, height, options) {\n  if (!options.filled) {\n    throw new Error('Non filled triangle is not implemented');\n  }\n  const matrix = zerosMatrix(height, width, options);\n  for (let y = 0; y < height; y++) {\n    let shift = Math.floor(((1 - y / height) * width) / 2);\n    for (let x = shift; x < width - shift; x++) {\n      matrix[y][x] = 1;\n    }\n  }\n  return matrix;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}