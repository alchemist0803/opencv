{"ast":null,"code":"/**\n * Rounds all the x and y values of an array of points\n * @param {Array<Array<number>>} points\n * @return {Array<Array<number>>} modified input value\n * @private\n */\nexport function round(points) {\n  for (let i = 0; i < points.length; i++) {\n    points[i][0] = Math.round(points[i][0]);\n    points[i][1] = Math.round(points[i][1]);\n  }\n  return points;\n}\n\n/**\n * Calculates a new point that is the difference p1 - p2\n * @param {Array<number>} p1\n * @param {Array<number>} p2\n * @return {Array<number>}\n * @private\n */\nexport function difference(p1, p2) {\n  return [p1[0] - p2[0], p1[1] - p2[1]];\n}\n\n/**\n * Normalize a point\n * @param {Array<number>} p\n * @return {Array<number>}\n * @private\n */\nexport function normalize(p) {\n  let length = Math.sqrt(p[0] ** 2 + p[1] ** 2);\n  return [p[0] / length, p[1] / length];\n}\n\n/**\n * We rotate an array of points\n * @param {number} radians\n * @param {Array<Array<number>>} srcPoints\n * @param {Array<Array<number>>} destPoints\n * @return {Array<Array<number>>}\n * @private\n */\nexport function rotate(radians, srcPoints, destPoints) {\n  if (destPoints === undefined) destPoints = new Array(srcPoints.length);\n  let cos = Math.cos(radians);\n  let sin = Math.sin(radians);\n  for (let i = 0; i < destPoints.length; ++i) {\n    destPoints[i] = [cos * srcPoints[i][0] - sin * srcPoints[i][1], sin * srcPoints[i][0] + cos * srcPoints[i][1]];\n  }\n  return destPoints;\n}\n\n/**\n * Dot products of 2 points assuming vectors starting from (0,0)\n * @param {Array<number>} p1\n * @param {Array<number>} p2\n * @return {number}\n * @private\n */\nexport function dot(p1, p2) {\n  return p1[0] * p2[0] + p1[1] * p2[1];\n}\n\n/**\n * Returns the angle between 3 points. The first one is a common point\n * @param {Array<number>} origin\n * @param {Array<number>} p1\n * @param {Array<number>} p2\n * @return {number}\n * @private\n */\nexport function angle(origin, p1, p2) {\n  let v1 = normalize(difference(p1, origin));\n  let v2 = normalize(difference(p2, origin));\n  let dotProduct = dot(v1, v2);\n  // TODO this code is not correct because it may yield the opposite angle\n  return Math.acos(dotProduct);\n}\n\n/**\n * Returns the 4 points of an horizontal rectangle that includes all the points\n * @param {Array<Array<number>>} points\n * @return {Array<Array<number>>}\n * @private\n */\nexport function boundary(points) {\n  let minMaxValues = minMax(points);\n  let xMin = minMaxValues[0][0];\n  let yMin = minMaxValues[0][1];\n  let xMax = minMaxValues[1][0];\n  let yMax = minMaxValues[1][1];\n  return [[xMin, yMin], [xMax, yMin], [xMax, yMax], [xMin, yMax]];\n}\n\n/**\n * Returns the perimeter represented by the points (a polygon)\n * @param {Array<Array<number>>} points\n */\nexport function perimeter(vertices) {\n  let total = 0;\n  for (let i = 0; i < vertices.length; i++) {\n    let fromX = vertices[i][0];\n    let fromY = vertices[i][1];\n    let toX = vertices[i === vertices.length - 1 ? 0 : i + 1][0];\n    let toY = vertices[i === vertices.length - 1 ? 0 : i + 1][1];\n    total += Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);\n  }\n  return total;\n}\n\n/**\n * Returns the surface represented by the points (a polygon)\n * @param {Array<Array<number>>} points\n */\nexport function surface(vertices) {\n  let total = 0;\n  for (let i = 0; i < vertices.length; i++) {\n    let addX = vertices[i][0];\n    let addY = vertices[i === vertices.length - 1 ? 0 : i + 1][1];\n    let subX = vertices[i === vertices.length - 1 ? 0 : i + 1][0];\n    let subY = vertices[i][1];\n    total += addX * addY * 0.5;\n    total -= subX * subY * 0.5;\n  }\n  return Math.abs(total);\n}\n\n/**\n * Returns 2 points with minimal and maximal XY\n * @param {Array<Array<number>>} points\n * @return {Array<Array<number>>}\n * @private\n */\nexport function minMax(points) {\n  let xMin = +Infinity;\n  let yMin = +Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n  for (let i = 0; i < points.length; i++) {\n    if (points[i][0] < xMin) xMin = points[i][0];\n    if (points[i][0] > xMax) xMax = points[i][0];\n    if (points[i][1] < yMin) yMin = points[i][1];\n    if (points[i][1] > yMax) yMax = points[i][1];\n  }\n  return [[xMin, yMin], [xMax, yMax]];\n}\n\n/**\n * Moves the minX, minY to 0,0\n * All the points will be positive after this move\n * @param {Array<Array<number>>} srcPoints\n * @param {Array<Array<number>>} destPoints\n * @return {Array<Array<number>>}\n * @private\n */\nexport function moveToZeroZero(srcPoints, destPoints) {\n  if (destPoints === undefined) {\n    destPoints = new Array(srcPoints.length).fill(0).map(() => []);\n  }\n  let minMaxValues = minMax(srcPoints);\n  let xMin = minMaxValues[0][0];\n  let yMin = minMaxValues[0][1];\n  for (let i = 0; i < srcPoints.length; i++) {\n    destPoints[i][0] = srcPoints[i][0] - xMin;\n    destPoints[i][1] = srcPoints[i][1] - yMin;\n  }\n  return destPoints;\n}","map":{"version":3,"names":["round","points","i","length","Math","difference","p1","p2","normalize","p","sqrt","rotate","radians","srcPoints","destPoints","undefined","Array","cos","sin","dot","angle","origin","v1","v2","dotProduct","acos","boundary","minMaxValues","minMax","xMin","yMin","xMax","yMax","perimeter","vertices","total","fromX","fromY","toX","toY","surface","addX","addY","subX","subY","abs","Infinity","moveToZeroZero","fill","map"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/util/points.js"],"sourcesContent":["/**\n * Rounds all the x and y values of an array of points\n * @param {Array<Array<number>>} points\n * @return {Array<Array<number>>} modified input value\n * @private\n */\nexport function round(points) {\n  for (let i = 0; i < points.length; i++) {\n    points[i][0] = Math.round(points[i][0]);\n    points[i][1] = Math.round(points[i][1]);\n  }\n  return points;\n}\n\n/**\n * Calculates a new point that is the difference p1 - p2\n * @param {Array<number>} p1\n * @param {Array<number>} p2\n * @return {Array<number>}\n * @private\n */\nexport function difference(p1, p2) {\n  return [p1[0] - p2[0], p1[1] - p2[1]];\n}\n\n/**\n * Normalize a point\n * @param {Array<number>} p\n * @return {Array<number>}\n * @private\n */\nexport function normalize(p) {\n  let length = Math.sqrt(p[0] ** 2 + p[1] ** 2);\n  return [p[0] / length, p[1] / length];\n}\n\n/**\n * We rotate an array of points\n * @param {number} radians\n * @param {Array<Array<number>>} srcPoints\n * @param {Array<Array<number>>} destPoints\n * @return {Array<Array<number>>}\n * @private\n */\nexport function rotate(radians, srcPoints, destPoints) {\n  if (destPoints === undefined) destPoints = new Array(srcPoints.length);\n  let cos = Math.cos(radians);\n  let sin = Math.sin(radians);\n  for (let i = 0; i < destPoints.length; ++i) {\n    destPoints[i] = [\n      cos * srcPoints[i][0] - sin * srcPoints[i][1],\n      sin * srcPoints[i][0] + cos * srcPoints[i][1],\n    ];\n  }\n  return destPoints;\n}\n\n/**\n * Dot products of 2 points assuming vectors starting from (0,0)\n * @param {Array<number>} p1\n * @param {Array<number>} p2\n * @return {number}\n * @private\n */\nexport function dot(p1, p2) {\n  return p1[0] * p2[0] + p1[1] * p2[1];\n}\n\n/**\n * Returns the angle between 3 points. The first one is a common point\n * @param {Array<number>} origin\n * @param {Array<number>} p1\n * @param {Array<number>} p2\n * @return {number}\n * @private\n */\nexport function angle(origin, p1, p2) {\n  let v1 = normalize(difference(p1, origin));\n  let v2 = normalize(difference(p2, origin));\n  let dotProduct = dot(v1, v2);\n  // TODO this code is not correct because it may yield the opposite angle\n  return Math.acos(dotProduct);\n}\n\n/**\n * Returns the 4 points of an horizontal rectangle that includes all the points\n * @param {Array<Array<number>>} points\n * @return {Array<Array<number>>}\n * @private\n */\nexport function boundary(points) {\n  let minMaxValues = minMax(points);\n  let xMin = minMaxValues[0][0];\n  let yMin = minMaxValues[0][1];\n  let xMax = minMaxValues[1][0];\n  let yMax = minMaxValues[1][1];\n  return [\n    [xMin, yMin],\n    [xMax, yMin],\n    [xMax, yMax],\n    [xMin, yMax],\n  ];\n}\n\n/**\n * Returns the perimeter represented by the points (a polygon)\n * @param {Array<Array<number>>} points\n */\nexport function perimeter(vertices) {\n  let total = 0;\n  for (let i = 0; i < vertices.length; i++) {\n    let fromX = vertices[i][0];\n    let fromY = vertices[i][1];\n    let toX = vertices[i === vertices.length - 1 ? 0 : i + 1][0];\n    let toY = vertices[i === vertices.length - 1 ? 0 : i + 1][1];\n    total += Math.sqrt((toX - fromX) ** 2 + (toY - fromY) ** 2);\n  }\n  return total;\n}\n\n/**\n * Returns the surface represented by the points (a polygon)\n * @param {Array<Array<number>>} points\n */\nexport function surface(vertices) {\n  let total = 0;\n\n  for (let i = 0; i < vertices.length; i++) {\n    let addX = vertices[i][0];\n    let addY = vertices[i === vertices.length - 1 ? 0 : i + 1][1];\n    let subX = vertices[i === vertices.length - 1 ? 0 : i + 1][0];\n    let subY = vertices[i][1];\n\n    total += addX * addY * 0.5;\n    total -= subX * subY * 0.5;\n  }\n\n  return Math.abs(total);\n}\n\n/**\n * Returns 2 points with minimal and maximal XY\n * @param {Array<Array<number>>} points\n * @return {Array<Array<number>>}\n * @private\n */\nexport function minMax(points) {\n  let xMin = +Infinity;\n  let yMin = +Infinity;\n  let xMax = -Infinity;\n  let yMax = -Infinity;\n  for (let i = 0; i < points.length; i++) {\n    if (points[i][0] < xMin) xMin = points[i][0];\n    if (points[i][0] > xMax) xMax = points[i][0];\n    if (points[i][1] < yMin) yMin = points[i][1];\n    if (points[i][1] > yMax) yMax = points[i][1];\n  }\n  return [\n    [xMin, yMin],\n    [xMax, yMax],\n  ];\n}\n\n/**\n * Moves the minX, minY to 0,0\n * All the points will be positive after this move\n * @param {Array<Array<number>>} srcPoints\n * @param {Array<Array<number>>} destPoints\n * @return {Array<Array<number>>}\n * @private\n */\nexport function moveToZeroZero(srcPoints, destPoints) {\n  if (destPoints === undefined) {\n    destPoints = new Array(srcPoints.length).fill(0).map(() => []);\n  }\n  let minMaxValues = minMax(srcPoints);\n  let xMin = minMaxValues[0][0];\n  let yMin = minMaxValues[0][1];\n  for (let i = 0; i < srcPoints.length; i++) {\n    destPoints[i][0] = srcPoints[i][0] - xMin;\n    destPoints[i][1] = srcPoints[i][1] - yMin;\n  }\n  return destPoints;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}