{"ast":null,"code":"import { getColors } from '../../util/color';\nimport { RGB } from '../model/model';\n\n/**\n * Paint a mask or masks on the current image.\n * @memberof Image\n * @instance\n * @param {(Image|Array<Image>)}     masks - Image containing a binary mask\n * @param {object}              [options]\n * @param {Array<number>|string}     [options.color] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {boolean}             [options.randomColors=true] - To paint each mask with a random color if color and colors are undefined\n * @param {boolean}             [options.distinctColors=false] - To paint each mask with a different color if color and colors are undefined\n * @param {number}              [options.alpha=255] - Value from 0 to 255 to specify the alpha.\n * @param {Array<string>}       [options.labels] - Array of labels to display. Should the the same size as masks.\n * @param {Array<Array<number>>} [options.labelsPosition] - Array of points [x,y] where the labels should be displayed.\n *                                      By default it is the 0,0 position of the correesponding mask.\n * @param {string}              [options.labelColor='blue'] - Define the color to paint the labels\n * @param {string}              [options.labelFont='12px Helvetica'] - Paint the labels in a different CSS style\n * @return {this} The original painted image\n */\nexport default function paintMasks(masks, options = {}) {\n  let {\n    alpha = 255,\n    labels = [],\n    labelsPosition = [],\n    labelColor = 'blue',\n    labelFont = '12px Helvetica'\n  } = options;\n  this.checkProcessable('paintMasks', {\n    channels: [3, 4],\n    bitDepth: [8, 16],\n    colorModel: RGB\n  });\n  let colors = getColors(Object.assign({}, options, {\n    numberColors: masks.length\n  }));\n  if (!Array.isArray(masks)) {\n    masks = [masks];\n  }\n  for (let i = 0; i < masks.length; i++) {\n    let mask = masks[i];\n    // we need to find the parent image to calculate the relative position\n    let color = colors[i % colors.length];\n    for (let x = 0; x < mask.width; x++) {\n      for (let y = 0; y < mask.height; y++) {\n        if (mask.getBitXY(x, y)) {\n          for (let component = 0; component < Math.min(this.components, color.length); component++) {\n            if (alpha === 255) {\n              this.setValueXY(x + mask.position[0], y + mask.position[1], component, color[component]);\n            } else {\n              let value = this.getValueXY(x + mask.position[0], y + mask.position[1], component);\n              value = Math.round((value * (255 - alpha) + color[component] * alpha) / 255);\n              this.setValueXY(x + mask.position[0], y + mask.position[1], component, value);\n            }\n          }\n        }\n      }\n    }\n  }\n  if (Array.isArray(labels) && labels.length > 0) {\n    let canvas = this.getCanvas();\n    let ctx = canvas.getContext('2d');\n    ctx.fillStyle = labelColor;\n    ctx.font = labelFont;\n    for (let i = 0; i < Math.min(masks.length, labels.length); i++) {\n      let position = labelsPosition[i] ? labelsPosition[i] : masks[i].position;\n      ctx.fillText(labels[i], position[0], position[1]);\n    }\n    this.data = Uint8Array.from(ctx.getImageData(0, 0, this.width, this.height).data);\n  }\n  return this;\n}","map":{"version":3,"names":["getColors","RGB","paintMasks","masks","options","alpha","labels","labelsPosition","labelColor","labelFont","checkProcessable","channels","bitDepth","colorModel","colors","Object","assign","numberColors","length","Array","isArray","i","mask","color","x","width","y","height","getBitXY","component","Math","min","components","setValueXY","position","value","getValueXY","round","canvas","getCanvas","ctx","getContext","fillStyle","font","fillText","data","Uint8Array","from","getImageData"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/operator/paintMasks.js"],"sourcesContent":["import { getColors } from '../../util/color';\nimport { RGB } from '../model/model';\n\n/**\n * Paint a mask or masks on the current image.\n * @memberof Image\n * @instance\n * @param {(Image|Array<Image>)}     masks - Image containing a binary mask\n * @param {object}              [options]\n * @param {Array<number>|string}     [options.color] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {boolean}             [options.randomColors=true] - To paint each mask with a random color if color and colors are undefined\n * @param {boolean}             [options.distinctColors=false] - To paint each mask with a different color if color and colors are undefined\n * @param {number}              [options.alpha=255] - Value from 0 to 255 to specify the alpha.\n * @param {Array<string>}       [options.labels] - Array of labels to display. Should the the same size as masks.\n * @param {Array<Array<number>>} [options.labelsPosition] - Array of points [x,y] where the labels should be displayed.\n *                                      By default it is the 0,0 position of the correesponding mask.\n * @param {string}              [options.labelColor='blue'] - Define the color to paint the labels\n * @param {string}              [options.labelFont='12px Helvetica'] - Paint the labels in a different CSS style\n * @return {this} The original painted image\n */\nexport default function paintMasks(masks, options = {}) {\n  let {\n    alpha = 255,\n    labels = [],\n    labelsPosition = [],\n    labelColor = 'blue',\n    labelFont = '12px Helvetica',\n  } = options;\n\n  this.checkProcessable('paintMasks', {\n    channels: [3, 4],\n    bitDepth: [8, 16],\n    colorModel: RGB,\n  });\n\n  let colors = getColors(\n    Object.assign({}, options, { numberColors: masks.length }),\n  );\n\n  if (!Array.isArray(masks)) {\n    masks = [masks];\n  }\n\n  for (let i = 0; i < masks.length; i++) {\n    let mask = masks[i];\n    // we need to find the parent image to calculate the relative position\n    let color = colors[i % colors.length];\n    for (let x = 0; x < mask.width; x++) {\n      for (let y = 0; y < mask.height; y++) {\n        if (mask.getBitXY(x, y)) {\n          for (\n            let component = 0;\n            component < Math.min(this.components, color.length);\n            component++\n          ) {\n            if (alpha === 255) {\n              this.setValueXY(\n                x + mask.position[0],\n                y + mask.position[1],\n                component,\n                color[component],\n              );\n            } else {\n              let value = this.getValueXY(\n                x + mask.position[0],\n                y + mask.position[1],\n                component,\n              );\n              value = Math.round(\n                (value * (255 - alpha) + color[component] * alpha) / 255,\n              );\n              this.setValueXY(\n                x + mask.position[0],\n                y + mask.position[1],\n                component,\n                value,\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (Array.isArray(labels) && labels.length > 0) {\n    let canvas = this.getCanvas();\n    let ctx = canvas.getContext('2d');\n    ctx.fillStyle = labelColor;\n    ctx.font = labelFont;\n    for (let i = 0; i < Math.min(masks.length, labels.length); i++) {\n      let position = labelsPosition[i] ? labelsPosition[i] : masks[i].position;\n      ctx.fillText(labels[i], position[0], position[1]);\n    }\n    this.data = Uint8Array.from(\n      ctx.getImageData(0, 0, this.width, this.height).data,\n    );\n  }\n\n  return this;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}