{"ast":null,"code":"import Image from '../Image';\n\n/**\n * Dilatation is one of two fundamental operations (with erosion) in morphological\n * image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local maximum among the pixels with a kernel value of 1.\n * http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html\n * https://en.wikipedia.org/wiki/Dilation_(morphology)\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.kernel] - The kernel can only have ones and zeros. Default: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n * @param {number} [options.iterations=1] - The number of successive erosions\n * @return {Image}\n */\nexport default function dilate(options = {}) {\n  let {\n    kernel = [[1, 1, 1], [1, 1, 1], [1, 1, 1]],\n    iterations = 1\n  } = options;\n  this.checkProcessable('dilate', {\n    bitDepth: [1, 8, 16],\n    components: 1,\n    alpha: 0\n  });\n  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {\n    throw new TypeError('dilate: The number of rows and columns of the kernel must be odd');\n  }\n  let onlyOnes = true;\n  outer: for (const row of kernel) {\n    for (const value of row) {\n      if (value !== 1) {\n        onlyOnes = false;\n        break outer;\n      }\n    }\n  }\n  let result = this;\n  for (let i = 0; i < iterations; i++) {\n    if (this.bitDepth === 1) {\n      if (onlyOnes) {\n        const newImage = result.clone();\n        result = dilateOnceBinaryOnlyOnes(result, newImage, kernel.length, kernel[0].length);\n      } else {\n        const newImage = Image.createFrom(result);\n        result = dilateOnceBinary(result, newImage, kernel);\n      }\n    } else if (onlyOnes) {\n      const newImage = Image.createFrom(result);\n      result = dilateOnceGreyOnlyOnes(result, newImage, kernel.length, kernel[0].length);\n    } else {\n      const newImage = Image.createFrom(result);\n      result = dilateOnceGrey(result, newImage, kernel);\n    }\n  }\n  return result;\n}\nfunction dilateOnceGrey(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (i < 0 || j < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getValueXY(i, j, 0);\n          if (value > max) max = value;\n        }\n      }\n      newImage.setValueXY(x, y, 0, max);\n    }\n  }\n  return newImage;\n}\nfunction dilateOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n  const maxList = [];\n  for (let x = 0; x < img.width; x++) {\n    maxList.push(0);\n  }\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {\n        const value = img.getValueXY(x, h, 0);\n        if (value > max) {\n          max = value;\n        }\n      }\n      maxList[x] = max;\n    }\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {\n        if (maxList[i] > max) {\n          max = maxList[i];\n        }\n      }\n      newImage.setValueXY(x, y, 0, max);\n    }\n  }\n  return newImage;\n}\nfunction dilateOnceBinary(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      intLoop: for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (j < 0 || i < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getBitXY(i, j);\n          if (value === 1) {\n            max = 1;\n            break intLoop;\n          }\n        }\n      }\n      if (max === 1) {\n        newImage.setBitXY(x, y);\n      }\n    }\n  }\n  return newImage;\n}\nfunction dilateOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n  const maxList = [];\n  for (let x = 0; x < img.width; x++) {\n    maxList.push(1);\n  }\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      maxList[x] = 0;\n      for (let h = Math.max(0, y - radiusY); h < Math.min(img.height, y + radiusY + 1); h++) {\n        if (img.getBitXY(x, h) === 1) {\n          maxList[x] = 1;\n          break;\n        }\n      }\n    }\n    for (let x = 0; x < img.width; x++) {\n      if (newImage.getBitXY(x, y) === 1) continue;\n      for (let i = Math.max(0, x - radiusX); i < Math.min(img.width, x + radiusX + 1); i++) {\n        if (maxList[i] === 1) {\n          newImage.setBitXY(x, y);\n          break;\n        }\n      }\n    }\n  }\n  return newImage;\n}","map":{"version":3,"names":["Image","dilate","options","kernel","iterations","checkProcessable","bitDepth","components","alpha","columns","rows","TypeError","onlyOnes","outer","row","value","result","i","newImage","clone","dilateOnceBinaryOnlyOnes","length","createFrom","dilateOnceBinary","dilateOnceGreyOnlyOnes","dilateOnceGrey","img","kernelWidth","kernelHeight","radiusX","radiusY","y","height","x","width","max","jj","ii","j","getValueXY","setValueXY","maxList","push","h","Math","min","intLoop","getBitXY","setBitXY"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/morphology/dilate.js"],"sourcesContent":["import Image from '../Image';\n\n/**\n * Dilatation is one of two fundamental operations (with erosion) in morphological\n * image processing from which all other morphological operations are based (from Wikipedia).\n * Replaces each value with it's local maximum among the pixels with a kernel value of 1.\n * http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html\n * https://en.wikipedia.org/wiki/Dilation_(morphology)\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.kernel] - The kernel can only have ones and zeros. Default: [[1, 1, 1], [1, 1, 1], [1, 1, 1]]\n * @param {number} [options.iterations=1] - The number of successive erosions\n * @return {Image}\n */\nexport default function dilate(options = {}) {\n  let {\n    kernel = [\n      [1, 1, 1],\n      [1, 1, 1],\n      [1, 1, 1],\n    ],\n    iterations = 1,\n  } = options;\n\n  this.checkProcessable('dilate', {\n    bitDepth: [1, 8, 16],\n    components: 1,\n    alpha: 0,\n  });\n  if (kernel.columns % 2 === 0 || kernel.rows % 2 === 0) {\n    throw new TypeError(\n      'dilate: The number of rows and columns of the kernel must be odd',\n    );\n  }\n\n  let onlyOnes = true;\n  outer: for (const row of kernel) {\n    for (const value of row) {\n      if (value !== 1) {\n        onlyOnes = false;\n        break outer;\n      }\n    }\n  }\n\n  let result = this;\n  for (let i = 0; i < iterations; i++) {\n    if (this.bitDepth === 1) {\n      if (onlyOnes) {\n        const newImage = result.clone();\n        result = dilateOnceBinaryOnlyOnes(\n          result,\n          newImage,\n          kernel.length,\n          kernel[0].length,\n        );\n      } else {\n        const newImage = Image.createFrom(result);\n        result = dilateOnceBinary(result, newImage, kernel);\n      }\n    } else if (onlyOnes) {\n      const newImage = Image.createFrom(result);\n      result = dilateOnceGreyOnlyOnes(\n        result,\n        newImage,\n        kernel.length,\n        kernel[0].length,\n      );\n    } else {\n      const newImage = Image.createFrom(result);\n      result = dilateOnceGrey(result, newImage, kernel);\n    }\n  }\n  return result;\n}\n\nfunction dilateOnceGrey(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (i < 0 || j < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getValueXY(i, j, 0);\n          if (value > max) max = value;\n        }\n      }\n      newImage.setValueXY(x, y, 0, max);\n    }\n  }\n  return newImage;\n}\n\nfunction dilateOnceGreyOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n\n  const maxList = [];\n  for (let x = 0; x < img.width; x++) {\n    maxList.push(0);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      for (\n        let h = Math.max(0, y - radiusY);\n        h < Math.min(img.height, y + radiusY + 1);\n        h++\n      ) {\n        const value = img.getValueXY(x, h, 0);\n        if (value > max) {\n          max = value;\n        }\n      }\n      maxList[x] = max;\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      for (\n        let i = Math.max(0, x - radiusX);\n        i < Math.min(img.width, x + radiusX + 1);\n        i++\n      ) {\n        if (maxList[i] > max) {\n          max = maxList[i];\n        }\n      }\n      newImage.setValueXY(x, y, 0, max);\n    }\n  }\n  return newImage;\n}\n\nfunction dilateOnceBinary(img, newImage, kernel) {\n  const kernelWidth = kernel.length;\n  const kernelHeight = kernel[0].length;\n  let radiusX = (kernelWidth - 1) / 2;\n  let radiusY = (kernelHeight - 1) / 2;\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      let max = 0;\n      intLoop: for (let jj = 0; jj < kernelHeight; jj++) {\n        for (let ii = 0; ii < kernelWidth; ii++) {\n          if (kernel[ii][jj] !== 1) continue;\n          let i = ii - radiusX + x;\n          let j = jj - radiusY + y;\n          if (j < 0 || i < 0 || i >= img.width || j >= img.height) continue;\n          const value = img.getBitXY(i, j);\n          if (value === 1) {\n            max = 1;\n            break intLoop;\n          }\n        }\n      }\n      if (max === 1) {\n        newImage.setBitXY(x, y);\n      }\n    }\n  }\n  return newImage;\n}\n\nfunction dilateOnceBinaryOnlyOnes(img, newImage, kernelWidth, kernelHeight) {\n  const radiusX = (kernelWidth - 1) / 2;\n  const radiusY = (kernelHeight - 1) / 2;\n\n  const maxList = [];\n  for (let x = 0; x < img.width; x++) {\n    maxList.push(1);\n  }\n\n  for (let y = 0; y < img.height; y++) {\n    for (let x = 0; x < img.width; x++) {\n      maxList[x] = 0;\n      for (\n        let h = Math.max(0, y - radiusY);\n        h < Math.min(img.height, y + radiusY + 1);\n        h++\n      ) {\n        if (img.getBitXY(x, h) === 1) {\n          maxList[x] = 1;\n          break;\n        }\n      }\n    }\n\n    for (let x = 0; x < img.width; x++) {\n      if (newImage.getBitXY(x, y) === 1) continue;\n      for (\n        let i = Math.max(0, x - radiusX);\n        i < Math.min(img.width, x + radiusX + 1);\n        i++\n      ) {\n        if (maxList[i] === 1) {\n          newImage.setBitXY(x, y);\n          break;\n        }\n      }\n    }\n  }\n  return newImage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}