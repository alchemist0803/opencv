{"ast":null,"code":"import Matrix from '../../util/matrix';\n\n/**\n * Try to match the current pictures with another one\n * @memberof Image\n * @instance\n * @param {Image} image - Other image to match\n * @param {object} [options]\n * @return {number[]}\n */\nexport default function getBestMatch(image, options = {}) {\n  let {\n    border\n  } = options;\n  this.checkProcessable('getChannel', {\n    bitDepth: [8, 16]\n  });\n  if (this.bitDepth !== image.bitDepth) {\n    throw new Error('Both images must have the same bitDepth');\n  }\n  if (this.channels !== image.channels) {\n    throw new Error('Both images must have the same number of channels');\n  }\n  if (this.colorModel !== image.colorModel) {\n    throw new Error('Both images must have the same colorModel');\n  }\n\n  // there could be many names\n  let similarityMatrix = new Matrix(image.width, image.height, -Infinity);\n  let currentX = Math.floor(image.width / 2);\n  let currentY = Math.floor(image.height / 2);\n  let middleX = currentX;\n  let middleY = currentY;\n  let theEnd = false;\n  while (!theEnd) {\n    let toCalculatePositions = similarityMatrix.localSearch(currentX, currentY, -Infinity);\n    for (let i = 0; i < toCalculatePositions.length; i++) {\n      let position = toCalculatePositions[i];\n      let similarity = this.getSimilarity(image, {\n        border: border,\n        shift: [middleX - position[0], middleY - position[1]]\n      });\n      similarityMatrix[position[0]][position[1]] = similarity;\n    }\n    let max = similarityMatrix.localMax(currentX, currentY);\n    if (max.position[0] !== currentX || max.position[1] !== currentY) {\n      currentX = max.position[0];\n      currentY = max.position[1];\n    } else {\n      theEnd = true;\n    }\n  }\n  return [currentX - middleX, currentY - middleY];\n}","map":{"version":3,"names":["Matrix","getBestMatch","image","options","border","checkProcessable","bitDepth","Error","channels","colorModel","similarityMatrix","width","height","Infinity","currentX","Math","floor","currentY","middleX","middleY","theEnd","toCalculatePositions","localSearch","i","length","position","similarity","getSimilarity","shift","max","localMax"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/utility/getBestMatch.js"],"sourcesContent":["import Matrix from '../../util/matrix';\n\n/**\n * Try to match the current pictures with another one\n * @memberof Image\n * @instance\n * @param {Image} image - Other image to match\n * @param {object} [options]\n * @return {number[]}\n */\nexport default function getBestMatch(image, options = {}) {\n  let { border } = options;\n\n  this.checkProcessable('getChannel', {\n    bitDepth: [8, 16],\n  });\n\n  if (this.bitDepth !== image.bitDepth) {\n    throw new Error('Both images must have the same bitDepth');\n  }\n  if (this.channels !== image.channels) {\n    throw new Error('Both images must have the same number of channels');\n  }\n  if (this.colorModel !== image.colorModel) {\n    throw new Error('Both images must have the same colorModel');\n  }\n\n  // there could be many names\n  let similarityMatrix = new Matrix(image.width, image.height, -Infinity);\n\n  let currentX = Math.floor(image.width / 2);\n  let currentY = Math.floor(image.height / 2);\n  let middleX = currentX;\n  let middleY = currentY;\n  let theEnd = false;\n\n  while (!theEnd) {\n    let toCalculatePositions = similarityMatrix.localSearch(\n      currentX,\n      currentY,\n      -Infinity,\n    );\n    for (let i = 0; i < toCalculatePositions.length; i++) {\n      let position = toCalculatePositions[i];\n      let similarity = this.getSimilarity(image, {\n        border: border,\n        shift: [middleX - position[0], middleY - position[1]],\n      });\n      similarityMatrix[position[0]][position[1]] = similarity;\n    }\n\n    let max = similarityMatrix.localMax(currentX, currentY);\n    if (max.position[0] !== currentX || max.position[1] !== currentY) {\n      currentX = max.position[0];\n      currentY = max.position[1];\n    } else {\n      theEnd = true;\n    }\n  }\n\n  return [currentX - middleX, currentY - middleY];\n}\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,mBAAmB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,YAAYA,CAACC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACxD,IAAI;IAAEC;EAAO,CAAC,GAAGD,OAAO;EAExB,IAAI,CAACE,gBAAgB,CAAC,YAAY,EAAE;IAClCC,QAAQ,EAAE,CAAC,CAAC,EAAE,EAAE;EAClB,CAAC,CAAC;EAEF,IAAI,IAAI,CAACA,QAAQ,KAAKJ,KAAK,CAACI,QAAQ,EAAE;IACpC,MAAM,IAAIC,KAAK,CAAC,yCAAyC,CAAC;EAC5D;EACA,IAAI,IAAI,CAACC,QAAQ,KAAKN,KAAK,CAACM,QAAQ,EAAE;IACpC,MAAM,IAAID,KAAK,CAAC,mDAAmD,CAAC;EACtE;EACA,IAAI,IAAI,CAACE,UAAU,KAAKP,KAAK,CAACO,UAAU,EAAE;IACxC,MAAM,IAAIF,KAAK,CAAC,2CAA2C,CAAC;EAC9D;;EAEA;EACA,IAAIG,gBAAgB,GAAG,IAAIV,MAAM,CAACE,KAAK,CAACS,KAAK,EAAET,KAAK,CAACU,MAAM,EAAE,CAACC,QAAQ,CAAC;EAEvE,IAAIC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACd,KAAK,CAACS,KAAK,GAAG,CAAC,CAAC;EAC1C,IAAIM,QAAQ,GAAGF,IAAI,CAACC,KAAK,CAACd,KAAK,CAACU,MAAM,GAAG,CAAC,CAAC;EAC3C,IAAIM,OAAO,GAAGJ,QAAQ;EACtB,IAAIK,OAAO,GAAGF,QAAQ;EACtB,IAAIG,MAAM,GAAG,KAAK;EAElB,OAAO,CAACA,MAAM,EAAE;IACd,IAAIC,oBAAoB,GAAGX,gBAAgB,CAACY,WAAW,CACrDR,QAAQ,EACRG,QAAQ,EACR,CAACJ,QACH,CAAC;IACD,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,oBAAoB,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MACpD,IAAIE,QAAQ,GAAGJ,oBAAoB,CAACE,CAAC,CAAC;MACtC,IAAIG,UAAU,GAAG,IAAI,CAACC,aAAa,CAACzB,KAAK,EAAE;QACzCE,MAAM,EAAEA,MAAM;QACdwB,KAAK,EAAE,CAACV,OAAO,GAAGO,QAAQ,CAAC,CAAC,CAAC,EAAEN,OAAO,GAAGM,QAAQ,CAAC,CAAC,CAAC;MACtD,CAAC,CAAC;MACFf,gBAAgB,CAACe,QAAQ,CAAC,CAAC,CAAC,CAAC,CAACA,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAGC,UAAU;IACzD;IAEA,IAAIG,GAAG,GAAGnB,gBAAgB,CAACoB,QAAQ,CAAChB,QAAQ,EAAEG,QAAQ,CAAC;IACvD,IAAIY,GAAG,CAACJ,QAAQ,CAAC,CAAC,CAAC,KAAKX,QAAQ,IAAIe,GAAG,CAACJ,QAAQ,CAAC,CAAC,CAAC,KAAKR,QAAQ,EAAE;MAChEH,QAAQ,GAAGe,GAAG,CAACJ,QAAQ,CAAC,CAAC,CAAC;MAC1BR,QAAQ,GAAGY,GAAG,CAACJ,QAAQ,CAAC,CAAC,CAAC;IAC5B,CAAC,MAAM;MACLL,MAAM,GAAG,IAAI;IACf;EACF;EAEA,OAAO,CAACN,QAAQ,GAAGI,OAAO,EAAED,QAAQ,GAAGE,OAAO,CAAC;AACjD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}