{"ast":null,"code":"import { validateArrayOfChannels } from '../../util/channel';\n\n/**\n * Calculate a new image that is the subtraction between the current image and the otherImage.\n * @memberof Image\n * @instance\n * @param {Image} otherImage\n * @param {object} [options={}]\n * @param {number[]|string[]} [options.channels] : to which channel to apply the filter. By default all but alpha.\n * @param {number[]|string[]} [options.absolute=false] :.take the absolute value of the difference (default minimum=0)\n * @return {Image}\n */\nexport default function subtractImage(otherImage, options = {}) {\n  let {\n    channels,\n    absolute = false\n  } = options;\n  this.checkProcessable('subtractImage', {\n    bitDepth: [8, 16]\n  });\n  if (this.width !== otherImage.width || this.height !== otherImage.height) {\n    throw new Error('subtractImage: both images must have the same size');\n  }\n  if (this.alpha !== otherImage.alpha || this.bitDepth !== otherImage.bitDepth) {\n    throw new Error('subtractImage: both images must have the same alpha and bitDepth');\n  }\n  if (this.channels !== otherImage.channels) {\n    throw new Error('subtractImage: both images must have the same number of channels');\n  }\n  let newImage = this.clone();\n  channels = validateArrayOfChannels(this, {\n    channels: channels\n  });\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n    for (let i = c; i < this.data.length; i += this.channels) {\n      let value = this.data[i] - otherImage.data[i];\n      if (absolute) {\n        newImage.data[i] = Math.abs(value);\n      } else {\n        newImage.data[i] = Math.max(value, 0);\n      }\n    }\n  }\n  return newImage;\n}","map":{"version":3,"names":["validateArrayOfChannels","subtractImage","otherImage","options","channels","absolute","checkProcessable","bitDepth","width","height","Error","alpha","newImage","clone","j","length","c","i","data","value","Math","abs","max"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/filter/subtractImage.js"],"sourcesContent":["import { validateArrayOfChannels } from '../../util/channel';\n\n/**\n * Calculate a new image that is the subtraction between the current image and the otherImage.\n * @memberof Image\n * @instance\n * @param {Image} otherImage\n * @param {object} [options={}]\n * @param {number[]|string[]} [options.channels] : to which channel to apply the filter. By default all but alpha.\n * @param {number[]|string[]} [options.absolute=false] :.take the absolute value of the difference (default minimum=0)\n * @return {Image}\n */\nexport default function subtractImage(otherImage, options = {}) {\n  let { channels, absolute = false } = options;\n  this.checkProcessable('subtractImage', {\n    bitDepth: [8, 16],\n  });\n  if (this.width !== otherImage.width || this.height !== otherImage.height) {\n    throw new Error('subtractImage: both images must have the same size');\n  }\n  if (\n    this.alpha !== otherImage.alpha ||\n    this.bitDepth !== otherImage.bitDepth\n  ) {\n    throw new Error(\n      'subtractImage: both images must have the same alpha and bitDepth',\n    );\n  }\n  if (this.channels !== otherImage.channels) {\n    throw new Error(\n      'subtractImage: both images must have the same number of channels',\n    );\n  }\n\n  let newImage = this.clone();\n\n  channels = validateArrayOfChannels(this, { channels: channels });\n\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n    for (let i = c; i < this.data.length; i += this.channels) {\n      let value = this.data[i] - otherImage.data[i];\n      if (absolute) {\n        newImage.data[i] = Math.abs(value);\n      } else {\n        newImage.data[i] = Math.max(value, 0);\n      }\n    }\n  }\n\n  return newImage;\n}\n"],"mappings":"AAAA,SAASA,uBAAuB,QAAQ,oBAAoB;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,aAAaA,CAACC,UAAU,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC9D,IAAI;IAAEC,QAAQ;IAAEC,QAAQ,GAAG;EAAM,CAAC,GAAGF,OAAO;EAC5C,IAAI,CAACG,gBAAgB,CAAC,eAAe,EAAE;IACrCC,QAAQ,EAAE,CAAC,CAAC,EAAE,EAAE;EAClB,CAAC,CAAC;EACF,IAAI,IAAI,CAACC,KAAK,KAAKN,UAAU,CAACM,KAAK,IAAI,IAAI,CAACC,MAAM,KAAKP,UAAU,CAACO,MAAM,EAAE;IACxE,MAAM,IAAIC,KAAK,CAAC,oDAAoD,CAAC;EACvE;EACA,IACE,IAAI,CAACC,KAAK,KAAKT,UAAU,CAACS,KAAK,IAC/B,IAAI,CAACJ,QAAQ,KAAKL,UAAU,CAACK,QAAQ,EACrC;IACA,MAAM,IAAIG,KAAK,CACb,kEACF,CAAC;EACH;EACA,IAAI,IAAI,CAACN,QAAQ,KAAKF,UAAU,CAACE,QAAQ,EAAE;IACzC,MAAM,IAAIM,KAAK,CACb,kEACF,CAAC;EACH;EAEA,IAAIE,QAAQ,GAAG,IAAI,CAACC,KAAK,CAAC,CAAC;EAE3BT,QAAQ,GAAGJ,uBAAuB,CAAC,IAAI,EAAE;IAAEI,QAAQ,EAAEA;EAAS,CAAC,CAAC;EAEhE,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,QAAQ,CAACW,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC,IAAIE,CAAC,GAAGZ,QAAQ,CAACU,CAAC,CAAC;IACnB,KAAK,IAAIG,CAAC,GAAGD,CAAC,EAAEC,CAAC,GAAG,IAAI,CAACC,IAAI,CAACH,MAAM,EAAEE,CAAC,IAAI,IAAI,CAACb,QAAQ,EAAE;MACxD,IAAIe,KAAK,GAAG,IAAI,CAACD,IAAI,CAACD,CAAC,CAAC,GAAGf,UAAU,CAACgB,IAAI,CAACD,CAAC,CAAC;MAC7C,IAAIZ,QAAQ,EAAE;QACZO,QAAQ,CAACM,IAAI,CAACD,CAAC,CAAC,GAAGG,IAAI,CAACC,GAAG,CAACF,KAAK,CAAC;MACpC,CAAC,MAAM;QACLP,QAAQ,CAACM,IAAI,CAACD,CAAC,CAAC,GAAGG,IAAI,CAACE,GAAG,CAACH,KAAK,EAAE,CAAC,CAAC;MACvC;IACF;EACF;EAEA,OAAOP,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}