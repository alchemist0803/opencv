{"ast":null,"code":"// based on https://bgrins.github.io/TinyColor/docs/tinycolor.html\n\nimport Image from '../Image';\nimport { RGB, HSV } from '../model/model';\n\n/**\n * Make a copy of the current image and convert the color model to HSV\n * The source image has to be RGB !\n * @memberof Image\n * @instance\n * @return {Image} - New image in HSV color model\n * @example\n * var hsvImage = image.hsv();\n * // we can create one image per channel\n * var channels = hsvImage.split();\n */\nexport default function hsv() {\n  this.checkProcessable('hsv', {\n    bitDepth: [8, 16],\n    alpha: [0, 1],\n    colorModel: [RGB]\n  });\n  let newImage = Image.createFrom(this, {\n    colorModel: HSV\n  });\n  let ptr = 0;\n  let data = this.data;\n  for (let i = 0; i < data.length; i += this.channels) {\n    let red = data[i];\n    let green = data[i + 1];\n    let blue = data[i + 2];\n    let min = Math.min(red, green, blue);\n    let max = Math.max(red, green, blue);\n    let delta = max - min;\n    let hue = 0;\n    let saturation = max === 0 ? 0 : delta / max;\n    let value = max;\n    if (max !== min) {\n      switch (max) {\n        case red:\n          hue = (green - blue) / delta + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / delta + 2;\n          break;\n        case blue:\n          hue = (red - green) / delta + 4;\n          break;\n        default:\n          throw new Error('unreachable');\n      }\n      hue /= 6;\n    }\n    newImage.data[ptr++] = hue * this.maxValue;\n    newImage.data[ptr++] = saturation * this.maxValue;\n    newImage.data[ptr++] = value;\n    if (this.alpha) {\n      newImage.data[ptr++] = data[i + 3];\n    }\n  }\n  return newImage;\n}","map":{"version":3,"names":["Image","RGB","HSV","hsv","checkProcessable","bitDepth","alpha","colorModel","newImage","createFrom","ptr","data","i","length","channels","red","green","blue","min","Math","max","delta","hue","saturation","value","Error","maxValue"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/hsv.js"],"sourcesContent":["// based on https://bgrins.github.io/TinyColor/docs/tinycolor.html\n\nimport Image from '../Image';\nimport { RGB, HSV } from '../model/model';\n\n/**\n * Make a copy of the current image and convert the color model to HSV\n * The source image has to be RGB !\n * @memberof Image\n * @instance\n * @return {Image} - New image in HSV color model\n * @example\n * var hsvImage = image.hsv();\n * // we can create one image per channel\n * var channels = hsvImage.split();\n */\nexport default function hsv() {\n  this.checkProcessable('hsv', {\n    bitDepth: [8, 16],\n    alpha: [0, 1],\n    colorModel: [RGB],\n  });\n\n  let newImage = Image.createFrom(this, {\n    colorModel: HSV,\n  });\n\n  let ptr = 0;\n  let data = this.data;\n  for (let i = 0; i < data.length; i += this.channels) {\n    let red = data[i];\n    let green = data[i + 1];\n    let blue = data[i + 2];\n\n    let min = Math.min(red, green, blue);\n    let max = Math.max(red, green, blue);\n    let delta = max - min;\n    let hue = 0;\n    let saturation = max === 0 ? 0 : delta / max;\n    let value = max;\n\n    if (max !== min) {\n      switch (max) {\n        case red:\n          hue = (green - blue) / delta + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / delta + 2;\n          break;\n        case blue:\n          hue = (red - green) / delta + 4;\n          break;\n        default:\n          throw new Error('unreachable');\n      }\n      hue /= 6;\n    }\n\n    newImage.data[ptr++] = hue * this.maxValue;\n    newImage.data[ptr++] = saturation * this.maxValue;\n    newImage.data[ptr++] = value;\n    if (this.alpha) {\n      newImage.data[ptr++] = data[i + 3];\n    }\n  }\n\n  return newImage;\n}\n"],"mappings":"AAAA;;AAEA,OAAOA,KAAK,MAAM,UAAU;AAC5B,SAASC,GAAG,EAAEC,GAAG,QAAQ,gBAAgB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,GAAGA,CAAA,EAAG;EAC5B,IAAI,CAACC,gBAAgB,CAAC,KAAK,EAAE;IAC3BC,QAAQ,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;IACjBC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IACbC,UAAU,EAAE,CAACN,GAAG;EAClB,CAAC,CAAC;EAEF,IAAIO,QAAQ,GAAGR,KAAK,CAACS,UAAU,CAAC,IAAI,EAAE;IACpCF,UAAU,EAAEL;EACd,CAAC,CAAC;EAEF,IAAIQ,GAAG,GAAG,CAAC;EACX,IAAIC,IAAI,GAAG,IAAI,CAACA,IAAI;EACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACE,MAAM,EAAED,CAAC,IAAI,IAAI,CAACE,QAAQ,EAAE;IACnD,IAAIC,GAAG,GAAGJ,IAAI,CAACC,CAAC,CAAC;IACjB,IAAII,KAAK,GAAGL,IAAI,CAACC,CAAC,GAAG,CAAC,CAAC;IACvB,IAAIK,IAAI,GAAGN,IAAI,CAACC,CAAC,GAAG,CAAC,CAAC;IAEtB,IAAIM,GAAG,GAAGC,IAAI,CAACD,GAAG,CAACH,GAAG,EAAEC,KAAK,EAAEC,IAAI,CAAC;IACpC,IAAIG,GAAG,GAAGD,IAAI,CAACC,GAAG,CAACL,GAAG,EAAEC,KAAK,EAAEC,IAAI,CAAC;IACpC,IAAII,KAAK,GAAGD,GAAG,GAAGF,GAAG;IACrB,IAAII,GAAG,GAAG,CAAC;IACX,IAAIC,UAAU,GAAGH,GAAG,KAAK,CAAC,GAAG,CAAC,GAAGC,KAAK,GAAGD,GAAG;IAC5C,IAAII,KAAK,GAAGJ,GAAG;IAEf,IAAIA,GAAG,KAAKF,GAAG,EAAE;MACf,QAAQE,GAAG;QACT,KAAKL,GAAG;UACNO,GAAG,GAAG,CAACN,KAAK,GAAGC,IAAI,IAAII,KAAK,IAAIL,KAAK,GAAGC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;UACrD;QACF,KAAKD,KAAK;UACRM,GAAG,GAAG,CAACL,IAAI,GAAGF,GAAG,IAAIM,KAAK,GAAG,CAAC;UAC9B;QACF,KAAKJ,IAAI;UACPK,GAAG,GAAG,CAACP,GAAG,GAAGC,KAAK,IAAIK,KAAK,GAAG,CAAC;UAC/B;QACF;UACE,MAAM,IAAII,KAAK,CAAC,aAAa,CAAC;MAClC;MACAH,GAAG,IAAI,CAAC;IACV;IAEAd,QAAQ,CAACG,IAAI,CAACD,GAAG,EAAE,CAAC,GAAGY,GAAG,GAAG,IAAI,CAACI,QAAQ;IAC1ClB,QAAQ,CAACG,IAAI,CAACD,GAAG,EAAE,CAAC,GAAGa,UAAU,GAAG,IAAI,CAACG,QAAQ;IACjDlB,QAAQ,CAACG,IAAI,CAACD,GAAG,EAAE,CAAC,GAAGc,KAAK;IAC5B,IAAI,IAAI,CAAClB,KAAK,EAAE;MACdE,QAAQ,CAACG,IAAI,CAACD,GAAG,EAAE,CAAC,GAAGC,IAAI,CAACC,CAAC,GAAG,CAAC,CAAC;IACpC;EACF;EAEA,OAAOJ,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}