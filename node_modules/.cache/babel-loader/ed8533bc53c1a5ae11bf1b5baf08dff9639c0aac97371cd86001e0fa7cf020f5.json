{"ast":null,"code":"/**\n * An image may be derived from another image either by a crop\n * or because it is a ROI (region of interest)\n * Also a region of interest can be reprocessed to generated another\n * set of region of interests.\n * It is therefore important to keep the hierarchy of images to know\n * which image is derived from which one and be able to get the\n * relative position of one image in another\n * This methods takes care of this.\n * @memberof Image\n * @instance\n * @param {Image} targetImage\n * @param {object} [options={}]\n * @param {boolean} [options.defaultFurther=false] If set to true and no parent found returns the relative position\n *      to the further parent\n * @return {number[]|boolean}\n */\nexport default function getRelativePosition(targetImage, options = {}) {\n  if (this === targetImage) {\n    return [0, 0];\n  }\n  let position = [0, 0];\n  let currentImage = this;\n  while (currentImage) {\n    if (currentImage === targetImage) {\n      return position;\n    }\n    if (currentImage.position) {\n      position[0] += currentImage.position[0];\n      position[1] += currentImage.position[1];\n    }\n    currentImage = currentImage.parent;\n  }\n  // we should never reach this place, this means we could not find the parent\n  // throw Error('Parent image was not found, can not get relative position.')\n  if (options.defaultFurther) return position;\n  return false;\n}","map":{"version":3,"names":["getRelativePosition","targetImage","options","position","currentImage","parent","defaultFurther"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/compute/relativePosition.js"],"sourcesContent":["/**\n * An image may be derived from another image either by a crop\n * or because it is a ROI (region of interest)\n * Also a region of interest can be reprocessed to generated another\n * set of region of interests.\n * It is therefore important to keep the hierarchy of images to know\n * which image is derived from which one and be able to get the\n * relative position of one image in another\n * This methods takes care of this.\n * @memberof Image\n * @instance\n * @param {Image} targetImage\n * @param {object} [options={}]\n * @param {boolean} [options.defaultFurther=false] If set to true and no parent found returns the relative position\n *      to the further parent\n * @return {number[]|boolean}\n */\nexport default function getRelativePosition(targetImage, options = {}) {\n  if (this === targetImage) {\n    return [0, 0];\n  }\n  let position = [0, 0];\n\n  let currentImage = this;\n  while (currentImage) {\n    if (currentImage === targetImage) {\n      return position;\n    }\n    if (currentImage.position) {\n      position[0] += currentImage.position[0];\n      position[1] += currentImage.position[1];\n    }\n    currentImage = currentImage.parent;\n  }\n  // we should never reach this place, this means we could not find the parent\n  // throw Error('Parent image was not found, can not get relative position.')\n  if (options.defaultFurther) return position;\n\n  return false;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,mBAAmBA,CAACC,WAAW,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACrE,IAAI,IAAI,KAAKD,WAAW,EAAE;IACxB,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC;EACf;EACA,IAAIE,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;EAErB,IAAIC,YAAY,GAAG,IAAI;EACvB,OAAOA,YAAY,EAAE;IACnB,IAAIA,YAAY,KAAKH,WAAW,EAAE;MAChC,OAAOE,QAAQ;IACjB;IACA,IAAIC,YAAY,CAACD,QAAQ,EAAE;MACzBA,QAAQ,CAAC,CAAC,CAAC,IAAIC,YAAY,CAACD,QAAQ,CAAC,CAAC,CAAC;MACvCA,QAAQ,CAAC,CAAC,CAAC,IAAIC,YAAY,CAACD,QAAQ,CAAC,CAAC,CAAC;IACzC;IACAC,YAAY,GAAGA,YAAY,CAACC,MAAM;EACpC;EACA;EACA;EACA,IAAIH,OAAO,CAACI,cAAc,EAAE,OAAOH,QAAQ;EAE3C,OAAO,KAAK;AACd","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}