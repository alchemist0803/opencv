{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { guessStripByteCounts } from './hacks';\nimport { applyHorizontalDifferencing8Bit, applyHorizontalDifferencing16Bit } from './horizontalDifferencing';\nimport IFD from './ifd';\nimport { getByteLength, readData } from './ifdValue';\nimport { decompressLzw } from './lzw';\nimport TiffIfd from './tiffIfd';\nimport { decompressZlib } from './zlib';\nconst defaultOptions = {\n  ignoreImageData: false,\n  onlyFirst: false\n};\nexport default class TIFFDecoder extends IOBuffer {\n  constructor(data) {\n    super(data);\n    this._nextIFD = 0;\n  }\n  get isMultiPage() {\n    let c = 0;\n    this.decodeHeader();\n    while (this._nextIFD) {\n      c++;\n      this.decodeIFD({\n        ignoreImageData: true\n      }, true);\n      if (c === 2) {\n        return true;\n      }\n    }\n    if (c === 1) {\n      return false;\n    }\n    throw unsupported('ifdCount', c);\n  }\n  get pageCount() {\n    let c = 0;\n    this.decodeHeader();\n    while (this._nextIFD) {\n      c++;\n      this.decodeIFD({\n        ignoreImageData: true\n      }, true);\n    }\n    if (c > 0) {\n      return c;\n    }\n    throw unsupported('ifdCount', c);\n  }\n  decode(options = {}) {\n    options = Object.assign({}, defaultOptions, options);\n    const result = [];\n    this.decodeHeader();\n    while (this._nextIFD) {\n      result.push(this.decodeIFD(options, true));\n      if (options.onlyFirst) {\n        return [result[0]];\n      }\n    }\n    return result;\n  }\n  decodeHeader() {\n    // Byte offset\n    const value = this.readUint16();\n    if (value === 0x4949) {\n      this.setLittleEndian();\n    } else if (value === 0x4d4d) {\n      this.setBigEndian();\n    } else {\n      throw new Error(`invalid byte order: 0x${value.toString(16)}`);\n    }\n    // Magic number\n    if (this.readUint16() !== 42) {\n      throw new Error('not a TIFF file');\n    }\n    // Offset of the first IFD\n    this._nextIFD = this.readUint32();\n  }\n  decodeIFD(options, tiff) {\n    this.seek(this._nextIFD);\n    let ifd;\n    if (tiff) {\n      ifd = new TiffIfd();\n    } else {\n      if (!options.kind) {\n        throw new Error(`kind is missing`);\n      }\n      ifd = new IFD(options.kind);\n    }\n    const numEntries = this.readUint16();\n    for (let i = 0; i < numEntries; i++) {\n      this.decodeIFDEntry(ifd);\n    }\n    if (!options.ignoreImageData) {\n      if (!(ifd instanceof TiffIfd)) {\n        throw new Error('must be a tiff ifd');\n      }\n      this.decodeImageData(ifd);\n    }\n    this._nextIFD = this.readUint32();\n    return ifd;\n  }\n  decodeIFDEntry(ifd) {\n    const offset = this.offset;\n    const tag = this.readUint16();\n    const type = this.readUint16();\n    const numValues = this.readUint32();\n    if (type < 1 || type > 12) {\n      this.skip(4); // unknown type, skip this value\n      return;\n    }\n    const valueByteLength = getByteLength(type, numValues);\n    if (valueByteLength > 4) {\n      this.seek(this.readUint32());\n    }\n    const value = readData(this, type, numValues);\n    ifd.fields.set(tag, value);\n    // Read sub-IFDs\n    if (tag === 0x8769 || tag === 0x8825) {\n      let currentOffset = this.offset;\n      let kind = 'exif';\n      if (tag === 0x8769) {\n        kind = 'exif';\n      } else if (tag === 0x8825) {\n        kind = 'gps';\n      }\n      this._nextIFD = value;\n      ifd[kind] = this.decodeIFD({\n        kind,\n        ignoreImageData: true\n      }, false);\n      this.offset = currentOffset;\n    }\n    // go to the next entry\n    this.seek(offset);\n    this.skip(12);\n  }\n  decodeImageData(ifd) {\n    const orientation = ifd.orientation;\n    if (orientation && orientation !== 1) {\n      throw unsupported('orientation', orientation);\n    }\n    switch (ifd.type) {\n      case 0: // WhiteIsZero\n      case 1: // BlackIsZero\n      case 2: // RGB\n      case 3:\n        // Palette color\n        this.readStripData(ifd);\n        break;\n      default:\n        throw unsupported('image type', ifd.type);\n    }\n    this.applyPredictor(ifd);\n    this.convertAlpha(ifd);\n    if (ifd.type === 0) {\n      // WhiteIsZero: we invert the values\n      const bitDepth = ifd.bitsPerSample;\n      const maxValue = Math.pow(2, bitDepth) - 1;\n      for (let i = 0; i < ifd.data.length; i++) {\n        ifd.data[i] = maxValue - ifd.data[i];\n      }\n    }\n  }\n  readStripData(ifd) {\n    const width = ifd.width;\n    const height = ifd.height;\n    const bitDepth = ifd.bitsPerSample;\n    const sampleFormat = ifd.sampleFormat;\n    const size = width * height * ifd.samplesPerPixel;\n    const data = getDataArray(size, bitDepth, sampleFormat);\n    const rowsPerStrip = ifd.rowsPerStrip;\n    const maxPixels = rowsPerStrip * width * ifd.samplesPerPixel;\n    const stripOffsets = ifd.stripOffsets;\n    const stripByteCounts = ifd.stripByteCounts || guessStripByteCounts(ifd);\n    let remainingPixels = size;\n    let pixel = 0;\n    for (let i = 0; i < stripOffsets.length; i++) {\n      let stripData = new DataView(this.buffer, this.byteOffset + stripOffsets[i], stripByteCounts[i]);\n      // Last strip can be smaller\n      let length = remainingPixels > maxPixels ? maxPixels : remainingPixels;\n      remainingPixels -= length;\n      let dataToFill = stripData;\n      switch (ifd.compression) {\n        case 1:\n          {\n            // No compression, nothing to do\n            break;\n          }\n        case 5:\n          {\n            // LZW compression\n            dataToFill = decompressLzw(stripData);\n            break;\n          }\n        case 8:\n          {\n            // Zlib compression\n            dataToFill = decompressZlib(stripData);\n            break;\n          }\n        case 2:\n          // CCITT Group 3 1-Dimensional Modified Huffman run length encoding\n          throw unsupported('Compression', 'CCITT Group 3');\n        case 32773:\n          // PackBits compression\n          throw unsupported('Compression', 'PackBits');\n        default:\n          throw unsupported('Compression', ifd.compression);\n      }\n      pixel = this.fillUncompressed(bitDepth, sampleFormat, data, dataToFill, pixel, length);\n    }\n    ifd.data = data;\n  }\n  fillUncompressed(bitDepth, sampleFormat, data, stripData, pixel, length) {\n    if (bitDepth === 8) {\n      return fill8bit(data, stripData, pixel, length);\n    } else if (bitDepth === 16) {\n      return fill16bit(data, stripData, pixel, length, this.isLittleEndian());\n    } else if (bitDepth === 32 && sampleFormat === 3) {\n      return fillFloat32(data, stripData, pixel, length, this.isLittleEndian());\n    } else {\n      throw unsupported('bitDepth', bitDepth);\n    }\n  }\n  applyPredictor(ifd) {\n    const bitDepth = ifd.bitsPerSample;\n    switch (ifd.predictor) {\n      case 1:\n        {\n          // No prediction scheme, nothing to do\n          break;\n        }\n      case 2:\n        {\n          if (bitDepth === 8) {\n            applyHorizontalDifferencing8Bit(ifd.data, ifd.width, ifd.components);\n          } else if (bitDepth === 16) {\n            applyHorizontalDifferencing16Bit(ifd.data, ifd.width, ifd.components);\n          } else {\n            throw new Error(`Horizontal differencing is only supported for images with a bit depth of ${bitDepth}`);\n          }\n          break;\n        }\n      default:\n        throw new Error(`invalid predictor: ${ifd.predictor}`);\n    }\n  }\n  convertAlpha(ifd) {\n    if (ifd.alpha && ifd.associatedAlpha) {\n      const {\n        data,\n        components,\n        maxSampleValue\n      } = ifd;\n      for (let i = 0; i < data.length; i += components) {\n        const alphaValue = data[i + components - 1];\n        for (let j = 0; j < components - 1; j++) {\n          data[i + j] = Math.round(data[i + j] * maxSampleValue / alphaValue);\n        }\n      }\n    }\n  }\n}\nfunction getDataArray(size, bitDepth, sampleFormat) {\n  if (bitDepth === 8) {\n    return new Uint8Array(size);\n  } else if (bitDepth === 16) {\n    return new Uint16Array(size);\n  } else if (bitDepth === 32 && sampleFormat === 3) {\n    return new Float32Array(size);\n  } else {\n    throw unsupported('bit depth / sample format', `${bitDepth} / ${sampleFormat}`);\n  }\n}\nfunction fill8bit(dataTo, dataFrom, index, length) {\n  for (let i = 0; i < length; i++) {\n    dataTo[index++] = dataFrom.getUint8(i);\n  }\n  return index;\n}\nfunction fill16bit(dataTo, dataFrom, index, length, littleEndian) {\n  for (let i = 0; i < length * 2; i += 2) {\n    dataTo[index++] = dataFrom.getUint16(i, littleEndian);\n  }\n  return index;\n}\nfunction fillFloat32(dataTo, dataFrom, index, length, littleEndian) {\n  for (let i = 0; i < length * 4; i += 4) {\n    dataTo[index++] = dataFrom.getFloat32(i, littleEndian);\n  }\n  return index;\n}\nfunction unsupported(type, value) {\n  return new Error(`Unsupported ${type}: ${value}`);\n}","map":{"version":3,"names":["IOBuffer","guessStripByteCounts","applyHorizontalDifferencing8Bit","applyHorizontalDifferencing16Bit","IFD","getByteLength","readData","decompressLzw","TiffIfd","decompressZlib","defaultOptions","ignoreImageData","onlyFirst","TIFFDecoder","constructor","data","_nextIFD","isMultiPage","c","decodeHeader","decodeIFD","unsupported","pageCount","decode","options","Object","assign","result","push","value","readUint16","setLittleEndian","setBigEndian","Error","toString","readUint32","tiff","seek","ifd","kind","numEntries","i","decodeIFDEntry","decodeImageData","offset","tag","type","numValues","skip","valueByteLength","fields","set","currentOffset","orientation","readStripData","applyPredictor","convertAlpha","bitDepth","bitsPerSample","maxValue","Math","pow","length","width","height","sampleFormat","size","samplesPerPixel","getDataArray","rowsPerStrip","maxPixels","stripOffsets","stripByteCounts","remainingPixels","pixel","stripData","DataView","buffer","byteOffset","dataToFill","compression","fillUncompressed","fill8bit","fill16bit","isLittleEndian","fillFloat32","predictor","components","alpha","associatedAlpha","maxSampleValue","alphaValue","j","round","Uint8Array","Uint16Array","Float32Array","dataTo","dataFrom","index","getUint8","littleEndian","getUint16","getFloat32"],"sources":["C:\\Users\\Admin\\Documents\\Workspace\\opencv\\opencv\\node_modules\\tiff\\src\\tiffDecoder.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\n\nimport { guessStripByteCounts } from './hacks';\nimport {\n  applyHorizontalDifferencing8Bit,\n  applyHorizontalDifferencing16Bit,\n} from './horizontalDifferencing';\nimport IFD from './ifd';\nimport { getByteLength, readData } from './ifdValue';\nimport { decompressLzw } from './lzw';\nimport TiffIfd from './tiffIfd';\nimport { BufferType, IDecodeOptions, IFDKind, DataArray } from './types';\nimport { decompressZlib } from './zlib';\n\nconst defaultOptions: IDecodeOptions = {\n  ignoreImageData: false,\n  onlyFirst: false,\n};\n\ninterface IInternalOptions extends IDecodeOptions {\n  kind?: IFDKind;\n}\n\nexport default class TIFFDecoder extends IOBuffer {\n  private _nextIFD: number;\n\n  public constructor(data: BufferType) {\n    super(data);\n    this._nextIFD = 0;\n  }\n\n  public get isMultiPage(): boolean {\n    let c = 0;\n    this.decodeHeader();\n    while (this._nextIFD) {\n      c++;\n      this.decodeIFD({ ignoreImageData: true }, true);\n      if (c === 2) {\n        return true;\n      }\n    }\n    if (c === 1) {\n      return false;\n    }\n    throw unsupported('ifdCount', c);\n  }\n\n  public get pageCount(): number {\n    let c = 0;\n    this.decodeHeader();\n    while (this._nextIFD) {\n      c++;\n      this.decodeIFD({ ignoreImageData: true }, true);\n    }\n    if (c > 0) {\n      return c;\n    }\n    throw unsupported('ifdCount', c);\n  }\n\n  public decode(options: IDecodeOptions = {}): TiffIfd[] {\n    options = Object.assign({}, defaultOptions, options);\n    const result = [];\n    this.decodeHeader();\n    while (this._nextIFD) {\n      result.push(this.decodeIFD(options, true));\n      if (options.onlyFirst) {\n        return [result[0]];\n      }\n    }\n    return result;\n  }\n\n  private decodeHeader(): void {\n    // Byte offset\n    const value = this.readUint16();\n    if (value === 0x4949) {\n      this.setLittleEndian();\n    } else if (value === 0x4d4d) {\n      this.setBigEndian();\n    } else {\n      throw new Error(`invalid byte order: 0x${value.toString(16)}`);\n    }\n\n    // Magic number\n    if (this.readUint16() !== 42) {\n      throw new Error('not a TIFF file');\n    }\n\n    // Offset of the first IFD\n    this._nextIFD = this.readUint32();\n  }\n\n  private decodeIFD(options: IInternalOptions, tiff: true): TiffIfd;\n  private decodeIFD(options: IInternalOptions, tiff: false): IFD;\n  private decodeIFD(options: IInternalOptions, tiff: boolean): TiffIfd | IFD {\n    this.seek(this._nextIFD);\n\n    let ifd: TiffIfd | IFD;\n    if (tiff) {\n      ifd = new TiffIfd();\n    } else {\n      if (!options.kind) {\n        throw new Error(`kind is missing`);\n      }\n      ifd = new IFD(options.kind);\n    }\n\n    const numEntries = this.readUint16();\n    for (let i = 0; i < numEntries; i++) {\n      this.decodeIFDEntry(ifd);\n    }\n    if (!options.ignoreImageData) {\n      if (!(ifd instanceof TiffIfd)) {\n        throw new Error('must be a tiff ifd');\n      }\n      this.decodeImageData(ifd);\n    }\n    this._nextIFD = this.readUint32();\n    return ifd;\n  }\n\n  private decodeIFDEntry(ifd: IFD): void {\n    const offset = this.offset;\n    const tag = this.readUint16();\n    const type = this.readUint16();\n    const numValues = this.readUint32();\n\n    if (type < 1 || type > 12) {\n      this.skip(4); // unknown type, skip this value\n      return;\n    }\n\n    const valueByteLength = getByteLength(type, numValues);\n    if (valueByteLength > 4) {\n      this.seek(this.readUint32());\n    }\n\n    const value = readData(this, type, numValues);\n    ifd.fields.set(tag, value);\n\n    // Read sub-IFDs\n    if (tag === 0x8769 || tag === 0x8825) {\n      let currentOffset = this.offset;\n      let kind: IFDKind = 'exif';\n      if (tag === 0x8769) {\n        kind = 'exif';\n      } else if (tag === 0x8825) {\n        kind = 'gps';\n      }\n      this._nextIFD = value;\n      ifd[kind] = this.decodeIFD(\n        {\n          kind,\n          ignoreImageData: true,\n        },\n        false,\n      );\n      this.offset = currentOffset;\n    }\n\n    // go to the next entry\n    this.seek(offset);\n    this.skip(12);\n  }\n\n  private decodeImageData(ifd: TiffIfd): void {\n    const orientation = ifd.orientation;\n    if (orientation && orientation !== 1) {\n      throw unsupported('orientation', orientation);\n    }\n    switch (ifd.type) {\n      case 0: // WhiteIsZero\n      case 1: // BlackIsZero\n      case 2: // RGB\n      case 3: // Palette color\n        this.readStripData(ifd);\n        break;\n      default:\n        throw unsupported('image type', ifd.type);\n    }\n    this.applyPredictor(ifd);\n    this.convertAlpha(ifd);\n    if (ifd.type === 0) {\n      // WhiteIsZero: we invert the values\n      const bitDepth = ifd.bitsPerSample;\n      const maxValue = Math.pow(2, bitDepth) - 1;\n      for (let i = 0; i < ifd.data.length; i++) {\n        ifd.data[i] = maxValue - ifd.data[i];\n      }\n    }\n  }\n\n  private readStripData(ifd: TiffIfd): void {\n    const width = ifd.width;\n    const height = ifd.height;\n\n    const bitDepth = ifd.bitsPerSample;\n    const sampleFormat = ifd.sampleFormat;\n    const size = width * height * ifd.samplesPerPixel;\n    const data = getDataArray(size, bitDepth, sampleFormat);\n\n    const rowsPerStrip = ifd.rowsPerStrip;\n    const maxPixels = rowsPerStrip * width * ifd.samplesPerPixel;\n    const stripOffsets = ifd.stripOffsets;\n    const stripByteCounts = ifd.stripByteCounts || guessStripByteCounts(ifd);\n\n    let remainingPixels = size;\n    let pixel = 0;\n    for (let i = 0; i < stripOffsets.length; i++) {\n      let stripData = new DataView(\n        this.buffer,\n        this.byteOffset + stripOffsets[i],\n        stripByteCounts[i],\n      );\n\n      // Last strip can be smaller\n      let length = remainingPixels > maxPixels ? maxPixels : remainingPixels;\n      remainingPixels -= length;\n\n      let dataToFill = stripData;\n\n      switch (ifd.compression) {\n        case 1: {\n          // No compression, nothing to do\n          break;\n        }\n        case 5: {\n          // LZW compression\n          dataToFill = decompressLzw(stripData);\n          break;\n        }\n        case 8: {\n          // Zlib compression\n          dataToFill = decompressZlib(stripData);\n          break;\n        }\n        case 2: // CCITT Group 3 1-Dimensional Modified Huffman run length encoding\n          throw unsupported('Compression', 'CCITT Group 3');\n        case 32773: // PackBits compression\n          throw unsupported('Compression', 'PackBits');\n        default:\n          throw unsupported('Compression', ifd.compression);\n      }\n\n      pixel = this.fillUncompressed(\n        bitDepth,\n        sampleFormat,\n        data,\n        dataToFill,\n        pixel,\n        length,\n      );\n    }\n\n    ifd.data = data;\n  }\n\n  private fillUncompressed(\n    bitDepth: number,\n    sampleFormat: number,\n    data: DataArray,\n    stripData: DataView,\n    pixel: number,\n    length: number,\n  ): number {\n    if (bitDepth === 8) {\n      return fill8bit(data, stripData, pixel, length);\n    } else if (bitDepth === 16) {\n      return fill16bit(data, stripData, pixel, length, this.isLittleEndian());\n    } else if (bitDepth === 32 && sampleFormat === 3) {\n      return fillFloat32(data, stripData, pixel, length, this.isLittleEndian());\n    } else {\n      throw unsupported('bitDepth', bitDepth);\n    }\n  }\n\n  private applyPredictor(ifd: TiffIfd): void {\n    const bitDepth = ifd.bitsPerSample;\n    switch (ifd.predictor) {\n      case 1: {\n        // No prediction scheme, nothing to do\n        break;\n      }\n      case 2: {\n        if (bitDepth === 8) {\n          applyHorizontalDifferencing8Bit(\n            ifd.data as Uint8Array,\n            ifd.width,\n            ifd.components,\n          );\n        } else if (bitDepth === 16) {\n          applyHorizontalDifferencing16Bit(\n            ifd.data as Uint16Array,\n            ifd.width,\n            ifd.components,\n          );\n        } else {\n          throw new Error(\n            `Horizontal differencing is only supported for images with a bit depth of ${bitDepth}`,\n          );\n        }\n        break;\n      }\n      default:\n        throw new Error(`invalid predictor: ${ifd.predictor}`);\n    }\n  }\n\n  private convertAlpha(ifd: TiffIfd): void {\n    if (ifd.alpha && ifd.associatedAlpha) {\n      const { data, components, maxSampleValue } = ifd;\n      for (let i = 0; i < data.length; i += components) {\n        const alphaValue = data[i + components - 1];\n        for (let j = 0; j < components - 1; j++) {\n          data[i + j] = Math.round((data[i + j] * maxSampleValue) / alphaValue);\n        }\n      }\n    }\n  }\n}\n\nfunction getDataArray(\n  size: number,\n  bitDepth: number,\n  sampleFormat: number,\n): DataArray {\n  if (bitDepth === 8) {\n    return new Uint8Array(size);\n  } else if (bitDepth === 16) {\n    return new Uint16Array(size);\n  } else if (bitDepth === 32 && sampleFormat === 3) {\n    return new Float32Array(size);\n  } else {\n    throw unsupported(\n      'bit depth / sample format',\n      `${bitDepth} / ${sampleFormat}`,\n    );\n  }\n}\n\nfunction fill8bit(\n  dataTo: DataArray,\n  dataFrom: DataView,\n  index: number,\n  length: number,\n): number {\n  for (let i = 0; i < length; i++) {\n    dataTo[index++] = dataFrom.getUint8(i);\n  }\n  return index;\n}\n\nfunction fill16bit(\n  dataTo: DataArray,\n  dataFrom: DataView,\n  index: number,\n  length: number,\n  littleEndian: boolean,\n): number {\n  for (let i = 0; i < length * 2; i += 2) {\n    dataTo[index++] = dataFrom.getUint16(i, littleEndian);\n  }\n  return index;\n}\n\nfunction fillFloat32(\n  dataTo: DataArray,\n  dataFrom: DataView,\n  index: number,\n  length: number,\n  littleEndian: boolean,\n): number {\n  for (let i = 0; i < length * 4; i += 4) {\n    dataTo[index++] = dataFrom.getFloat32(i, littleEndian);\n  }\n  return index;\n}\n\nfunction unsupported(type: string, value: any): Error {\n  return new Error(`Unsupported ${type}: ${value}`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}