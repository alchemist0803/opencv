{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// J. M. S. Prewitt and M. L. Mendelsohn, \"The analysis of cell images,\" in\n// Annals of the New York Academy of Sciences, vol. 128, pp. 1035-1053, 1966.\n// ported to ImageJ plugin by G.Landini from Antti Niemisto's Matlab code (GPL)\n// Original Matlab code Copyright (C) 2004 Antti Niemisto\n// See http://www.cs.tut.fi/~ant/histthresh/ for an excellent slide presentation\n// and the original Matlab code\nexport default function minimum(histogram) {\n  if (histogram.length < 2) {\n    // validate that the histogram has at least two color values\n    return 0;\n  }\n  let iterations = 0; // number of iterations of the smoothing process\n  let threshold = -1;\n  let max = -1; // maximum color value with a greater number of pixels to 0\n  let histogramCopy = new Array(histogram.length); // a copy of the histogram\n  for (let i = 0; i < histogram.length; i++) {\n    histogramCopy[i] = histogram[i];\n    if (histogram[i] > 0) {\n      max = i;\n    }\n  }\n  while (!bimodalTest(histogramCopy)) {\n    histogramCopy = smoothed(histogramCopy);\n    iterations++;\n    if (iterations > 10000) {\n      // if they occur more than 10000 iterations it returns -1\n      return threshold;\n    }\n  }\n  threshold = minimumBetweenPeeks(histogramCopy, max);\n  return threshold;\n}\nfunction smoothed(histogram) {\n  // Smooth with a 3 point running mean filter\n  let auHistogram = new Array(histogram.length); // a copy of the histograma for the smoothing process\n  for (let i = 1; i < histogram.length - 1; i++) {\n    auHistogram[i] = (histogram[i - 1] + histogram[i] + histogram[i + 1]) / 3;\n  }\n  auHistogram[0] = (histogram[0] + histogram[1]) / 3;\n  auHistogram[histogram.length - 1] = (histogram[histogram.length - 2] + histogram[histogram.length - 1]) / 3;\n  return auHistogram;\n}\nfunction minimumBetweenPeeks(histogramBimodal, max) {\n  let threshold;\n  for (let i = 1; i < max; i++) {\n    if (histogramBimodal[i - 1] > histogramBimodal[i] && histogramBimodal[i + 1] >= histogramBimodal[i]) {\n      threshold = i;\n      break;\n    }\n  }\n  return threshold;\n}\nfunction bimodalTest(histogram) {\n  // It is responsible for determining if a histogram is bimodal\n  let len = histogram.length;\n  let isBimodal = false;\n  let peaks = 0;\n  for (let k = 1; k < len - 1; k++) {\n    if (histogram[k - 1] < histogram[k] && histogram[k + 1] < histogram[k]) {\n      peaks++;\n      if (peaks > 2) {\n        return false;\n      }\n    }\n  }\n  if (peaks === 2) {\n    isBimodal = true;\n  }\n  return isBimodal;\n}","map":{"version":3,"names":["minimum","histogram","length","iterations","threshold","max","histogramCopy","Array","i","bimodalTest","smoothed","minimumBetweenPeeks","auHistogram","histogramBimodal","len","isBimodal","peaks","k"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/minimum.js"],"sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// J. M. S. Prewitt and M. L. Mendelsohn, \"The analysis of cell images,\" in\n// Annals of the New York Academy of Sciences, vol. 128, pp. 1035-1053, 1966.\n// ported to ImageJ plugin by G.Landini from Antti Niemisto's Matlab code (GPL)\n// Original Matlab code Copyright (C) 2004 Antti Niemisto\n// See http://www.cs.tut.fi/~ant/histthresh/ for an excellent slide presentation\n// and the original Matlab code\nexport default function minimum(histogram) {\n  if (histogram.length < 2) {\n    // validate that the histogram has at least two color values\n    return 0;\n  }\n  let iterations = 0; // number of iterations of the smoothing process\n  let threshold = -1;\n  let max = -1; // maximum color value with a greater number of pixels to 0\n  let histogramCopy = new Array(histogram.length); // a copy of the histogram\n  for (let i = 0; i < histogram.length; i++) {\n    histogramCopy[i] = histogram[i];\n    if (histogram[i] > 0) {\n      max = i;\n    }\n  }\n  while (!bimodalTest(histogramCopy)) {\n    histogramCopy = smoothed(histogramCopy);\n    iterations++;\n    if (iterations > 10000) {\n      // if they occur more than 10000 iterations it returns -1\n      return threshold;\n    }\n  }\n  threshold = minimumBetweenPeeks(histogramCopy, max);\n  return threshold;\n}\n\nfunction smoothed(histogram) {\n  // Smooth with a 3 point running mean filter\n  let auHistogram = new Array(histogram.length); // a copy of the histograma for the smoothing process\n  for (let i = 1; i < histogram.length - 1; i++) {\n    auHistogram[i] = (histogram[i - 1] + histogram[i] + histogram[i + 1]) / 3;\n  }\n  auHistogram[0] = (histogram[0] + histogram[1]) / 3;\n  auHistogram[histogram.length - 1] =\n    (histogram[histogram.length - 2] + histogram[histogram.length - 1]) / 3;\n  return auHistogram;\n}\n\nfunction minimumBetweenPeeks(histogramBimodal, max) {\n  let threshold;\n  for (let i = 1; i < max; i++) {\n    if (\n      histogramBimodal[i - 1] > histogramBimodal[i] &&\n      histogramBimodal[i + 1] >= histogramBimodal[i]\n    ) {\n      threshold = i;\n      break;\n    }\n  }\n  return threshold;\n}\n\nfunction bimodalTest(histogram) {\n  // It is responsible for determining if a histogram is bimodal\n  let len = histogram.length;\n  let isBimodal = false;\n  let peaks = 0;\n  for (let k = 1; k < len - 1; k++) {\n    if (histogram[k - 1] < histogram[k] && histogram[k + 1] < histogram[k]) {\n      peaks++;\n      if (peaks > 2) {\n        return false;\n      }\n    }\n  }\n  if (peaks === 2) {\n    isBimodal = true;\n  }\n  return isBimodal;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}