{"ast":null,"code":"/*\nThis algorithm is nice and is therefore kept here\nHowever it seems to be slower than the get mask and\nalso provides only the positive ROI\nWe therefore don't expose it in the roiManager\n */\n\nimport DisjointSet from 'ml-disjoint-set';\nimport RoiMap from '../RoiMap';\nconst direction4X = [-1, 0];\nconst direction4Y = [0, -1];\nconst neighbours4 = [null, null];\nconst direction8X = [-1, -1, 0, 1];\nconst direction8Y = [0, -1, -1, -1];\nconst neighbours8 = [null, null, null, null];\n\n/*\nImplementation of the connected-component labeling algorithm\n */\nexport default function fromMaskConnectedComponentLabelingAlgorithm(mask, options = {}) {\n  const {\n    allowCorners = false\n  } = options;\n  let neighbours = 4;\n  if (allowCorners) {\n    neighbours = 8;\n  }\n  let directionX;\n  let directionY;\n  let neighboursList;\n  if (neighbours === 8) {\n    directionX = direction8X;\n    directionY = direction8Y;\n    neighboursList = neighbours8;\n  } else if (neighbours === 4) {\n    directionX = direction4X;\n    directionY = direction4Y;\n    neighboursList = neighbours4;\n  } else {\n    throw new RangeError(`unsupported neighbours count: ${neighbours}`);\n  }\n  const size = mask.size;\n  const width = mask.width;\n  const height = mask.height;\n  const labels = new Array(size);\n  const data = new Uint32Array(size);\n  const linked = new DisjointSet();\n  let currentLabel = 1;\n  for (let j = 0; j < height; j++) {\n    for (let i = 0; i < width; i++) {\n      // true means out of background\n      const index = i + j * width;\n      if (mask.getBit(index)) {\n        let smallestNeighbour = null;\n        for (let k = 0; k < neighboursList.length; k++) {\n          const ii = i + directionX[k];\n          const jj = j + directionY[k];\n          if (ii >= 0 && jj >= 0 && ii < width && jj < height) {\n            const index = ii + jj * width;\n            let neighbour = labels[index];\n            if (!neighbour) {\n              neighboursList[k] = null;\n            } else {\n              neighboursList[k] = neighbour;\n              if (!smallestNeighbour || neighboursList[k].value < smallestNeighbour.value) {\n                smallestNeighbour = neighboursList[k];\n              }\n            }\n          }\n        }\n        if (!smallestNeighbour) {\n          labels[index] = linked.add(currentLabel++);\n        } else {\n          labels[index] = smallestNeighbour;\n          for (let k = 0; k < neighboursList.length; k++) {\n            if (neighboursList[k] && neighboursList[k] !== smallestNeighbour) {\n              linked.union(smallestNeighbour, neighboursList[k]);\n            }\n          }\n        }\n      }\n    }\n  }\n  for (let j = 0; j < height; j++) {\n    for (let i = 0; i < width; i++) {\n      const index = i + j * width;\n      if (mask.getBit(index)) {\n        data[index] = linked.find(labels[index]).value;\n      }\n    }\n  }\n  return new RoiMap(mask, data);\n}","map":{"version":3,"names":["DisjointSet","RoiMap","direction4X","direction4Y","neighbours4","direction8X","direction8Y","neighbours8","fromMaskConnectedComponentLabelingAlgorithm","mask","options","allowCorners","neighbours","directionX","directionY","neighboursList","RangeError","size","width","height","labels","Array","data","Uint32Array","linked","currentLabel","j","i","index","getBit","smallestNeighbour","k","length","ii","jj","neighbour","value","add","union","find"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/roi/creator/fromMaskConnectedComponentLabelingAlgorithm.js"],"sourcesContent":["/*\nThis algorithm is nice and is therefore kept here\nHowever it seems to be slower than the get mask and\nalso provides only the positive ROI\nWe therefore don't expose it in the roiManager\n */\n\nimport DisjointSet from 'ml-disjoint-set';\n\nimport RoiMap from '../RoiMap';\n\nconst direction4X = [-1, 0];\nconst direction4Y = [0, -1];\nconst neighbours4 = [null, null];\n\nconst direction8X = [-1, -1, 0, 1];\nconst direction8Y = [0, -1, -1, -1];\nconst neighbours8 = [null, null, null, null];\n\n/*\nImplementation of the connected-component labeling algorithm\n */\nexport default function fromMaskConnectedComponentLabelingAlgorithm(\n  mask,\n  options = {},\n) {\n  const { allowCorners = false } = options;\n  let neighbours = 4;\n  if (allowCorners) {\n    neighbours = 8;\n  }\n\n  let directionX;\n  let directionY;\n  let neighboursList;\n  if (neighbours === 8) {\n    directionX = direction8X;\n    directionY = direction8Y;\n    neighboursList = neighbours8;\n  } else if (neighbours === 4) {\n    directionX = direction4X;\n    directionY = direction4Y;\n    neighboursList = neighbours4;\n  } else {\n    throw new RangeError(`unsupported neighbours count: ${neighbours}`);\n  }\n\n  const size = mask.size;\n  const width = mask.width;\n  const height = mask.height;\n  const labels = new Array(size);\n  const data = new Uint32Array(size);\n  const linked = new DisjointSet();\n\n  let currentLabel = 1;\n  for (let j = 0; j < height; j++) {\n    for (let i = 0; i < width; i++) {\n      // true means out of background\n      const index = i + j * width;\n      if (mask.getBit(index)) {\n        let smallestNeighbour = null;\n        for (let k = 0; k < neighboursList.length; k++) {\n          const ii = i + directionX[k];\n          const jj = j + directionY[k];\n          if (ii >= 0 && jj >= 0 && ii < width && jj < height) {\n            const index = ii + jj * width;\n            let neighbour = labels[index];\n            if (!neighbour) {\n              neighboursList[k] = null;\n            } else {\n              neighboursList[k] = neighbour;\n              if (\n                !smallestNeighbour ||\n                neighboursList[k].value < smallestNeighbour.value\n              ) {\n                smallestNeighbour = neighboursList[k];\n              }\n            }\n          }\n        }\n        if (!smallestNeighbour) {\n          labels[index] = linked.add(currentLabel++);\n        } else {\n          labels[index] = smallestNeighbour;\n          for (let k = 0; k < neighboursList.length; k++) {\n            if (neighboursList[k] && neighboursList[k] !== smallestNeighbour) {\n              linked.union(smallestNeighbour, neighboursList[k]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  for (let j = 0; j < height; j++) {\n    for (let i = 0; i < width; i++) {\n      const index = i + j * width;\n      if (mask.getBit(index)) {\n        data[index] = linked.find(labels[index]).value;\n      }\n    }\n  }\n\n  return new RoiMap(mask, data);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,WAAW,MAAM,iBAAiB;AAEzC,OAAOC,MAAM,MAAM,WAAW;AAE9B,MAAMC,WAAW,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;AAC3B,MAAMC,WAAW,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC3B,MAAMC,WAAW,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;AAEhC,MAAMC,WAAW,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAClC,MAAMC,WAAW,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACnC,MAAMC,WAAW,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;;AAE5C;AACA;AACA;AACA,eAAe,SAASC,2CAA2CA,CACjEC,IAAI,EACJC,OAAO,GAAG,CAAC,CAAC,EACZ;EACA,MAAM;IAAEC,YAAY,GAAG;EAAM,CAAC,GAAGD,OAAO;EACxC,IAAIE,UAAU,GAAG,CAAC;EAClB,IAAID,YAAY,EAAE;IAChBC,UAAU,GAAG,CAAC;EAChB;EAEA,IAAIC,UAAU;EACd,IAAIC,UAAU;EACd,IAAIC,cAAc;EAClB,IAAIH,UAAU,KAAK,CAAC,EAAE;IACpBC,UAAU,GAAGR,WAAW;IACxBS,UAAU,GAAGR,WAAW;IACxBS,cAAc,GAAGR,WAAW;EAC9B,CAAC,MAAM,IAAIK,UAAU,KAAK,CAAC,EAAE;IAC3BC,UAAU,GAAGX,WAAW;IACxBY,UAAU,GAAGX,WAAW;IACxBY,cAAc,GAAGX,WAAW;EAC9B,CAAC,MAAM;IACL,MAAM,IAAIY,UAAU,CAAC,iCAAiCJ,UAAU,EAAE,CAAC;EACrE;EAEA,MAAMK,IAAI,GAAGR,IAAI,CAACQ,IAAI;EACtB,MAAMC,KAAK,GAAGT,IAAI,CAACS,KAAK;EACxB,MAAMC,MAAM,GAAGV,IAAI,CAACU,MAAM;EAC1B,MAAMC,MAAM,GAAG,IAAIC,KAAK,CAACJ,IAAI,CAAC;EAC9B,MAAMK,IAAI,GAAG,IAAIC,WAAW,CAACN,IAAI,CAAC;EAClC,MAAMO,MAAM,GAAG,IAAIxB,WAAW,CAAC,CAAC;EAEhC,IAAIyB,YAAY,GAAG,CAAC;EACpB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,MAAM,EAAEO,CAAC,EAAE,EAAE;IAC/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,KAAK,EAAES,CAAC,EAAE,EAAE;MAC9B;MACA,MAAMC,KAAK,GAAGD,CAAC,GAAGD,CAAC,GAAGR,KAAK;MAC3B,IAAIT,IAAI,CAACoB,MAAM,CAACD,KAAK,CAAC,EAAE;QACtB,IAAIE,iBAAiB,GAAG,IAAI;QAC5B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,cAAc,CAACiB,MAAM,EAAED,CAAC,EAAE,EAAE;UAC9C,MAAME,EAAE,GAAGN,CAAC,GAAGd,UAAU,CAACkB,CAAC,CAAC;UAC5B,MAAMG,EAAE,GAAGR,CAAC,GAAGZ,UAAU,CAACiB,CAAC,CAAC;UAC5B,IAAIE,EAAE,IAAI,CAAC,IAAIC,EAAE,IAAI,CAAC,IAAID,EAAE,GAAGf,KAAK,IAAIgB,EAAE,GAAGf,MAAM,EAAE;YACnD,MAAMS,KAAK,GAAGK,EAAE,GAAGC,EAAE,GAAGhB,KAAK;YAC7B,IAAIiB,SAAS,GAAGf,MAAM,CAACQ,KAAK,CAAC;YAC7B,IAAI,CAACO,SAAS,EAAE;cACdpB,cAAc,CAACgB,CAAC,CAAC,GAAG,IAAI;YAC1B,CAAC,MAAM;cACLhB,cAAc,CAACgB,CAAC,CAAC,GAAGI,SAAS;cAC7B,IACE,CAACL,iBAAiB,IAClBf,cAAc,CAACgB,CAAC,CAAC,CAACK,KAAK,GAAGN,iBAAiB,CAACM,KAAK,EACjD;gBACAN,iBAAiB,GAAGf,cAAc,CAACgB,CAAC,CAAC;cACvC;YACF;UACF;QACF;QACA,IAAI,CAACD,iBAAiB,EAAE;UACtBV,MAAM,CAACQ,KAAK,CAAC,GAAGJ,MAAM,CAACa,GAAG,CAACZ,YAAY,EAAE,CAAC;QAC5C,CAAC,MAAM;UACLL,MAAM,CAACQ,KAAK,CAAC,GAAGE,iBAAiB;UACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,cAAc,CAACiB,MAAM,EAAED,CAAC,EAAE,EAAE;YAC9C,IAAIhB,cAAc,CAACgB,CAAC,CAAC,IAAIhB,cAAc,CAACgB,CAAC,CAAC,KAAKD,iBAAiB,EAAE;cAChEN,MAAM,CAACc,KAAK,CAACR,iBAAiB,EAAEf,cAAc,CAACgB,CAAC,CAAC,CAAC;YACpD;UACF;QACF;MACF;IACF;EACF;EAEA,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,MAAM,EAAEO,CAAC,EAAE,EAAE;IAC/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,KAAK,EAAES,CAAC,EAAE,EAAE;MAC9B,MAAMC,KAAK,GAAGD,CAAC,GAAGD,CAAC,GAAGR,KAAK;MAC3B,IAAIT,IAAI,CAACoB,MAAM,CAACD,KAAK,CAAC,EAAE;QACtBN,IAAI,CAACM,KAAK,CAAC,GAAGJ,MAAM,CAACe,IAAI,CAACnB,MAAM,CAACQ,KAAK,CAAC,CAAC,CAACQ,KAAK;MAChD;IACF;EACF;EAEA,OAAO,IAAInC,MAAM,CAACQ,IAAI,EAAEa,IAAI,CAAC;AAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}