{"ast":null,"code":"import newArray from 'new-array';\nimport { validateArrayOfChannels } from '../../util/channel';\n\n/**\n * Try to match the current pictures with another one. If normalize we normalize separately the 2 images.\n * @memberof Image\n * @instance\n * @param {Image} image - Other image\n * @param {object} [options]\n * @return {number[]|number}\n */\nexport default function getSimilarity(image, options = {}) {\n  let {\n    shift = [0, 0],\n    average,\n    channels,\n    defaultAlpha,\n    normalize,\n    border = [0, 0]\n  } = options;\n  this.checkProcessable('getSimilarity', {\n    bitDepth: [8, 16]\n  });\n  if (!Array.isArray(border)) {\n    border = [border, border];\n  }\n  channels = validateArrayOfChannels(this, {\n    channels: channels,\n    defaultAlpha: defaultAlpha\n  });\n  if (this.bitDepth !== image.bitDepth) {\n    throw new Error('Both images must have the same bitDepth');\n  }\n  if (this.channels !== image.channels) {\n    throw new Error('Both images must have the same number of channels');\n  }\n  if (this.colorModel !== image.colorModel) {\n    throw new Error('Both images must have the same colorModel');\n  }\n  if (typeof average === 'undefined') {\n    average = true;\n  }\n\n  // we allow a shift\n  // we need to find the minX, maxX, minY, maxY\n  let minX = Math.max(border[0], -shift[0]);\n  let maxX = Math.min(this.width - border[0], this.width - shift[0]);\n  let minY = Math.max(border[1], -shift[1]);\n  let maxY = Math.min(this.height - border[1], this.height - shift[1]);\n  let results = newArray(channels.length, 0);\n  for (let i = 0; i < channels.length; i++) {\n    let c = channels[i];\n    let sumThis = normalize ? this.sum[c] : Math.max(this.sum[c], image.sum[c]);\n    let sumImage = normalize ? image.sum[c] : Math.max(this.sum[c], image.sum[c]);\n    if (sumThis !== 0 && sumImage !== 0) {\n      for (let x = minX; x < maxX; x++) {\n        for (let y = minY; y < maxY; y++) {\n          let indexThis = x * this.multiplierX + y * this.multiplierY + c;\n          let indexImage = indexThis + shift[0] * this.multiplierX + shift[1] * this.multiplierY;\n          results[i] += Math.min(this.data[indexThis] / sumThis, image.data[indexImage] / sumImage);\n        }\n      }\n    }\n  }\n  if (average) {\n    return results.reduce((sum, x) => sum + x) / results.length;\n  }\n  return results;\n}","map":{"version":3,"names":["newArray","validateArrayOfChannels","getSimilarity","image","options","shift","average","channels","defaultAlpha","normalize","border","checkProcessable","bitDepth","Array","isArray","Error","colorModel","minX","Math","max","maxX","min","width","minY","maxY","height","results","length","i","c","sumThis","sum","sumImage","x","y","indexThis","multiplierX","multiplierY","indexImage","data","reduce"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/utility/getSimilarity.js"],"sourcesContent":["import newArray from 'new-array';\n\nimport { validateArrayOfChannels } from '../../util/channel';\n\n/**\n * Try to match the current pictures with another one. If normalize we normalize separately the 2 images.\n * @memberof Image\n * @instance\n * @param {Image} image - Other image\n * @param {object} [options]\n * @return {number[]|number}\n */\nexport default function getSimilarity(image, options = {}) {\n  let {\n    shift = [0, 0],\n    average,\n    channels,\n    defaultAlpha,\n    normalize,\n    border = [0, 0],\n  } = options;\n\n  this.checkProcessable('getSimilarity', {\n    bitDepth: [8, 16],\n  });\n\n  if (!Array.isArray(border)) {\n    border = [border, border];\n  }\n  channels = validateArrayOfChannels(this, {\n    channels: channels,\n    defaultAlpha: defaultAlpha,\n  });\n\n  if (this.bitDepth !== image.bitDepth) {\n    throw new Error('Both images must have the same bitDepth');\n  }\n  if (this.channels !== image.channels) {\n    throw new Error('Both images must have the same number of channels');\n  }\n  if (this.colorModel !== image.colorModel) {\n    throw new Error('Both images must have the same colorModel');\n  }\n\n  if (typeof average === 'undefined') {\n    average = true;\n  }\n\n  // we allow a shift\n  // we need to find the minX, maxX, minY, maxY\n  let minX = Math.max(border[0], -shift[0]);\n  let maxX = Math.min(this.width - border[0], this.width - shift[0]);\n  let minY = Math.max(border[1], -shift[1]);\n  let maxY = Math.min(this.height - border[1], this.height - shift[1]);\n\n  let results = newArray(channels.length, 0);\n  for (let i = 0; i < channels.length; i++) {\n    let c = channels[i];\n    let sumThis = normalize ? this.sum[c] : Math.max(this.sum[c], image.sum[c]);\n    let sumImage = normalize\n      ? image.sum[c]\n      : Math.max(this.sum[c], image.sum[c]);\n\n    if (sumThis !== 0 && sumImage !== 0) {\n      for (let x = minX; x < maxX; x++) {\n        for (let y = minY; y < maxY; y++) {\n          let indexThis = x * this.multiplierX + y * this.multiplierY + c;\n          let indexImage =\n            indexThis +\n            shift[0] * this.multiplierX +\n            shift[1] * this.multiplierY;\n          results[i] += Math.min(\n            this.data[indexThis] / sumThis,\n            image.data[indexImage] / sumImage,\n          );\n        }\n      }\n    }\n  }\n\n  if (average) {\n    return results.reduce((sum, x) => sum + x) / results.length;\n  }\n  return results;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}