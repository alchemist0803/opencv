{"ast":null,"code":"import { rotate, difference, normalize } from '../../util/points';\nimport convexHullFunction from '../compute/monotoneChainConvexHull';\n\n/**\n * Computes the Feret diameters\n * https://www.sympatec.com/en/particle-measurement/glossary/particle-shape/#\n * http://portal.s2nano.org:8282/files/TEM_protocol_NANoREG.pdf\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.originalPoints]\n * @return {object} Object with {min, max, minLine: {Array<Array<number>>}, maxLine: {Array<Array<number>>}}\n */\nexport default function feretDiameters(options = {}) {\n  const {\n    originalPoints = convexHullFunction.call(this)\n  } = options;\n  if (originalPoints.length === 0) {\n    return {\n      min: 0,\n      max: 0,\n      minLine: [],\n      maxLine: [],\n      aspectRatio: 1\n    };\n  }\n  if (originalPoints.length === 1) {\n    return {\n      min: 1,\n      max: 1,\n      minLine: [originalPoints[0], originalPoints[0]],\n      maxLine: [originalPoints[0], originalPoints[0]],\n      aspectRatio: 1\n    };\n  }\n  const temporaryPoints = new Array(originalPoints.length);\n\n  // CALCULATE MIN VALUE\n  let minWidth = +Infinity;\n  let minWidthAngle = 0;\n  let minLine = [];\n  for (let i = 0; i < originalPoints.length; i++) {\n    let angle = getAngle(originalPoints[i], originalPoints[(i + 1) % originalPoints.length]);\n\n    // we rotate so that it is parallel to X axis\n    rotate(-angle, originalPoints, temporaryPoints);\n    let currentWidth = 0;\n    let currentMinLine = [];\n    for (let j = 0; j < originalPoints.length; j++) {\n      let absWidth = Math.abs(temporaryPoints[i][1] - temporaryPoints[j][1]);\n      if (absWidth > currentWidth) {\n        currentWidth = absWidth;\n        currentMinLine = [];\n        currentMinLine.push([temporaryPoints[j][0], temporaryPoints[i][1]], [temporaryPoints[j][0], temporaryPoints[j][1]]);\n      }\n    }\n    if (currentWidth < minWidth) {\n      minWidth = currentWidth;\n      minWidthAngle = angle;\n      minLine = currentMinLine;\n    }\n  }\n  rotate(minWidthAngle, minLine, minLine);\n\n  // CALCULATE MAX VALUE\n  let maxWidth = 0;\n  let maxLine = [];\n  let maxSquaredWidth = 0;\n  for (let i = 0; i < originalPoints.length - 1; i++) {\n    for (let j = i + 1; j < originalPoints.length; j++) {\n      let currentSquaredWidth = (originalPoints[i][0] - originalPoints[j][0]) ** 2 + (originalPoints[i][1] - originalPoints[j][1]) ** 2;\n      if (currentSquaredWidth > maxSquaredWidth) {\n        maxSquaredWidth = currentSquaredWidth;\n        maxWidth = Math.sqrt(currentSquaredWidth);\n        maxLine = [originalPoints[i], originalPoints[j]];\n      }\n    }\n  }\n  return {\n    min: minWidth,\n    minLine,\n    max: maxWidth,\n    maxLine,\n    aspectRatio: minWidth / maxWidth\n  };\n}\n\n// the angle that allows to make the line going through p1 and p2 horizontal\n// this is an optimized version because it assume one vector is horizontal\nfunction getAngle(p1, p2) {\n  let diff = difference(p2, p1);\n  let vector = normalize(diff);\n  let angle = Math.acos(vector[0]);\n  if (vector[1] < 0) return -angle;\n  return angle;\n}","map":{"version":3,"names":["rotate","difference","normalize","convexHullFunction","feretDiameters","options","originalPoints","call","length","min","max","minLine","maxLine","aspectRatio","temporaryPoints","Array","minWidth","Infinity","minWidthAngle","i","angle","getAngle","currentWidth","currentMinLine","j","absWidth","Math","abs","push","maxWidth","maxSquaredWidth","currentSquaredWidth","sqrt","p1","p2","diff","vector","acos"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/roi/feretDiameters.js"],"sourcesContent":["import { rotate, difference, normalize } from '../../util/points';\nimport convexHullFunction from '../compute/monotoneChainConvexHull';\n\n/**\n * Computes the Feret diameters\n * https://www.sympatec.com/en/particle-measurement/glossary/particle-shape/#\n * http://portal.s2nano.org:8282/files/TEM_protocol_NANoREG.pdf\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.originalPoints]\n * @return {object} Object with {min, max, minLine: {Array<Array<number>>}, maxLine: {Array<Array<number>>}}\n */\nexport default function feretDiameters(options = {}) {\n  const { originalPoints = convexHullFunction.call(this) } = options;\n  if (originalPoints.length === 0) {\n    return { min: 0, max: 0, minLine: [], maxLine: [], aspectRatio: 1 };\n  }\n\n  if (originalPoints.length === 1) {\n    return {\n      min: 1,\n      max: 1,\n      minLine: [originalPoints[0], originalPoints[0]],\n      maxLine: [originalPoints[0], originalPoints[0]],\n      aspectRatio: 1,\n    };\n  }\n\n  const temporaryPoints = new Array(originalPoints.length);\n\n  // CALCULATE MIN VALUE\n  let minWidth = +Infinity;\n  let minWidthAngle = 0;\n  let minLine = [];\n\n  for (let i = 0; i < originalPoints.length; i++) {\n    let angle = getAngle(\n      originalPoints[i],\n      originalPoints[(i + 1) % originalPoints.length],\n    );\n\n    // we rotate so that it is parallel to X axis\n    rotate(-angle, originalPoints, temporaryPoints);\n\n    let currentWidth = 0;\n    let currentMinLine = [];\n    for (let j = 0; j < originalPoints.length; j++) {\n      let absWidth = Math.abs(temporaryPoints[i][1] - temporaryPoints[j][1]);\n      if (absWidth > currentWidth) {\n        currentWidth = absWidth;\n        currentMinLine = [];\n        currentMinLine.push(\n          [temporaryPoints[j][0], temporaryPoints[i][1]],\n          [temporaryPoints[j][0], temporaryPoints[j][1]],\n        );\n      }\n    }\n    if (currentWidth < minWidth) {\n      minWidth = currentWidth;\n      minWidthAngle = angle;\n      minLine = currentMinLine;\n    }\n  }\n  rotate(minWidthAngle, minLine, minLine);\n\n  // CALCULATE MAX VALUE\n  let maxWidth = 0;\n  let maxLine = [];\n  let maxSquaredWidth = 0;\n  for (let i = 0; i < originalPoints.length - 1; i++) {\n    for (let j = i + 1; j < originalPoints.length; j++) {\n      let currentSquaredWidth =\n        (originalPoints[i][0] - originalPoints[j][0]) ** 2 +\n        (originalPoints[i][1] - originalPoints[j][1]) ** 2;\n      if (currentSquaredWidth > maxSquaredWidth) {\n        maxSquaredWidth = currentSquaredWidth;\n        maxWidth = Math.sqrt(currentSquaredWidth);\n        maxLine = [originalPoints[i], originalPoints[j]];\n      }\n    }\n  }\n\n  return {\n    min: minWidth,\n    minLine,\n    max: maxWidth,\n    maxLine,\n    aspectRatio: minWidth / maxWidth,\n  };\n}\n\n// the angle that allows to make the line going through p1 and p2 horizontal\n// this is an optimized version because it assume one vector is horizontal\nfunction getAngle(p1, p2) {\n  let diff = difference(p2, p1);\n  let vector = normalize(diff);\n  let angle = Math.acos(vector[0]);\n  if (vector[1] < 0) return -angle;\n  return angle;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}