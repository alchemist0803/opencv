{"ast":null,"code":"/**\n * Find intersection of points between two different masks\n * @memberof Image\n * @instance\n * @param {Image} mask2 - a mask (1 bit image)\n * @return {object} - object containing number of white pixels for mask1, for mask 2 and for them both\n */\nexport default function getIntersection(mask2) {\n  let mask1 = this;\n  let closestParent = mask1.getClosestCommonParent(mask2);\n  let startPos1 = mask1.getRelativePosition(closestParent, {\n    defaultFurther: true\n  });\n  let allRelPos1 = getRelativePositionForAllPixels(mask1, startPos1);\n  let startPos2 = mask2.getRelativePosition(closestParent, {\n    defaultFurther: true\n  });\n  let allRelPos2 = getRelativePositionForAllPixels(mask2, startPos2);\n  let commonSurface = getCommonSurface(allRelPos1, allRelPos2);\n  let intersection = {\n    whitePixelsMask1: [],\n    whitePixelsMask2: [],\n    commonWhitePixels: []\n  };\n  for (let i = 0; i < commonSurface.length; i++) {\n    let currentRelativePos = commonSurface[i];\n    let realPos1 = [currentRelativePos[0] - startPos1[0], currentRelativePos[1] - startPos1[1]];\n    let realPos2 = [currentRelativePos[0] - startPos2[0], currentRelativePos[1] - startPos2[1]];\n    let valueBitMask1 = mask1.getBitXY(realPos1[0], realPos1[1]);\n    let valueBitMask2 = mask2.getBitXY(realPos2[0], realPos2[1]);\n    if (valueBitMask1 === 1 && valueBitMask2 === 1) {\n      intersection.commonWhitePixels.push(currentRelativePos);\n    }\n  }\n  for (let i = 0; i < allRelPos1.length; i++) {\n    let posX;\n    let posY;\n    if (i !== 0) {\n      posX = Math.floor(i / mask1.width);\n      posY = i % mask1.width;\n    }\n    if (mask1.getBitXY(posX, posY) === 1) {\n      intersection.whitePixelsMask1.push(allRelPos1[i]);\n    }\n  }\n  for (let i = 0; i < allRelPos2.length; i++) {\n    let posX = 0;\n    let posY = 0;\n    if (i !== 0) {\n      posX = Math.floor(i / mask2.width);\n      posY = i % mask2.width;\n    }\n    if (mask2.getBitXY(posX, posY) === 1) {\n      intersection.whitePixelsMask2.push(allRelPos2[i]);\n    }\n  }\n  return intersection;\n}\n\n/**\n * Get relative position array for all pixels in masks\n * @param {Image} mask - a mask (1 bit image)\n * @param {Array<number>} startPosition - start position of mask relative to parent\n * @return {Array} - relative position of all pixels\n * @private\n */\nfunction getRelativePositionForAllPixels(mask, startPosition) {\n  let relativePositions = [];\n  for (let i = 0; i < mask.height; i++) {\n    for (let j = 0; j < mask.width; j++) {\n      let originalPos = [i, j];\n      relativePositions.push([originalPos[0] + startPosition[0], originalPos[1] + startPosition[1]]);\n    }\n  }\n  return relativePositions;\n}\n\n/**\n * Finds common surface for two arrays containing the positions of the pixels relative to parent image\n * @param {Array<number>} positionArray1 - positions of pixels relative to parent\n * @param {Array<number>} positionArray2 - positions of pixels relative to parent\n * @return {Array<number>} - positions of common pixels for both arrays\n * @private\n */\nfunction getCommonSurface(positionArray1, positionArray2) {\n  let i = 0;\n  let j = 0;\n  let commonSurface = [];\n  while (i < positionArray1.length && j < positionArray2.length) {\n    if (positionArray1[i][0] === positionArray2[j][0] && positionArray1[i][1] === positionArray2[j][1]) {\n      commonSurface.push(positionArray1[i]);\n      i++;\n      j++;\n    } else if (positionArray1[i][0] < positionArray2[j][0] || positionArray1[i][0] === positionArray2[j][0] && positionArray1[i][1] < positionArray2[j][1]) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return commonSurface;\n}","map":{"version":3,"names":["getIntersection","mask2","mask1","closestParent","getClosestCommonParent","startPos1","getRelativePosition","defaultFurther","allRelPos1","getRelativePositionForAllPixels","startPos2","allRelPos2","commonSurface","getCommonSurface","intersection","whitePixelsMask1","whitePixelsMask2","commonWhitePixels","i","length","currentRelativePos","realPos1","realPos2","valueBitMask1","getBitXY","valueBitMask2","push","posX","posY","Math","floor","width","mask","startPosition","relativePositions","height","j","originalPos","positionArray1","positionArray2"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/utility/getIntersection.js"],"sourcesContent":["/**\n * Find intersection of points between two different masks\n * @memberof Image\n * @instance\n * @param {Image} mask2 - a mask (1 bit image)\n * @return {object} - object containing number of white pixels for mask1, for mask 2 and for them both\n */\nexport default function getIntersection(mask2) {\n  let mask1 = this;\n  let closestParent = mask1.getClosestCommonParent(mask2);\n\n  let startPos1 = mask1.getRelativePosition(closestParent, {\n    defaultFurther: true,\n  });\n  let allRelPos1 = getRelativePositionForAllPixels(mask1, startPos1);\n  let startPos2 = mask2.getRelativePosition(closestParent, {\n    defaultFurther: true,\n  });\n  let allRelPos2 = getRelativePositionForAllPixels(mask2, startPos2);\n\n  let commonSurface = getCommonSurface(allRelPos1, allRelPos2);\n  let intersection = {\n    whitePixelsMask1: [],\n    whitePixelsMask2: [],\n    commonWhitePixels: [],\n  };\n\n  for (let i = 0; i < commonSurface.length; i++) {\n    let currentRelativePos = commonSurface[i];\n    let realPos1 = [\n      currentRelativePos[0] - startPos1[0],\n      currentRelativePos[1] - startPos1[1],\n    ];\n    let realPos2 = [\n      currentRelativePos[0] - startPos2[0],\n      currentRelativePos[1] - startPos2[1],\n    ];\n    let valueBitMask1 = mask1.getBitXY(realPos1[0], realPos1[1]);\n    let valueBitMask2 = mask2.getBitXY(realPos2[0], realPos2[1]);\n\n    if (valueBitMask1 === 1 && valueBitMask2 === 1) {\n      intersection.commonWhitePixels.push(currentRelativePos);\n    }\n  }\n\n  for (let i = 0; i < allRelPos1.length; i++) {\n    let posX;\n    let posY;\n    if (i !== 0) {\n      posX = Math.floor(i / mask1.width);\n      posY = i % mask1.width;\n    }\n    if (mask1.getBitXY(posX, posY) === 1) {\n      intersection.whitePixelsMask1.push(allRelPos1[i]);\n    }\n  }\n\n  for (let i = 0; i < allRelPos2.length; i++) {\n    let posX = 0;\n    let posY = 0;\n    if (i !== 0) {\n      posX = Math.floor(i / mask2.width);\n      posY = i % mask2.width;\n    }\n    if (mask2.getBitXY(posX, posY) === 1) {\n      intersection.whitePixelsMask2.push(allRelPos2[i]);\n    }\n  }\n\n  return intersection;\n}\n\n/**\n * Get relative position array for all pixels in masks\n * @param {Image} mask - a mask (1 bit image)\n * @param {Array<number>} startPosition - start position of mask relative to parent\n * @return {Array} - relative position of all pixels\n * @private\n */\nfunction getRelativePositionForAllPixels(mask, startPosition) {\n  let relativePositions = [];\n  for (let i = 0; i < mask.height; i++) {\n    for (let j = 0; j < mask.width; j++) {\n      let originalPos = [i, j];\n      relativePositions.push([\n        originalPos[0] + startPosition[0],\n        originalPos[1] + startPosition[1],\n      ]);\n    }\n  }\n  return relativePositions;\n}\n\n/**\n * Finds common surface for two arrays containing the positions of the pixels relative to parent image\n * @param {Array<number>} positionArray1 - positions of pixels relative to parent\n * @param {Array<number>} positionArray2 - positions of pixels relative to parent\n * @return {Array<number>} - positions of common pixels for both arrays\n * @private\n */\nfunction getCommonSurface(positionArray1, positionArray2) {\n  let i = 0;\n  let j = 0;\n  let commonSurface = [];\n  while (i < positionArray1.length && j < positionArray2.length) {\n    if (\n      positionArray1[i][0] === positionArray2[j][0] &&\n      positionArray1[i][1] === positionArray2[j][1]\n    ) {\n      commonSurface.push(positionArray1[i]);\n      i++;\n      j++;\n    } else if (\n      positionArray1[i][0] < positionArray2[j][0] ||\n      (positionArray1[i][0] === positionArray2[j][0] &&\n        positionArray1[i][1] < positionArray2[j][1])\n    ) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  return commonSurface;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}