{"ast":null,"code":"import { rotate, difference, normalize } from '../../util/points';\nimport convexHullFunction from './monotoneChainConvexHull';\n\n/**\n * Computes the minimum bounding box around a binary image\n * https://www.researchgate.net/profile/Lennert_Den_Boer2/publication/303783472_A_Fast_Algorithm_for_Generating_a_Minimal_Bounding_Rectangle/links/5751a14108ae6807fafb2aa5.pdf\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.originalPoints]\n * @return {Array<Array<number>>}\n */\nexport default function minimalBoundingRectangle(options = {}) {\n  const {\n    originalPoints = convexHullFunction.call(this)\n  } = options;\n  if (originalPoints.length === 0) {\n    return [];\n  }\n  if (originalPoints.length === 1) {\n    return [originalPoints[0], originalPoints[0], originalPoints[0], originalPoints[0]];\n  }\n  const p = new Array(originalPoints.length);\n  let minSurface = +Infinity;\n  let minSurfaceAngle = 0;\n  let mbr;\n  for (let i = 0; i < p.length; i++) {\n    let angle = getAngle(originalPoints[i], originalPoints[(i + 1) % p.length]);\n    rotate(-angle, originalPoints, p);\n\n    // we rotate and translate so that this axe is in the bottom\n    let aX = p[i][0];\n    let aY = p[i][1];\n    let bX = p[(i + 1) % p.length][0];\n    let bY = p[(i + 1) % p.length][1];\n    let tUndefined = true;\n    let tMin = 0;\n    let tMax = 0;\n    let maxWidth = 0;\n    for (let j = 0; j < p.length; j++) {\n      let cX = p[j][0];\n      let cY = p[j][1];\n      let t = (cX - aX) / (bX - aX);\n      if (tUndefined === true) {\n        tUndefined = false;\n        tMin = t;\n        tMax = t;\n      } else {\n        if (t < tMin) tMin = t;\n        if (t > tMax) tMax = t;\n      }\n      let width = (-(bX - aX) * cY + bX * aY - bY * aX) / (bX - aX);\n      if (Math.abs(width) > Math.abs(maxWidth)) maxWidth = width;\n    }\n    let pMin = [aX + tMin * (bX - aX), aY];\n    let pMax = [aX + tMax * (bX - aX), aY];\n    let currentSurface = Math.abs(maxWidth * (tMin - tMax) * (bX - aX));\n    if (currentSurface < minSurface) {\n      minSurfaceAngle = angle;\n      minSurface = currentSurface;\n      mbr = [pMin, pMax, [pMax[0], pMax[1] - maxWidth], [pMin[0], pMin[1] - maxWidth]];\n    }\n  }\n  rotate(minSurfaceAngle, mbr, mbr);\n  return mbr;\n}\n\n// the angle that allows to make the line going through p1 and p2 horizontal\n// this is an optimized version because it assume one vector is horizontal\nfunction getAngle(p1, p2) {\n  let diff = difference(p2, p1);\n  let vector = normalize(diff);\n  let angle = Math.acos(vector[0]);\n  if (vector[1] < 0) return -angle;\n  return angle;\n}","map":{"version":3,"names":["rotate","difference","normalize","convexHullFunction","minimalBoundingRectangle","options","originalPoints","call","length","p","Array","minSurface","Infinity","minSurfaceAngle","mbr","i","angle","getAngle","aX","aY","bX","bY","tUndefined","tMin","tMax","maxWidth","j","cX","cY","t","width","Math","abs","pMin","pMax","currentSurface","p1","p2","diff","vector","acos"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/compute/minimalBoundingRectangle.js"],"sourcesContent":["import { rotate, difference, normalize } from '../../util/points';\n\nimport convexHullFunction from './monotoneChainConvexHull';\n\n/**\n * Computes the minimum bounding box around a binary image\n * https://www.researchgate.net/profile/Lennert_Den_Boer2/publication/303783472_A_Fast_Algorithm_for_Generating_a_Minimal_Bounding_Rectangle/links/5751a14108ae6807fafb2aa5.pdf\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Array<Array<number>>} [options.originalPoints]\n * @return {Array<Array<number>>}\n */\nexport default function minimalBoundingRectangle(options = {}) {\n  const { originalPoints = convexHullFunction.call(this) } = options;\n  if (originalPoints.length === 0) {\n    return [];\n  }\n\n  if (originalPoints.length === 1) {\n    return [\n      originalPoints[0],\n      originalPoints[0],\n      originalPoints[0],\n      originalPoints[0],\n    ];\n  }\n\n  const p = new Array(originalPoints.length);\n\n  let minSurface = +Infinity;\n  let minSurfaceAngle = 0;\n  let mbr;\n\n  for (let i = 0; i < p.length; i++) {\n    let angle = getAngle(originalPoints[i], originalPoints[(i + 1) % p.length]);\n\n    rotate(-angle, originalPoints, p);\n\n    // we rotate and translate so that this axe is in the bottom\n    let aX = p[i][0];\n    let aY = p[i][1];\n    let bX = p[(i + 1) % p.length][0];\n    let bY = p[(i + 1) % p.length][1];\n\n    let tUndefined = true;\n    let tMin = 0;\n    let tMax = 0;\n    let maxWidth = 0;\n    for (let j = 0; j < p.length; j++) {\n      let cX = p[j][0];\n      let cY = p[j][1];\n      let t = (cX - aX) / (bX - aX);\n      if (tUndefined === true) {\n        tUndefined = false;\n        tMin = t;\n        tMax = t;\n      } else {\n        if (t < tMin) tMin = t;\n        if (t > tMax) tMax = t;\n      }\n      let width = (-(bX - aX) * cY + bX * aY - bY * aX) / (bX - aX);\n\n      if (Math.abs(width) > Math.abs(maxWidth)) maxWidth = width;\n    }\n    let pMin = [aX + tMin * (bX - aX), aY];\n    let pMax = [aX + tMax * (bX - aX), aY];\n\n    let currentSurface = Math.abs(maxWidth * (tMin - tMax) * (bX - aX));\n\n    if (currentSurface < minSurface) {\n      minSurfaceAngle = angle;\n      minSurface = currentSurface;\n      mbr = [\n        pMin,\n        pMax,\n        [pMax[0], pMax[1] - maxWidth],\n        [pMin[0], pMin[1] - maxWidth],\n      ];\n    }\n  }\n  rotate(minSurfaceAngle, mbr, mbr);\n  return mbr;\n}\n\n// the angle that allows to make the line going through p1 and p2 horizontal\n// this is an optimized version because it assume one vector is horizontal\nfunction getAngle(p1, p2) {\n  let diff = difference(p2, p1);\n  let vector = normalize(diff);\n  let angle = Math.acos(vector[0]);\n  if (vector[1] < 0) return -angle;\n  return angle;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}