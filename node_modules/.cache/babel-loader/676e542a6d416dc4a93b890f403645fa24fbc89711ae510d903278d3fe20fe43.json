{"ast":null,"code":"import Roi from './Roi';\n\n/**\n * A layer that is caracterised by a {@link RoiMap} and that will\n * generated automatically the corresponding ROI.\n * ROI should be a continuous\n * surface (it is not tested when it is not continous ...)\n * From the roiMap, the RoiLayer will create the corresponding\n * {@link ROI}.\n *\n * @class RoiLayer\n * @private\n * @param {Image} image\n * @param {object} [options]\n */\nexport default class RoiLayer {\n  constructor(roiMap, options) {\n    this.roiMap = roiMap;\n    this.options = options;\n    this.roi = this.createRoi();\n  }\n\n  /**\n   * Roi are created from a roiMap\n   * The roiMap contains mainty an array of identifiers that define\n   * for each data to which Roi it belongs\n   * @memberof RoiManager\n   * @instance\n   * @return {Roi[]}\n   */\n  createRoi() {\n    // we need to find all all the different IDs there is in the data\n    let data = this.roiMap.data;\n    let mapIDs = {};\n    this.roiMap.positive = 0;\n    this.roiMap.negative = 0;\n    for (let i = 0; i < data.length; i++) {\n      if (data[i] && !mapIDs[data[i]]) {\n        mapIDs[data[i]] = true;\n        if (data[i] > 0) {\n          this.roiMap.positive++;\n        } else {\n          this.roiMap.negative++;\n        }\n      }\n    }\n    let rois = {};\n    for (let mapID in mapIDs) {\n      rois[mapID] = new Roi(this.roiMap, mapID * 1);\n    }\n    let width = this.roiMap.width;\n    let height = this.roiMap.height;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        let target = y * width + x;\n        if (data[target] !== 0) {\n          const mapID = data[target];\n          const roi = rois[mapID];\n          if (x < roi.minX) {\n            roi.minX = x;\n          }\n          if (x > roi.maxX) {\n            roi.maxX = x;\n          }\n          if (y < roi.minY) {\n            roi.minY = y;\n          }\n          if (y > roi.maxY) {\n            roi.maxY = y;\n          }\n          roi.meanX += x;\n          roi.meanY += y;\n          roi.surface++;\n        }\n      }\n    }\n    let roiArray = [];\n    for (let mapID in mapIDs) {\n      rois[mapID].meanX /= rois[mapID].surface;\n      rois[mapID].meanY /= rois[mapID].surface;\n      roiArray.push(rois[mapID]);\n    }\n    return roiArray;\n  }\n}","map":{"version":3,"names":["Roi","RoiLayer","constructor","roiMap","options","roi","createRoi","data","mapIDs","positive","negative","i","length","rois","mapID","width","height","y","x","target","minX","maxX","minY","maxY","meanX","meanY","surface","roiArray","push"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/roi/RoiLayer.js"],"sourcesContent":["import Roi from './Roi';\n\n/**\n * A layer that is caracterised by a {@link RoiMap} and that will\n * generated automatically the corresponding ROI.\n * ROI should be a continuous\n * surface (it is not tested when it is not continous ...)\n * From the roiMap, the RoiLayer will create the corresponding\n * {@link ROI}.\n *\n * @class RoiLayer\n * @private\n * @param {Image} image\n * @param {object} [options]\n */\nexport default class RoiLayer {\n  constructor(roiMap, options) {\n    this.roiMap = roiMap;\n    this.options = options;\n    this.roi = this.createRoi();\n  }\n\n  /**\n   * Roi are created from a roiMap\n   * The roiMap contains mainty an array of identifiers that define\n   * for each data to which Roi it belongs\n   * @memberof RoiManager\n   * @instance\n   * @return {Roi[]}\n   */\n  createRoi() {\n    // we need to find all all the different IDs there is in the data\n    let data = this.roiMap.data;\n    let mapIDs = {};\n    this.roiMap.positive = 0;\n    this.roiMap.negative = 0;\n\n    for (let i = 0; i < data.length; i++) {\n      if (data[i] && !mapIDs[data[i]]) {\n        mapIDs[data[i]] = true;\n        if (data[i] > 0) {\n          this.roiMap.positive++;\n        } else {\n          this.roiMap.negative++;\n        }\n      }\n    }\n\n    let rois = {};\n\n    for (let mapID in mapIDs) {\n      rois[mapID] = new Roi(this.roiMap, mapID * 1);\n    }\n    let width = this.roiMap.width;\n    let height = this.roiMap.height;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        let target = y * width + x;\n        if (data[target] !== 0) {\n          const mapID = data[target];\n          const roi = rois[mapID];\n          if (x < roi.minX) {\n            roi.minX = x;\n          }\n          if (x > roi.maxX) {\n            roi.maxX = x;\n          }\n          if (y < roi.minY) {\n            roi.minY = y;\n          }\n          if (y > roi.maxY) {\n            roi.maxY = y;\n          }\n          roi.meanX += x;\n          roi.meanY += y;\n          roi.surface++;\n        }\n      }\n    }\n    let roiArray = [];\n    for (let mapID in mapIDs) {\n      rois[mapID].meanX /= rois[mapID].surface;\n      rois[mapID].meanY /= rois[mapID].surface;\n      roiArray.push(rois[mapID]);\n    }\n\n    return roiArray;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}