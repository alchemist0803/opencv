{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\nimport { pngSignature, crc } from './common';\nimport { ColorType, CompressionMethod, FilterMethod, InterlaceMethod } from './internalTypes';\nconst empty = new Uint8Array(0);\nconst NULL = '\\0';\nconst uint16 = new Uint16Array([0x00ff]);\nconst uint8 = new Uint8Array(uint16.buffer);\nconst osIsLittleEndian = uint8[0] === 0xff;\nexport default class PngDecoder extends IOBuffer {\n  constructor(data, options = {}) {\n    super(data);\n    const {\n      checkCrc = false\n    } = options;\n    this._checkCrc = checkCrc;\n    this._inflator = new Inflator();\n    this._png = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      data: new Uint8Array(0),\n      depth: 1,\n      text: {}\n    };\n    this._end = false;\n    this._hasPalette = false;\n    this._palette = [];\n    this._hasTransparency = false;\n    this._transparency = new Uint16Array(0);\n    this._compressionMethod = CompressionMethod.UNKNOWN;\n    this._filterMethod = FilterMethod.UNKNOWN;\n    this._interlaceMethod = InterlaceMethod.UNKNOWN;\n    this._colorType = ColorType.UNKNOWN;\n    // PNG is always big endian\n    // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n    this.setBigEndian();\n  }\n  decode() {\n    this.decodeSignature();\n    while (!this._end) {\n      this.decodeChunk();\n    }\n    this.decodeImage();\n    return this._png;\n  }\n  // https://www.w3.org/TR/PNG/#5PNG-file-signature\n  decodeSignature() {\n    for (let i = 0; i < pngSignature.length; i++) {\n      if (this.readUint8() !== pngSignature[i]) {\n        throw new Error(`wrong PNG signature. Byte at ${i} should be ${pngSignature[i]}.`);\n      }\n    }\n  }\n  // https://www.w3.org/TR/PNG/#5Chunk-layout\n  decodeChunk() {\n    const length = this.readUint32();\n    const type = this.readChars(4);\n    const offset = this.offset;\n    switch (type) {\n      // 11.2 Critical chunks\n      case 'IHDR':\n        // 11.2.2 IHDR Image header\n        this.decodeIHDR();\n        break;\n      case 'PLTE':\n        // 11.2.3 PLTE Palette\n        this.decodePLTE(length);\n        break;\n      case 'IDAT':\n        // 11.2.4 IDAT Image data\n        this.decodeIDAT(length);\n        break;\n      case 'IEND':\n        // 11.2.5 IEND Image trailer\n        this._end = true;\n        break;\n      // 11.3 Ancillary chunks\n      case 'tRNS':\n        // 11.3.2.1 tRNS Transparency\n        this.decodetRNS(length);\n        break;\n      case 'iCCP':\n        // 11.3.3.3 iCCP Embedded ICC profile\n        this.decodeiCCP(length);\n        break;\n      case 'tEXt':\n        // 11.3.4.3 tEXt Textual data\n        this.decodetEXt(length);\n        break;\n      case 'pHYs':\n        // 11.3.5.3 pHYs Physical pixel dimensions\n        this.decodepHYs();\n        break;\n      default:\n        this.skip(length);\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      const expectedCrc = this.readUint32();\n      const crcLength = length + 4; // includes type\n      const actualCrc = crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - crcLength - 4, crcLength), crcLength); // \"- 4\" because we already advanced by reading the CRC\n      if (actualCrc !== expectedCrc) {\n        throw new Error(`CRC mismatch for chunk ${type}. Expected ${expectedCrc}, found ${actualCrc}`);\n      }\n    } else {\n      this.skip(4);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  decodeIHDR() {\n    const image = this._png;\n    image.width = this.readUint32();\n    image.height = this.readUint32();\n    image.depth = checkBitDepth(this.readUint8());\n    const colorType = this.readUint8();\n    this._colorType = colorType;\n    let channels;\n    switch (colorType) {\n      case ColorType.GREYSCALE:\n        channels = 1;\n        break;\n      case ColorType.TRUECOLOUR:\n        channels = 3;\n        break;\n      case ColorType.INDEXED_COLOUR:\n        channels = 1;\n        break;\n      case ColorType.GREYSCALE_ALPHA:\n        channels = 2;\n        break;\n      case ColorType.TRUECOLOUR_ALPHA:\n        channels = 4;\n        break;\n      default:\n        throw new Error(`Unknown color type: ${colorType}`);\n    }\n    this._png.channels = channels;\n    this._compressionMethod = this.readUint8();\n    if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\n    }\n    this._filterMethod = this.readUint8();\n    this._interlaceMethod = this.readUint8();\n  }\n  // https://www.w3.org/TR/PNG/#11PLTE\n  decodePLTE(length) {\n    if (length % 3 !== 0) {\n      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\n    }\n    const l = length / 3;\n    this._hasPalette = true;\n    const palette = [];\n    this._palette = palette;\n    for (let i = 0; i < l; i++) {\n      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  decodeIDAT(length) {\n    this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, length));\n    this.skip(length);\n  }\n  // https://www.w3.org/TR/PNG/#11tRNS\n  decodetRNS(length) {\n    switch (this._colorType) {\n      case ColorType.GREYSCALE:\n      case ColorType.TRUECOLOUR:\n        {\n          if (length % 2 !== 0) {\n            throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);\n          }\n          if (length / 2 > this._png.width * this._png.height) {\n            throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);\n          }\n          this._hasTransparency = true;\n          this._transparency = new Uint16Array(length / 2);\n          for (let i = 0; i < length / 2; i++) {\n            this._transparency[i] = this.readUint16();\n          }\n          break;\n        }\n      case ColorType.INDEXED_COLOUR:\n        {\n          if (length > this._palette.length) {\n            throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\n          }\n          let i = 0;\n          for (; i < length; i++) {\n            const alpha = this.readByte();\n            this._palette[i].push(alpha);\n          }\n          for (; i < this._palette.length; i++) {\n            this._palette[i].push(255);\n          }\n          break;\n        }\n      default:\n        {\n          throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);\n        }\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11iCCP\n  decodeiCCP(length) {\n    let name = '';\n    let char;\n    while ((char = this.readChar()) !== NULL) {\n      name += char;\n    }\n    const compressionMethod = this.readUint8();\n    if (compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);\n    }\n    const compressedProfile = this.readBytes(length - name.length - 2);\n    this._png.iccEmbeddedProfile = {\n      name,\n      profile: inflate(compressedProfile)\n    };\n  }\n  // https://www.w3.org/TR/PNG/#11tEXt\n  decodetEXt(length) {\n    let keyword = '';\n    let char;\n    while ((char = this.readChar()) !== NULL) {\n      keyword += char;\n    }\n    this._png.text[keyword] = this.readChars(length - keyword.length - 1);\n  }\n  // https://www.w3.org/TR/PNG/#11pHYs\n  decodepHYs() {\n    const ppuX = this.readUint32();\n    const ppuY = this.readUint32();\n    const unitSpecifier = this.readByte();\n    this._png.resolution = {\n      x: ppuX,\n      y: ppuY,\n      unit: unitSpecifier\n    };\n  }\n  decodeImage() {\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    const data = this._inflator.result;\n    if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n      throw new Error(`Filter method ${this._filterMethod} not supported`);\n    }\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      this.decodeInterlaceNull(data);\n    } else {\n      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\n    }\n  }\n  decodeInterlaceNull(data) {\n    const height = this._png.height;\n    const bytesPerPixel = this._png.channels * this._png.depth / 8;\n    const bytesPerLine = this._png.width * bytesPerPixel;\n    const newData = new Uint8Array(this._png.height * bytesPerLine);\n    let prevLine = empty;\n    let offset = 0;\n    let currentLine;\n    let newLine;\n    for (let i = 0; i < height; i++) {\n      currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);\n      newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);\n      switch (data[offset]) {\n        case 0:\n          unfilterNone(currentLine, newLine, bytesPerLine);\n          break;\n        case 1:\n          unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);\n          break;\n        case 2:\n          unfilterUp(currentLine, newLine, prevLine, bytesPerLine);\n          break;\n        case 3:\n          unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n          break;\n        case 4:\n          unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);\n          break;\n        default:\n          throw new Error(`Unsupported filter: ${data[offset]}`);\n      }\n      prevLine = newLine;\n      offset += bytesPerLine + 1;\n    }\n    if (this._hasPalette) {\n      this._png.palette = this._palette;\n    }\n    if (this._hasTransparency) {\n      this._png.transparency = this._transparency;\n    }\n    if (this._png.depth === 16) {\n      const uint16Data = new Uint16Array(newData.buffer);\n      if (osIsLittleEndian) {\n        for (let k = 0; k < uint16Data.length; k++) {\n          // PNG is always big endian. Swap the bytes.\n          uint16Data[k] = swap16(uint16Data[k]);\n        }\n      }\n      this._png.data = uint16Data;\n    } else {\n      this._png.data = newData;\n    }\n  }\n}\nfunction unfilterNone(currentLine, newLine, bytesPerLine) {\n  for (let i = 0; i < bytesPerLine; i++) {\n    newLine[i] = currentLine[i];\n  }\n}\nfunction unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {\n  let i = 0;\n  for (; i < bytesPerPixel; i++) {\n    // just copy first bytes\n    newLine[i] = currentLine[i];\n  }\n  for (; i < bytesPerLine; i++) {\n    newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 0xff;\n  }\n}\nfunction unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {\n  let i = 0;\n  if (prevLine.length === 0) {\n    // just copy bytes for first line\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i];\n    }\n  } else {\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + prevLine[i] & 0xff;\n    }\n  }\n}\nfunction unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n  let i = 0;\n  if (prevLine.length === 0) {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i];\n    }\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] >> 1) & 0xff;\n    }\n  } else {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i] + (prevLine[i] >> 1) & 0xff;\n    }\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + (newLine[i - bytesPerPixel] + prevLine[i] >> 1) & 0xff;\n    }\n  }\n}\nfunction unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {\n  let i = 0;\n  if (prevLine.length === 0) {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i];\n    }\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + newLine[i - bytesPerPixel] & 0xff;\n    }\n  } else {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i] + prevLine[i] & 0xff;\n    }\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i] + paethPredictor(newLine[i - bytesPerPixel], prevLine[i], prevLine[i - bytesPerPixel]) & 0xff;\n    }\n  }\n}\nfunction paethPredictor(a, b, c) {\n  const p = a + b - c;\n  const pa = Math.abs(p - a);\n  const pb = Math.abs(p - b);\n  const pc = Math.abs(p - c);\n  if (pa <= pb && pa <= pc) return a;else if (pb <= pc) return b;else return c;\n}\nfunction swap16(val) {\n  return (val & 0xff) << 8 | val >> 8 & 0xff;\n}\nfunction checkBitDepth(value) {\n  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {\n    throw new Error(`invalid bit depth: ${value}`);\n  }\n  return value;\n}","map":{"version":3,"names":["IOBuffer","inflate","Inflate","Inflator","pngSignature","crc","ColorType","CompressionMethod","FilterMethod","InterlaceMethod","empty","Uint8Array","NULL","uint16","Uint16Array","uint8","buffer","osIsLittleEndian","PngDecoder","constructor","data","options","checkCrc","_checkCrc","_inflator","_png","width","height","channels","depth","text","_end","_hasPalette","_palette","_hasTransparency","_transparency","_compressionMethod","UNKNOWN","_filterMethod","_interlaceMethod","_colorType","setBigEndian","decode","decodeSignature","decodeChunk","decodeImage","i","length","readUint8","Error","readUint32","type","readChars","offset","decodeIHDR","decodePLTE","decodeIDAT","decodetRNS","decodeiCCP","decodetEXt","decodepHYs","skip","expectedCrc","crcLength","actualCrc","byteOffset","image","checkBitDepth","colorType","GREYSCALE","TRUECOLOUR","INDEXED_COLOUR","GREYSCALE_ALPHA","TRUECOLOUR_ALPHA","DEFLATE","RangeError","l","palette","push","readUint16","alpha","readByte","name","char","readChar","compressionMethod","compressedProfile","readBytes","iccEmbeddedProfile","profile","keyword","ppuX","ppuY","unitSpecifier","resolution","x","y","unit","err","result","ADAPTIVE","NO_INTERLACE","decodeInterlaceNull","bytesPerPixel","bytesPerLine","newData","prevLine","currentLine","newLine","subarray","unfilterNone","unfilterSub","unfilterUp","unfilterAverage","unfilterPaeth","transparency","uint16Data","k","swap16","paethPredictor","a","b","c","p","pa","Math","abs","pb","pc","val","value"],"sources":["C:\\Users\\Admin\\Documents\\Workspace\\opencv\\opencv\\node_modules\\fast-png\\src\\PngDecoder.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\n\nimport { pngSignature, crc } from './common';\nimport {\n  ColorType,\n  CompressionMethod,\n  FilterMethod,\n  InterlaceMethod,\n} from './internalTypes';\nimport {\n  DecodedPng,\n  DecoderInputType,\n  PngDecoderOptions,\n  PngDataArray,\n  IndexedColors,\n  BitDepth,\n} from './types';\n\nconst empty = new Uint8Array(0);\nconst NULL = '\\0';\n\nconst uint16 = new Uint16Array([0x00ff]);\nconst uint8 = new Uint8Array(uint16.buffer);\nconst osIsLittleEndian = uint8[0] === 0xff;\n\nexport default class PngDecoder extends IOBuffer {\n  private _checkCrc: boolean;\n  private _inflator: Inflator;\n  private _png: DecodedPng;\n  private _end: boolean;\n  private _hasPalette: boolean;\n  private _palette: IndexedColors;\n  private _hasTransparency: boolean;\n  private _transparency: Uint16Array;\n  private _compressionMethod: CompressionMethod;\n  private _filterMethod: FilterMethod;\n  private _interlaceMethod: InterlaceMethod;\n  private _colorType: ColorType;\n\n  public constructor(data: DecoderInputType, options: PngDecoderOptions = {}) {\n    super(data);\n    const { checkCrc = false } = options;\n    this._checkCrc = checkCrc;\n    this._inflator = new Inflator();\n    this._png = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      data: new Uint8Array(0),\n      depth: 1,\n      text: {},\n    };\n    this._end = false;\n    this._hasPalette = false;\n    this._palette = [];\n    this._hasTransparency = false;\n    this._transparency = new Uint16Array(0);\n    this._compressionMethod = CompressionMethod.UNKNOWN;\n    this._filterMethod = FilterMethod.UNKNOWN;\n    this._interlaceMethod = InterlaceMethod.UNKNOWN;\n    this._colorType = ColorType.UNKNOWN;\n    // PNG is always big endian\n    // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n    this.setBigEndian();\n  }\n\n  public decode(): DecodedPng {\n    this.decodeSignature();\n    while (!this._end) {\n      this.decodeChunk();\n    }\n    this.decodeImage();\n    return this._png;\n  }\n\n  // https://www.w3.org/TR/PNG/#5PNG-file-signature\n  private decodeSignature(): void {\n    for (let i = 0; i < pngSignature.length; i++) {\n      if (this.readUint8() !== pngSignature[i]) {\n        throw new Error(\n          `wrong PNG signature. Byte at ${i} should be ${pngSignature[i]}.`,\n        );\n      }\n    }\n  }\n\n  // https://www.w3.org/TR/PNG/#5Chunk-layout\n  private decodeChunk(): void {\n    const length = this.readUint32();\n    const type = this.readChars(4);\n    const offset = this.offset;\n    switch (type) {\n      // 11.2 Critical chunks\n      case 'IHDR': // 11.2.2 IHDR Image header\n        this.decodeIHDR();\n        break;\n      case 'PLTE': // 11.2.3 PLTE Palette\n        this.decodePLTE(length);\n        break;\n      case 'IDAT': // 11.2.4 IDAT Image data\n        this.decodeIDAT(length);\n        break;\n      case 'IEND': // 11.2.5 IEND Image trailer\n        this._end = true;\n        break;\n      // 11.3 Ancillary chunks\n      case 'tRNS': // 11.3.2.1 tRNS Transparency\n        this.decodetRNS(length);\n        break;\n      case 'iCCP': // 11.3.3.3 iCCP Embedded ICC profile\n        this.decodeiCCP(length);\n        break;\n      case 'tEXt': // 11.3.4.3 tEXt Textual data\n        this.decodetEXt(length);\n        break;\n      case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions\n        this.decodepHYs();\n        break;\n      default:\n        this.skip(length);\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      const expectedCrc = this.readUint32();\n      const crcLength = length + 4; // includes type\n      const actualCrc = crc(\n        new Uint8Array(\n          this.buffer,\n          this.byteOffset + this.offset - crcLength - 4,\n          crcLength,\n        ),\n        crcLength,\n      ); // \"- 4\" because we already advanced by reading the CRC\n      if (actualCrc !== expectedCrc) {\n        throw new Error(\n          `CRC mismatch for chunk ${type}. Expected ${expectedCrc}, found ${actualCrc}`,\n        );\n      }\n    } else {\n      this.skip(4);\n    }\n  }\n\n  // https://www.w3.org/TR/PNG/#11IHDR\n  private decodeIHDR(): void {\n    const image = this._png;\n    image.width = this.readUint32();\n    image.height = this.readUint32();\n    image.depth = checkBitDepth(this.readUint8());\n\n    const colorType: ColorType = this.readUint8();\n    this._colorType = colorType;\n    let channels: number;\n    switch (colorType) {\n      case ColorType.GREYSCALE:\n        channels = 1;\n        break;\n      case ColorType.TRUECOLOUR:\n        channels = 3;\n        break;\n      case ColorType.INDEXED_COLOUR:\n        channels = 1;\n        break;\n      case ColorType.GREYSCALE_ALPHA:\n        channels = 2;\n        break;\n      case ColorType.TRUECOLOUR_ALPHA:\n        channels = 4;\n        break;\n      default:\n        throw new Error(`Unknown color type: ${colorType}`);\n    }\n    this._png.channels = channels;\n\n    this._compressionMethod = this.readUint8();\n    if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(\n        `Unsupported compression method: ${this._compressionMethod}`,\n      );\n    }\n\n    this._filterMethod = this.readUint8();\n    this._interlaceMethod = this.readUint8();\n  }\n\n  // https://www.w3.org/TR/PNG/#11PLTE\n  private decodePLTE(length: number): void {\n    if (length % 3 !== 0) {\n      throw new RangeError(\n        `PLTE field length must be a multiple of 3. Got ${length}`,\n      );\n    }\n    const l = length / 3;\n    this._hasPalette = true;\n    const palette: IndexedColors = [];\n    this._palette = palette;\n    for (let i = 0; i < l; i++) {\n      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n    }\n  }\n\n  // https://www.w3.org/TR/PNG/#11IDAT\n  private decodeIDAT(length: number): void {\n    this._inflator.push(\n      new Uint8Array(this.buffer, this.offset + this.byteOffset, length),\n    );\n    this.skip(length);\n  }\n\n  // https://www.w3.org/TR/PNG/#11tRNS\n  private decodetRNS(length: number): void {\n    switch (this._colorType) {\n      case ColorType.GREYSCALE:\n      case ColorType.TRUECOLOUR: {\n        if (length % 2 !== 0) {\n          throw new RangeError(\n            `tRNS chunk length must be a multiple of 2. Got ${length}`,\n          );\n        }\n        if (length / 2 > this._png.width * this._png.height) {\n          throw new Error(\n            `tRNS chunk contains more alpha values than there are pixels (${\n              length / 2\n            } vs ${this._png.width * this._png.height})`,\n          );\n        }\n        this._hasTransparency = true;\n        this._transparency = new Uint16Array(length / 2);\n        for (let i = 0; i < length / 2; i++) {\n          this._transparency[i] = this.readUint16();\n        }\n        break;\n      }\n      case ColorType.INDEXED_COLOUR: {\n        if (length > this._palette.length) {\n          throw new Error(\n            `tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`,\n          );\n        }\n        let i = 0;\n        for (; i < length; i++) {\n          const alpha = this.readByte();\n          this._palette[i].push(alpha);\n        }\n        for (; i < this._palette.length; i++) {\n          this._palette[i].push(255);\n        }\n        break;\n      }\n      default: {\n        throw new Error(\n          `tRNS chunk is not supported for color type ${this._colorType}`,\n        );\n      }\n    }\n  }\n\n  // https://www.w3.org/TR/PNG/#11iCCP\n  private decodeiCCP(length: number): void {\n    let name = '';\n    let char;\n    while ((char = this.readChar()) !== NULL) {\n      name += char;\n    }\n    const compressionMethod = this.readUint8();\n    if (compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(\n        `Unsupported iCCP compression method: ${compressionMethod}`,\n      );\n    }\n    const compressedProfile = this.readBytes(length - name.length - 2);\n    this._png.iccEmbeddedProfile = {\n      name,\n      profile: inflate(compressedProfile),\n    };\n  }\n\n  // https://www.w3.org/TR/PNG/#11tEXt\n  private decodetEXt(length: number): void {\n    let keyword = '';\n    let char;\n    while ((char = this.readChar()) !== NULL) {\n      keyword += char;\n    }\n    this._png.text[keyword] = this.readChars(length - keyword.length - 1);\n  }\n\n  // https://www.w3.org/TR/PNG/#11pHYs\n  private decodepHYs(): void {\n    const ppuX = this.readUint32();\n    const ppuY = this.readUint32();\n    const unitSpecifier = this.readByte();\n    this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };\n  }\n\n  private decodeImage(): void {\n    if (this._inflator.err) {\n      throw new Error(\n        `Error while decompressing the data: ${this._inflator.err}`,\n      );\n    }\n    const data = this._inflator.result;\n\n    if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n      throw new Error(`Filter method ${this._filterMethod} not supported`);\n    }\n\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      this.decodeInterlaceNull(data as Uint8Array);\n    } else {\n      throw new Error(\n        `Interlace method ${this._interlaceMethod} not supported`,\n      );\n    }\n  }\n\n  private decodeInterlaceNull(data: PngDataArray): void {\n    const height = this._png.height;\n    const bytesPerPixel = (this._png.channels * this._png.depth) / 8;\n    const bytesPerLine = this._png.width * bytesPerPixel;\n    const newData = new Uint8Array(this._png.height * bytesPerLine);\n\n    let prevLine = empty;\n    let offset = 0;\n    let currentLine;\n    let newLine;\n\n    for (let i = 0; i < height; i++) {\n      currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);\n      newLine = newData.subarray(i * bytesPerLine, (i + 1) * bytesPerLine);\n      switch (data[offset]) {\n        case 0:\n          unfilterNone(currentLine, newLine, bytesPerLine);\n          break;\n        case 1:\n          unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);\n          break;\n        case 2:\n          unfilterUp(currentLine, newLine, prevLine, bytesPerLine);\n          break;\n        case 3:\n          unfilterAverage(\n            currentLine,\n            newLine,\n            prevLine,\n            bytesPerLine,\n            bytesPerPixel,\n          );\n          break;\n        case 4:\n          unfilterPaeth(\n            currentLine,\n            newLine,\n            prevLine,\n            bytesPerLine,\n            bytesPerPixel,\n          );\n          break;\n        default:\n          throw new Error(`Unsupported filter: ${data[offset]}`);\n      }\n      prevLine = newLine;\n      offset += bytesPerLine + 1;\n    }\n\n    if (this._hasPalette) {\n      this._png.palette = this._palette;\n    }\n    if (this._hasTransparency) {\n      this._png.transparency = this._transparency;\n    }\n\n    if (this._png.depth === 16) {\n      const uint16Data = new Uint16Array(newData.buffer);\n      if (osIsLittleEndian) {\n        for (let k = 0; k < uint16Data.length; k++) {\n          // PNG is always big endian. Swap the bytes.\n          uint16Data[k] = swap16(uint16Data[k]);\n        }\n      }\n      this._png.data = uint16Data;\n    } else {\n      this._png.data = newData;\n    }\n  }\n}\n\nfunction unfilterNone(\n  currentLine: PngDataArray,\n  newLine: PngDataArray,\n  bytesPerLine: number,\n): void {\n  for (let i = 0; i < bytesPerLine; i++) {\n    newLine[i] = currentLine[i];\n  }\n}\n\nfunction unfilterSub(\n  currentLine: PngDataArray,\n  newLine: PngDataArray,\n  bytesPerLine: number,\n  bytesPerPixel: number,\n): void {\n  let i = 0;\n  for (; i < bytesPerPixel; i++) {\n    // just copy first bytes\n    newLine[i] = currentLine[i];\n  }\n  for (; i < bytesPerLine; i++) {\n    newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\n  }\n}\n\nfunction unfilterUp(\n  currentLine: PngDataArray,\n  newLine: PngDataArray,\n  prevLine: PngDataArray,\n  bytesPerLine: number,\n): void {\n  let i = 0;\n  if (prevLine.length === 0) {\n    // just copy bytes for first line\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = currentLine[i];\n    }\n  } else {\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\n    }\n  }\n}\n\nfunction unfilterAverage(\n  currentLine: PngDataArray,\n  newLine: PngDataArray,\n  prevLine: PngDataArray,\n  bytesPerLine: number,\n  bytesPerPixel: number,\n): void {\n  let i = 0;\n  if (prevLine.length === 0) {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i];\n    }\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = (currentLine[i] + (newLine[i - bytesPerPixel] >> 1)) & 0xff;\n    }\n  } else {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = (currentLine[i] + (prevLine[i] >> 1)) & 0xff;\n    }\n    for (; i < bytesPerLine; i++) {\n      newLine[i] =\n        (currentLine[i] + ((newLine[i - bytesPerPixel] + prevLine[i]) >> 1)) &\n        0xff;\n    }\n  }\n}\n\nfunction unfilterPaeth(\n  currentLine: PngDataArray,\n  newLine: PngDataArray,\n  prevLine: PngDataArray,\n  bytesPerLine: number,\n  bytesPerPixel: number,\n): void {\n  let i = 0;\n  if (prevLine.length === 0) {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = currentLine[i];\n    }\n    for (; i < bytesPerLine; i++) {\n      newLine[i] = (currentLine[i] + newLine[i - bytesPerPixel]) & 0xff;\n    }\n  } else {\n    for (; i < bytesPerPixel; i++) {\n      newLine[i] = (currentLine[i] + prevLine[i]) & 0xff;\n    }\n    for (; i < bytesPerLine; i++) {\n      newLine[i] =\n        (currentLine[i] +\n          paethPredictor(\n            newLine[i - bytesPerPixel],\n            prevLine[i],\n            prevLine[i - bytesPerPixel],\n          )) &\n        0xff;\n    }\n  }\n}\n\nfunction paethPredictor(a: number, b: number, c: number): number {\n  const p = a + b - c;\n  const pa = Math.abs(p - a);\n  const pb = Math.abs(p - b);\n  const pc = Math.abs(p - c);\n  if (pa <= pb && pa <= pc) return a;\n  else if (pb <= pc) return b;\n  else return c;\n}\n\nfunction swap16(val: number): number {\n  return ((val & 0xff) << 8) | ((val >> 8) & 0xff);\n}\n\nfunction checkBitDepth(value: number): BitDepth {\n  if (\n    value !== 1 &&\n    value !== 2 &&\n    value !== 4 &&\n    value !== 8 &&\n    value !== 16\n  ) {\n    throw new Error(`invalid bit depth: ${value}`);\n  }\n  return value;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}