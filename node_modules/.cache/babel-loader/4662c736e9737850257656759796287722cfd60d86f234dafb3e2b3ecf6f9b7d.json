{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Shanhbag A.G. (1994) \"Utilization of Information Measure as a Means of\n// Image Thresholding\" Graphical Models and Image Processing, 56(5): 414-419\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\n\nexport default function shanbhag(histogram, total) {\n  let normHisto = new Array(histogram.length); // normalized histogram\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n  let P1 = new Array(histogram.length); // cumulative normalized histogram\n  let P2 = new Array(histogram.length);\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n\n  /* Determine the first non-zero bin */\n  let firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  let lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  // Calculate the total entropy each gray-level\n  // and find the threshold that maximizes it\n  let threshold = -1;\n  let minEnt = Number.MAX_VALUE; // min entropy\n\n  let term;\n  let totEnt; // total entropy\n  let entBack; // entropy of the background pixels at a given threshold\n  let entObj; // entropy of the object pixels at a given threshold\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    entBack = 0.0;\n    term = 0.5 / P1[it];\n    for (let ih = 1; ih <= it; ih++) {\n      entBack -= normHisto[ih] * Math.log(1.0 - term * P1[ih - 1]);\n    }\n    entBack *= term;\n\n    /* Entropy of the object pixels */\n    entObj = 0.0;\n    term = 0.5 / P2[it];\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      entObj -= normHisto[ih] * Math.log(1.0 - term * P2[ih]);\n    }\n    entObj *= term;\n\n    /* Total entropy */\n    totEnt = Math.abs(entBack - entObj);\n    if (totEnt < minEnt) {\n      minEnt = totEnt;\n      threshold = it;\n    }\n  }\n  return threshold;\n}","map":{"version":3,"names":["shanbhag","histogram","total","normHisto","Array","length","ih","P1","P2","firstBin","Math","abs","Number","EPSILON","lastBin","threshold","minEnt","MAX_VALUE","term","totEnt","entBack","entObj","it","log"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/shanbhag.js"],"sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Shanhbag A.G. (1994) \"Utilization of Information Measure as a Means of\n// Image Thresholding\" Graphical Models and Image Processing, 56(5): 414-419\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\n\nexport default function shanbhag(histogram, total) {\n  let normHisto = new Array(histogram.length); // normalized histogram\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n\n  let P1 = new Array(histogram.length); // cumulative normalized histogram\n  let P2 = new Array(histogram.length);\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n\n  /* Determine the first non-zero bin */\n  let firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  let lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  // Calculate the total entropy each gray-level\n  // and find the threshold that maximizes it\n  let threshold = -1;\n  let minEnt = Number.MAX_VALUE; // min entropy\n\n  let term;\n  let totEnt; // total entropy\n  let entBack; // entropy of the background pixels at a given threshold\n  let entObj; // entropy of the object pixels at a given threshold\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    entBack = 0.0;\n    term = 0.5 / P1[it];\n    for (let ih = 1; ih <= it; ih++) {\n      entBack -= normHisto[ih] * Math.log(1.0 - term * P1[ih - 1]);\n    }\n    entBack *= term;\n\n    /* Entropy of the object pixels */\n    entObj = 0.0;\n    term = 0.5 / P2[it];\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      entObj -= normHisto[ih] * Math.log(1.0 - term * P2[ih]);\n    }\n    entObj *= term;\n\n    /* Total entropy */\n    totEnt = Math.abs(entBack - entObj);\n\n    if (totEnt < minEnt) {\n      minEnt = totEnt;\n      threshold = it;\n    }\n  }\n  return threshold;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}