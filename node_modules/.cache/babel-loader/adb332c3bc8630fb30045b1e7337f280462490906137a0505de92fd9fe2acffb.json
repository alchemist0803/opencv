{"ast":null,"code":"import hasOwn from 'has-own';\nimport Image from '../image/Image';\nimport extend from './extend';\nlet computedPropertyDescriptor = {\n  configurable: true,\n  enumerable: false,\n  get: undefined\n};\n\n/**\n * Class representing stack of images\n * @class Stack\n */\nexport default class Stack extends Array {\n  constructor(images) {\n    if (Array.isArray(images)) {\n      super(images.length);\n      for (let i = 0; i < images.length; i++) {\n        this[i] = images[i];\n      }\n    } else if (typeof images === 'number') {\n      super(images);\n    } else {\n      super();\n    }\n    this.computed = null;\n  }\n  static load(urls) {\n    return Promise.all(urls.map(Image.load)).then(images => new Stack(images));\n  }\n  static extendMethod(name, method, options = {}) {\n    let {\n      inPlace = false,\n      returnThis = true,\n      partialArgs = []\n    } = options;\n    if (inPlace) {\n      Stack.prototype[name] = function (...args) {\n        // remove computed properties\n        this.computed = null;\n        let result = method.apply(this, [...partialArgs, ...args]);\n        if (returnThis) {\n          return this;\n        }\n        return result;\n      };\n    } else {\n      Stack.prototype[name] = function (...args) {\n        return method.apply(this, [...partialArgs, ...args]);\n      };\n    }\n    return Stack;\n  }\n  static extendProperty(name, method, options = {}) {\n    let {\n      partialArgs = []\n    } = options;\n    computedPropertyDescriptor.get = function () {\n      if (this.computed === null) {\n        this.computed = {};\n      } else if (hasOwn(name, this.computed)) {\n        return this.computed[name];\n      }\n      let result = method.apply(this, partialArgs);\n      this.computed[name] = result;\n      return result;\n    };\n    Object.defineProperty(Stack.prototype, name, computedPropertyDescriptor);\n    return Stack;\n  }\n\n  /**\n   * Check if a process can be applied on the stack\n   * @param {string} processName\n   * @param {object} [options]\n   * @private\n   */\n  checkProcessable(processName, options = {}) {\n    if (typeof processName !== 'string') {\n      throw new TypeError('checkProcessable requires as first parameter the processName (a string)');\n    }\n    if (this.size === 0) {\n      throw new TypeError(`The process: ${processName} can not be applied on an empty stack`);\n    }\n    this[0].checkProcessable(processName, options);\n    for (let i = 1; i < this.length; i++) {\n      if ((options.sameSize === undefined || options.sameSize) && this[0].width !== this[i].width) {\n        throw new TypeError(`The process: ${processName} can not be applied if width is not identical in all images`);\n      }\n      if ((options.sameSize === undefined || options.sameSize) && this[0].height !== this[i].height) {\n        throw new TypeError(`The process: ${processName} can not be applied if height is not identical in all images`);\n      }\n      if ((options.sameAlpha === undefined || options.sameAlpha) && this[0].alpha !== this[i].alpha) {\n        throw new TypeError(`The process: ${processName} can not be applied if alpha is not identical in all images`);\n      }\n      if ((options.sameBitDepth === undefined || options.sameBitDepth) && this[0].bitDepth !== this[i].bitDepth) {\n        throw new TypeError(`The process: ${processName} can not be applied if bitDepth is not identical in all images`);\n      }\n      if ((options.sameColorModel === undefined || options.sameColorModel) && this[0].colorModel !== this[i].colorModel) {\n        throw new TypeError(`The process: ${processName} can not be applied if colorModel is not identical in all images`);\n      }\n      if ((options.sameNumberChannels === undefined || options.sameNumberChannels) && this[0].channels !== this[i].channels) {\n        throw new TypeError(`The process: ${processName} can not be applied if channels is not identical in all images`);\n      }\n    }\n  }\n}\nif (!Array[Symbol.species]) {\n  // support old engines\n  Stack.prototype.map = function (cb, thisArg) {\n    if (typeof cb !== 'function') {\n      throw new TypeError(`${cb} is not a function`);\n    }\n    let newStack = new Stack(this.length);\n    for (let i = 0; i < this.length; i++) {\n      newStack[i] = cb.call(thisArg, this[i], i, this);\n    }\n    return newStack;\n  };\n}\nextend(Stack);","map":{"version":3,"names":["hasOwn","Image","extend","computedPropertyDescriptor","configurable","enumerable","get","undefined","Stack","Array","constructor","images","isArray","length","i","computed","load","urls","Promise","all","map","then","extendMethod","name","method","options","inPlace","returnThis","partialArgs","prototype","args","result","apply","extendProperty","Object","defineProperty","checkProcessable","processName","TypeError","size","sameSize","width","height","sameAlpha","alpha","sameBitDepth","bitDepth","sameColorModel","colorModel","sameNumberChannels","channels","Symbol","species","cb","thisArg","newStack","call"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/stack/Stack.js"],"sourcesContent":["import hasOwn from 'has-own';\n\nimport Image from '../image/Image';\n\nimport extend from './extend';\n\nlet computedPropertyDescriptor = {\n  configurable: true,\n  enumerable: false,\n  get: undefined,\n};\n\n/**\n * Class representing stack of images\n * @class Stack\n */\nexport default class Stack extends Array {\n  constructor(images) {\n    if (Array.isArray(images)) {\n      super(images.length);\n      for (let i = 0; i < images.length; i++) {\n        this[i] = images[i];\n      }\n    } else if (typeof images === 'number') {\n      super(images);\n    } else {\n      super();\n    }\n    this.computed = null;\n  }\n\n  static load(urls) {\n    return Promise.all(urls.map(Image.load)).then(\n      (images) => new Stack(images),\n    );\n  }\n\n  static extendMethod(name, method, options = {}) {\n    let { inPlace = false, returnThis = true, partialArgs = [] } = options;\n\n    if (inPlace) {\n      Stack.prototype[name] = function (...args) {\n        // remove computed properties\n        this.computed = null;\n        let result = method.apply(this, [...partialArgs, ...args]);\n        if (returnThis) {\n          return this;\n        }\n        return result;\n      };\n    } else {\n      Stack.prototype[name] = function (...args) {\n        return method.apply(this, [...partialArgs, ...args]);\n      };\n    }\n    return Stack;\n  }\n\n  static extendProperty(name, method, options = {}) {\n    let { partialArgs = [] } = options;\n\n    computedPropertyDescriptor.get = function () {\n      if (this.computed === null) {\n        this.computed = {};\n      } else if (hasOwn(name, this.computed)) {\n        return this.computed[name];\n      }\n      let result = method.apply(this, partialArgs);\n      this.computed[name] = result;\n      return result;\n    };\n    Object.defineProperty(Stack.prototype, name, computedPropertyDescriptor);\n    return Stack;\n  }\n\n  /**\n   * Check if a process can be applied on the stack\n   * @param {string} processName\n   * @param {object} [options]\n   * @private\n   */\n  checkProcessable(processName, options = {}) {\n    if (typeof processName !== 'string') {\n      throw new TypeError(\n        'checkProcessable requires as first parameter the processName (a string)',\n      );\n    }\n    if (this.size === 0) {\n      throw new TypeError(\n        `The process: ${processName} can not be applied on an empty stack`,\n      );\n    }\n    this[0].checkProcessable(processName, options);\n    for (let i = 1; i < this.length; i++) {\n      if (\n        (options.sameSize === undefined || options.sameSize) &&\n        this[0].width !== this[i].width\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if width is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameSize === undefined || options.sameSize) &&\n        this[0].height !== this[i].height\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if height is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameAlpha === undefined || options.sameAlpha) &&\n        this[0].alpha !== this[i].alpha\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if alpha is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameBitDepth === undefined || options.sameBitDepth) &&\n        this[0].bitDepth !== this[i].bitDepth\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if bitDepth is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameColorModel === undefined || options.sameColorModel) &&\n        this[0].colorModel !== this[i].colorModel\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if colorModel is not identical in all images`,\n        );\n      }\n      if (\n        (options.sameNumberChannels === undefined ||\n          options.sameNumberChannels) &&\n        this[0].channels !== this[i].channels\n      ) {\n        throw new TypeError(\n          `The process: ${processName} can not be applied if channels is not identical in all images`,\n        );\n      }\n    }\n  }\n}\n\nif (!Array[Symbol.species]) {\n  // support old engines\n  Stack.prototype.map = function (cb, thisArg) {\n    if (typeof cb !== 'function') {\n      throw new TypeError(`${cb} is not a function`);\n    }\n    let newStack = new Stack(this.length);\n    for (let i = 0; i < this.length; i++) {\n      newStack[i] = cb.call(thisArg, this[i], i, this);\n    }\n    return newStack;\n  };\n}\n\nextend(Stack);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}