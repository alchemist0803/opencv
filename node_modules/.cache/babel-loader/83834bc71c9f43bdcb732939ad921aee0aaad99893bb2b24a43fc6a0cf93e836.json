{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// W. Tsai, \"Moment-preserving thresholding: a new approach,\" Computer Vision,\n// Graphics, and Image Processing, vol. 29, pp. 377-393, 1985.\n// Ported to ImageJ plugin by G.Landini from the the open source project FOURIER 0.8\n// by M. Emre Celebi , Department of Computer Science, Louisiana State University in Shreveport\n// Shreveport, LA 71115, USA\n// http://sourceforge.net/projects/fourier-ipal\n// http://www.lsus.edu/faculty/~ecelebi/fourier.htm\nexport default function moments(histogram, total) {\n  // moments\n  let m0 = 1.0;\n  let m1 = 0.0;\n  let m2 = 0.0;\n  let m3 = 0.0;\n  let sum = 0.0;\n  let p0;\n  let cd, c0, c1, z0, z1; /* auxiliary variables */\n  let threshold = -1;\n  let histogramLength = histogram.length;\n  let normalizedHistogram = new Array(histogramLength);\n  for (let i = 0; i < histogramLength; i++) {\n    normalizedHistogram[i] = histogram[i] / total;\n  }\n  /* Calculate the first, second, and third order moments */\n  for (let i = 0; i < histogramLength; i++) {\n    m1 += i * normalizedHistogram[i];\n    m2 += i * i * normalizedHistogram[i];\n    m3 += i * i * i * normalizedHistogram[i];\n  }\n  /*\n     First 4 moments of the gray-level image should match the first 4 moments\n     of the target binary image. This leads to 4 equalities whose solutions\n     are given in the Appendix of Ref. 1\n     */\n  cd = m0 * m2 - m1 * m1; // determinant of the matriz of hankel for moments 2x2\n  c0 = (-m2 * m2 + m1 * m3) / cd;\n  c1 = (m0 * -m3 + m2 * m1) / cd;\n  // new two gray values where z0<z1\n  z0 = 0.5 * (-c1 - Math.sqrt(c1 * c1 - 4.0 * c0));\n  z1 = 0.5 * (-c1 + Math.sqrt(c1 * c1 - 4.0 * c0));\n  p0 = (z1 - m1) / (z1 - z0); /* Fraction of the object pixels in the target binary image (p0z0+p1z1=m1) */\n  // The threshold is the gray-level closest to the p0-tile of the normalized histogram\n  for (let i = 0; i < histogramLength; i++) {\n    sum += normalizedHistogram[i];\n    if (sum > p0) {\n      threshold = i;\n      break;\n    }\n  }\n  return threshold;\n}","map":{"version":3,"names":["moments","histogram","total","m0","m1","m2","m3","sum","p0","cd","c0","c1","z0","z1","threshold","histogramLength","length","normalizedHistogram","Array","i","Math","sqrt"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/moments.js"],"sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// W. Tsai, \"Moment-preserving thresholding: a new approach,\" Computer Vision,\n// Graphics, and Image Processing, vol. 29, pp. 377-393, 1985.\n// Ported to ImageJ plugin by G.Landini from the the open source project FOURIER 0.8\n// by M. Emre Celebi , Department of Computer Science, Louisiana State University in Shreveport\n// Shreveport, LA 71115, USA\n// http://sourceforge.net/projects/fourier-ipal\n// http://www.lsus.edu/faculty/~ecelebi/fourier.htm\nexport default function moments(histogram, total) {\n  // moments\n  let m0 = 1.0;\n  let m1 = 0.0;\n  let m2 = 0.0;\n  let m3 = 0.0;\n  let sum = 0.0;\n  let p0;\n  let cd, c0, c1, z0, z1; /* auxiliary variables */\n  let threshold = -1;\n  let histogramLength = histogram.length;\n  let normalizedHistogram = new Array(histogramLength);\n  for (let i = 0; i < histogramLength; i++) {\n    normalizedHistogram[i] = histogram[i] / total;\n  }\n  /* Calculate the first, second, and third order moments */\n  for (let i = 0; i < histogramLength; i++) {\n    m1 += i * normalizedHistogram[i];\n    m2 += i * i * normalizedHistogram[i];\n    m3 += i * i * i * normalizedHistogram[i];\n  }\n  /*\n     First 4 moments of the gray-level image should match the first 4 moments\n     of the target binary image. This leads to 4 equalities whose solutions\n     are given in the Appendix of Ref. 1\n     */\n  cd = m0 * m2 - m1 * m1; // determinant of the matriz of hankel for moments 2x2\n  c0 = (-m2 * m2 + m1 * m3) / cd;\n  c1 = (m0 * -m3 + m2 * m1) / cd;\n  // new two gray values where z0<z1\n  z0 = 0.5 * (-c1 - Math.sqrt(c1 * c1 - 4.0 * c0));\n  z1 = 0.5 * (-c1 + Math.sqrt(c1 * c1 - 4.0 * c0));\n  p0 =\n    (z1 - m1) /\n    (z1 -\n      z0); /* Fraction of the object pixels in the target binary image (p0z0+p1z1=m1) */\n  // The threshold is the gray-level closest to the p0-tile of the normalized histogram\n  for (let i = 0; i < histogramLength; i++) {\n    sum += normalizedHistogram[i];\n    if (sum > p0) {\n      threshold = i;\n      break;\n    }\n  }\n  return threshold;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,OAAOA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAChD;EACA,IAAIC,EAAE,GAAG,GAAG;EACZ,IAAIC,EAAE,GAAG,GAAG;EACZ,IAAIC,EAAE,GAAG,GAAG;EACZ,IAAIC,EAAE,GAAG,GAAG;EACZ,IAAIC,GAAG,GAAG,GAAG;EACb,IAAIC,EAAE;EACN,IAAIC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,CAAC;EACxB,IAAIC,SAAS,GAAG,CAAC,CAAC;EAClB,IAAIC,eAAe,GAAGd,SAAS,CAACe,MAAM;EACtC,IAAIC,mBAAmB,GAAG,IAAIC,KAAK,CAACH,eAAe,CAAC;EACpD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,eAAe,EAAEI,CAAC,EAAE,EAAE;IACxCF,mBAAmB,CAACE,CAAC,CAAC,GAAGlB,SAAS,CAACkB,CAAC,CAAC,GAAGjB,KAAK;EAC/C;EACA;EACA,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,eAAe,EAAEI,CAAC,EAAE,EAAE;IACxCf,EAAE,IAAIe,CAAC,GAAGF,mBAAmB,CAACE,CAAC,CAAC;IAChCd,EAAE,IAAIc,CAAC,GAAGA,CAAC,GAAGF,mBAAmB,CAACE,CAAC,CAAC;IACpCb,EAAE,IAAIa,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAGF,mBAAmB,CAACE,CAAC,CAAC;EAC1C;EACA;AACF;AACA;AACA;AACA;EACEV,EAAE,GAAGN,EAAE,GAAGE,EAAE,GAAGD,EAAE,GAAGA,EAAE,CAAC,CAAC;EACxBM,EAAE,GAAG,CAAC,CAACL,EAAE,GAAGA,EAAE,GAAGD,EAAE,GAAGE,EAAE,IAAIG,EAAE;EAC9BE,EAAE,GAAG,CAACR,EAAE,GAAG,CAACG,EAAE,GAAGD,EAAE,GAAGD,EAAE,IAAIK,EAAE;EAC9B;EACAG,EAAE,GAAG,GAAG,IAAI,CAACD,EAAE,GAAGS,IAAI,CAACC,IAAI,CAACV,EAAE,GAAGA,EAAE,GAAG,GAAG,GAAGD,EAAE,CAAC,CAAC;EAChDG,EAAE,GAAG,GAAG,IAAI,CAACF,EAAE,GAAGS,IAAI,CAACC,IAAI,CAACV,EAAE,GAAGA,EAAE,GAAG,GAAG,GAAGD,EAAE,CAAC,CAAC;EAChDF,EAAE,GACA,CAACK,EAAE,GAAGT,EAAE,KACPS,EAAE,GACDD,EAAE,CAAC,CAAC,CAAC;EACT;EACA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,eAAe,EAAEI,CAAC,EAAE,EAAE;IACxCZ,GAAG,IAAIU,mBAAmB,CAACE,CAAC,CAAC;IAC7B,IAAIZ,GAAG,GAAGC,EAAE,EAAE;MACZM,SAAS,GAAGK,CAAC;MACb;IACF;EACF;EACA,OAAOL,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}