{"ast":null,"code":"import { getThreshold as convertThreshold } from '../../../util/converter';\nimport Image from '../../Image';\nimport getThreshold from '../../utility/getThreshold';\nconst THRESHOLD = 'threshold';\n\n/**\n * Creation of binary mask is based on the determination of a threshold\n * You may either choose among the provided algorithm or just specify a threshold value\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {ThresholdAlgorithm|'threshold'} [options.algorithm='threshold']\n * @param {number} [options.threshold=0.5] - If the algorithm is 'threshold' specify here the value (0 to 1).\n * @param {boolean} [options.useAlpha=true] - Apply the alpha channel to determine the intensity of the pixel.\n * @param {boolean} [options.invert=false] - Invert the resulting image\n * @return {Image} - Binary image containing the mask\n */\nexport default function mask(options = {}) {\n  let {\n    algorithm = THRESHOLD,\n    threshold = 0.5,\n    useAlpha = true,\n    invert = false\n  } = options;\n  this.checkProcessable('mask', {\n    components: 1,\n    bitDepth: [8, 16]\n  });\n  if (algorithm === THRESHOLD) {\n    threshold = convertThreshold(threshold, this.maxValue);\n  } else {\n    threshold = getThreshold.call(this, options);\n  }\n  let newImage = new Image(this.width, this.height, {\n    kind: 'BINARY',\n    parent: this\n  });\n  let ptr = 0;\n  if (this.alpha && useAlpha) {\n    for (let i = 0; i < this.data.length; i += this.channels) {\n      let value = this.data[i] + (this.maxValue - this.data[i]) * (this.maxValue - this.data[i + 1]) / this.maxValue;\n      if (invert && value <= threshold || !invert && value >= threshold) {\n        newImage.setBit(ptr);\n      }\n      ptr++;\n    }\n  } else {\n    for (let i = 0; i < this.data.length; i += this.channels) {\n      if (invert && this.data[i] <= threshold || !invert && this.data[i] >= threshold) {\n        newImage.setBit(ptr);\n      }\n      ptr++;\n    }\n  }\n  return newImage;\n}","map":{"version":3,"names":["getThreshold","convertThreshold","Image","THRESHOLD","mask","options","algorithm","threshold","useAlpha","invert","checkProcessable","components","bitDepth","maxValue","call","newImage","width","height","kind","parent","ptr","alpha","i","data","length","channels","value","setBit"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/mask.js"],"sourcesContent":["import { getThreshold as convertThreshold } from '../../../util/converter';\nimport Image from '../../Image';\nimport getThreshold from '../../utility/getThreshold';\n\nconst THRESHOLD = 'threshold';\n\n/**\n * Creation of binary mask is based on the determination of a threshold\n * You may either choose among the provided algorithm or just specify a threshold value\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {ThresholdAlgorithm|'threshold'} [options.algorithm='threshold']\n * @param {number} [options.threshold=0.5] - If the algorithm is 'threshold' specify here the value (0 to 1).\n * @param {boolean} [options.useAlpha=true] - Apply the alpha channel to determine the intensity of the pixel.\n * @param {boolean} [options.invert=false] - Invert the resulting image\n * @return {Image} - Binary image containing the mask\n */\nexport default function mask(options = {}) {\n  let {\n    algorithm = THRESHOLD,\n    threshold = 0.5,\n    useAlpha = true,\n    invert = false,\n  } = options;\n\n  this.checkProcessable('mask', {\n    components: 1,\n    bitDepth: [8, 16],\n  });\n\n  if (algorithm === THRESHOLD) {\n    threshold = convertThreshold(threshold, this.maxValue);\n  } else {\n    threshold = getThreshold.call(this, options);\n  }\n\n  let newImage = new Image(this.width, this.height, {\n    kind: 'BINARY',\n    parent: this,\n  });\n\n  let ptr = 0;\n  if (this.alpha && useAlpha) {\n    for (let i = 0; i < this.data.length; i += this.channels) {\n      let value =\n        this.data[i] +\n        ((this.maxValue - this.data[i]) * (this.maxValue - this.data[i + 1])) /\n          this.maxValue;\n      if ((invert && value <= threshold) || (!invert && value >= threshold)) {\n        newImage.setBit(ptr);\n      }\n      ptr++;\n    }\n  } else {\n    for (let i = 0; i < this.data.length; i += this.channels) {\n      if (\n        (invert && this.data[i] <= threshold) ||\n        (!invert && this.data[i] >= threshold)\n      ) {\n        newImage.setBit(ptr);\n      }\n      ptr++;\n    }\n  }\n\n  return newImage;\n}\n"],"mappings":"AAAA,SAASA,YAAY,IAAIC,gBAAgB,QAAQ,yBAAyB;AAC1E,OAAOC,KAAK,MAAM,aAAa;AAC/B,OAAOF,YAAY,MAAM,4BAA4B;AAErD,MAAMG,SAAS,GAAG,WAAW;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,IAAIA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;EACzC,IAAI;IACFC,SAAS,GAAGH,SAAS;IACrBI,SAAS,GAAG,GAAG;IACfC,QAAQ,GAAG,IAAI;IACfC,MAAM,GAAG;EACX,CAAC,GAAGJ,OAAO;EAEX,IAAI,CAACK,gBAAgB,CAAC,MAAM,EAAE;IAC5BC,UAAU,EAAE,CAAC;IACbC,QAAQ,EAAE,CAAC,CAAC,EAAE,EAAE;EAClB,CAAC,CAAC;EAEF,IAAIN,SAAS,KAAKH,SAAS,EAAE;IAC3BI,SAAS,GAAGN,gBAAgB,CAACM,SAAS,EAAE,IAAI,CAACM,QAAQ,CAAC;EACxD,CAAC,MAAM;IACLN,SAAS,GAAGP,YAAY,CAACc,IAAI,CAAC,IAAI,EAAET,OAAO,CAAC;EAC9C;EAEA,IAAIU,QAAQ,GAAG,IAAIb,KAAK,CAAC,IAAI,CAACc,KAAK,EAAE,IAAI,CAACC,MAAM,EAAE;IAChDC,IAAI,EAAE,QAAQ;IACdC,MAAM,EAAE;EACV,CAAC,CAAC;EAEF,IAAIC,GAAG,GAAG,CAAC;EACX,IAAI,IAAI,CAACC,KAAK,IAAIb,QAAQ,EAAE;IAC1B,KAAK,IAAIc,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACC,IAAI,CAACC,MAAM,EAAEF,CAAC,IAAI,IAAI,CAACG,QAAQ,EAAE;MACxD,IAAIC,KAAK,GACP,IAAI,CAACH,IAAI,CAACD,CAAC,CAAC,GACX,CAAC,IAAI,CAACT,QAAQ,GAAG,IAAI,CAACU,IAAI,CAACD,CAAC,CAAC,KAAK,IAAI,CAACT,QAAQ,GAAG,IAAI,CAACU,IAAI,CAACD,CAAC,GAAG,CAAC,CAAC,CAAC,GAClE,IAAI,CAACT,QAAQ;MACjB,IAAKJ,MAAM,IAAIiB,KAAK,IAAInB,SAAS,IAAM,CAACE,MAAM,IAAIiB,KAAK,IAAInB,SAAU,EAAE;QACrEQ,QAAQ,CAACY,MAAM,CAACP,GAAG,CAAC;MACtB;MACAA,GAAG,EAAE;IACP;EACF,CAAC,MAAM;IACL,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACC,IAAI,CAACC,MAAM,EAAEF,CAAC,IAAI,IAAI,CAACG,QAAQ,EAAE;MACxD,IACGhB,MAAM,IAAI,IAAI,CAACc,IAAI,CAACD,CAAC,CAAC,IAAIf,SAAS,IACnC,CAACE,MAAM,IAAI,IAAI,CAACc,IAAI,CAACD,CAAC,CAAC,IAAIf,SAAU,EACtC;QACAQ,QAAQ,CAACY,MAAM,CAACP,GAAG,CAAC;MACtB;MACAA,GAAG,EAAE;IACP;EACF;EAEA,OAAOL,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}