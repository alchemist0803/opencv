{"ast":null,"code":"import array from 'new-array';\n\n/**\n * This method will change the border\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.size=0]\n * @param {string} [options.algorithm='copy']\n * @param {number[]} [options.color]\n * @return {this}\n */\nexport default function setBorder(options = {}) {\n  let {\n    size = 0,\n    algorithm = 'copy',\n    color\n  } = options;\n  this.checkProcessable('setBorder', {\n    bitDepth: [8, 16, 32, 64]\n  });\n  if (algorithm === 'set') {\n    if (color.length !== this.channels) {\n      throw new Error(`setBorder: the color array must have the same length as the number of channels. Here: ${this.channels}`);\n    }\n    for (let i = 0; i < color.length; i++) {\n      if (color[i] === 0) {\n        color[i] = 0.001;\n      }\n    }\n  } else {\n    color = array(this.channels, null);\n  }\n  if (!Array.isArray(size)) {\n    size = [size, size];\n  }\n  let leftRightSize = size[0];\n  let topBottomSize = size[1];\n  let channels = this.channels;\n  for (let i = leftRightSize; i < this.width - leftRightSize; i++) {\n    for (let k = 0; k < channels; k++) {\n      let value = color[k] || this.data[(i + this.width * topBottomSize) * channels + k];\n      for (let j = 0; j < topBottomSize; j++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n      value = color[k] || this.data[(i + this.width * (this.height - topBottomSize - 1)) * channels + k];\n      for (let j = this.height - topBottomSize; j < this.height; j++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n    }\n  }\n  for (let j = 0; j < this.height; j++) {\n    for (let k = 0; k < channels; k++) {\n      let value = color[k] || this.data[(j * this.width + leftRightSize) * channels + k];\n      for (let i = 0; i < leftRightSize; i++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n      value = color[k] || this.data[(j * this.width + this.width - leftRightSize - 1) * channels + k];\n      for (let i = this.width - leftRightSize; i < this.width; i++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n    }\n  }\n  return this;\n}","map":{"version":3,"names":["array","setBorder","options","size","algorithm","color","checkProcessable","bitDepth","length","channels","Error","i","Array","isArray","leftRightSize","topBottomSize","width","k","value","data","j","height"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/utility/setBorder.js"],"sourcesContent":["import array from 'new-array';\n\n/**\n * This method will change the border\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.size=0]\n * @param {string} [options.algorithm='copy']\n * @param {number[]} [options.color]\n * @return {this}\n */\nexport default function setBorder(options = {}) {\n  let { size = 0, algorithm = 'copy', color } = options;\n\n  this.checkProcessable('setBorder', {\n    bitDepth: [8, 16, 32, 64],\n  });\n\n  if (algorithm === 'set') {\n    if (color.length !== this.channels) {\n      throw new Error(\n        `setBorder: the color array must have the same length as the number of channels. Here: ${this.channels}`,\n      );\n    }\n    for (let i = 0; i < color.length; i++) {\n      if (color[i] === 0) {\n        color[i] = 0.001;\n      }\n    }\n  } else {\n    color = array(this.channels, null);\n  }\n\n  if (!Array.isArray(size)) {\n    size = [size, size];\n  }\n\n  let leftRightSize = size[0];\n  let topBottomSize = size[1];\n  let channels = this.channels;\n\n  for (let i = leftRightSize; i < this.width - leftRightSize; i++) {\n    for (let k = 0; k < channels; k++) {\n      let value =\n        color[k] || this.data[(i + this.width * topBottomSize) * channels + k];\n      for (let j = 0; j < topBottomSize; j++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n      value =\n        color[k] ||\n        this.data[\n          (i + this.width * (this.height - topBottomSize - 1)) * channels + k\n        ];\n      for (let j = this.height - topBottomSize; j < this.height; j++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n    }\n  }\n\n  for (let j = 0; j < this.height; j++) {\n    for (let k = 0; k < channels; k++) {\n      let value =\n        color[k] || this.data[(j * this.width + leftRightSize) * channels + k];\n      for (let i = 0; i < leftRightSize; i++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n      value =\n        color[k] ||\n        this.data[\n          (j * this.width + this.width - leftRightSize - 1) * channels + k\n        ];\n      for (let i = this.width - leftRightSize; i < this.width; i++) {\n        this.data[(j * this.width + i) * channels + k] = value;\n      }\n    }\n  }\n\n  return this;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}