{"ast":null,"code":"/**\n * Finds common parent between two different masks\n * @memberof Image\n * @instance\n * @param {Image} mask - a mask (1 bit image)\n * @return {Image} - the lowest common parent of both masks\n */\nexport default function getClosestCommonParent(mask) {\n  let depthMask1 = getDepth(this);\n  let depthMask2 = getDepth(mask);\n  let furthestParent;\n  if (depthMask1 >= depthMask2) {\n    furthestParent = getFurthestParent(this, depthMask1);\n  } else {\n    furthestParent = getFurthestParent(mask, depthMask2);\n  }\n  if (depthMask1 === 0 || depthMask2 === 0) {\n    // comparing with at least one original image -> no common parent\n    return furthestParent;\n  }\n  let m1 = this;\n  let m2 = mask;\n  while (depthMask1 !== depthMask2) {\n    if (depthMask1 > depthMask2) {\n      m1 = m1.parent;\n      if (m1 === null) {\n        return furthestParent;\n      }\n      depthMask1 = depthMask1 - 1;\n    } else {\n      m2 = m2.parent;\n      if (m2 === null) {\n        return furthestParent;\n      }\n      depthMask2 = depthMask2 - 1;\n    }\n  }\n  while (m1 !== m2 && m1 !== null && m2 !== null) {\n    m1 = m1.parent;\n    m2 = m2.parent;\n    if (m1 === null || m2 === null) {\n      return furthestParent;\n    }\n  }\n\n  // TODO\n  // no common parent, use parent at top of hierarchy of m1\n  // we assume it works for now\n  if (m1 !== m2) {\n    return furthestParent;\n  }\n  return m1;\n}\n\n/**\n * Find the depth of the mask with respect to its arborescence.\n * Helper function to find the common parent between two masks.\n * @param {Image} mask - a mask (1 bit Image)\n * @return {number} - depth of mask\n * @private\n */\nfunction getDepth(mask) {\n  let d = 0;\n  let m = mask;\n  // a null parent means it's the original image\n  while (m.parent != null) {\n    m = m.parent;\n    d++;\n  }\n  return d;\n}\nfunction getFurthestParent(mask, depth) {\n  let m = mask;\n  while (depth > 0) {\n    m = m.parent;\n    depth = depth - 1;\n  }\n  return m;\n}","map":{"version":3,"names":["getClosestCommonParent","mask","depthMask1","getDepth","depthMask2","furthestParent","getFurthestParent","m1","m2","parent","d","m","depth"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/utility/getClosestCommonParent.js"],"sourcesContent":["/**\n * Finds common parent between two different masks\n * @memberof Image\n * @instance\n * @param {Image} mask - a mask (1 bit image)\n * @return {Image} - the lowest common parent of both masks\n */\nexport default function getClosestCommonParent(mask) {\n  let depthMask1 = getDepth(this);\n  let depthMask2 = getDepth(mask);\n\n  let furthestParent;\n  if (depthMask1 >= depthMask2) {\n    furthestParent = getFurthestParent(this, depthMask1);\n  } else {\n    furthestParent = getFurthestParent(mask, depthMask2);\n  }\n\n  if (depthMask1 === 0 || depthMask2 === 0) {\n    // comparing with at least one original image -> no common parent\n    return furthestParent;\n  }\n  let m1 = this;\n  let m2 = mask;\n\n  while (depthMask1 !== depthMask2) {\n    if (depthMask1 > depthMask2) {\n      m1 = m1.parent;\n      if (m1 === null) {\n        return furthestParent;\n      }\n      depthMask1 = depthMask1 - 1;\n    } else {\n      m2 = m2.parent;\n      if (m2 === null) {\n        return furthestParent;\n      }\n      depthMask2 = depthMask2 - 1;\n    }\n  }\n\n  while (m1 !== m2 && m1 !== null && m2 !== null) {\n    m1 = m1.parent;\n    m2 = m2.parent;\n    if (m1 === null || m2 === null) {\n      return furthestParent;\n    }\n  }\n\n  // TODO\n  // no common parent, use parent at top of hierarchy of m1\n  // we assume it works for now\n  if (m1 !== m2) {\n    return furthestParent;\n  }\n\n  return m1;\n}\n\n/**\n * Find the depth of the mask with respect to its arborescence.\n * Helper function to find the common parent between two masks.\n * @param {Image} mask - a mask (1 bit Image)\n * @return {number} - depth of mask\n * @private\n */\nfunction getDepth(mask) {\n  let d = 0;\n  let m = mask;\n  // a null parent means it's the original image\n  while (m.parent != null) {\n    m = m.parent;\n    d++;\n  }\n  return d;\n}\n\nfunction getFurthestParent(mask, depth) {\n  let m = mask;\n  while (depth > 0) {\n    m = m.parent;\n    depth = depth - 1;\n  }\n  return m;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,sBAAsBA,CAACC,IAAI,EAAE;EACnD,IAAIC,UAAU,GAAGC,QAAQ,CAAC,IAAI,CAAC;EAC/B,IAAIC,UAAU,GAAGD,QAAQ,CAACF,IAAI,CAAC;EAE/B,IAAII,cAAc;EAClB,IAAIH,UAAU,IAAIE,UAAU,EAAE;IAC5BC,cAAc,GAAGC,iBAAiB,CAAC,IAAI,EAAEJ,UAAU,CAAC;EACtD,CAAC,MAAM;IACLG,cAAc,GAAGC,iBAAiB,CAACL,IAAI,EAAEG,UAAU,CAAC;EACtD;EAEA,IAAIF,UAAU,KAAK,CAAC,IAAIE,UAAU,KAAK,CAAC,EAAE;IACxC;IACA,OAAOC,cAAc;EACvB;EACA,IAAIE,EAAE,GAAG,IAAI;EACb,IAAIC,EAAE,GAAGP,IAAI;EAEb,OAAOC,UAAU,KAAKE,UAAU,EAAE;IAChC,IAAIF,UAAU,GAAGE,UAAU,EAAE;MAC3BG,EAAE,GAAGA,EAAE,CAACE,MAAM;MACd,IAAIF,EAAE,KAAK,IAAI,EAAE;QACf,OAAOF,cAAc;MACvB;MACAH,UAAU,GAAGA,UAAU,GAAG,CAAC;IAC7B,CAAC,MAAM;MACLM,EAAE,GAAGA,EAAE,CAACC,MAAM;MACd,IAAID,EAAE,KAAK,IAAI,EAAE;QACf,OAAOH,cAAc;MACvB;MACAD,UAAU,GAAGA,UAAU,GAAG,CAAC;IAC7B;EACF;EAEA,OAAOG,EAAE,KAAKC,EAAE,IAAID,EAAE,KAAK,IAAI,IAAIC,EAAE,KAAK,IAAI,EAAE;IAC9CD,EAAE,GAAGA,EAAE,CAACE,MAAM;IACdD,EAAE,GAAGA,EAAE,CAACC,MAAM;IACd,IAAIF,EAAE,KAAK,IAAI,IAAIC,EAAE,KAAK,IAAI,EAAE;MAC9B,OAAOH,cAAc;IACvB;EACF;;EAEA;EACA;EACA;EACA,IAAIE,EAAE,KAAKC,EAAE,EAAE;IACb,OAAOH,cAAc;EACvB;EAEA,OAAOE,EAAE;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASJ,QAAQA,CAACF,IAAI,EAAE;EACtB,IAAIS,CAAC,GAAG,CAAC;EACT,IAAIC,CAAC,GAAGV,IAAI;EACZ;EACA,OAAOU,CAAC,CAACF,MAAM,IAAI,IAAI,EAAE;IACvBE,CAAC,GAAGA,CAAC,CAACF,MAAM;IACZC,CAAC,EAAE;EACL;EACA,OAAOA,CAAC;AACV;AAEA,SAASJ,iBAAiBA,CAACL,IAAI,EAAEW,KAAK,EAAE;EACtC,IAAID,CAAC,GAAGV,IAAI;EACZ,OAAOW,KAAK,GAAG,CAAC,EAAE;IAChBD,CAAC,GAAGA,CAAC,CAACF,MAAM;IACZG,KAAK,GAAGA,KAAK,GAAG,CAAC;EACnB;EACA,OAAOD,CAAC;AACV","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}