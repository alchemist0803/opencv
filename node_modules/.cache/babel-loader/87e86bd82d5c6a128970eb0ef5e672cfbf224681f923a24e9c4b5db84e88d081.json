{"ast":null,"code":"'use strict';\n\n/**\n * @class DisjointSet\n */\nclass DisjointSet {\n  constructor() {\n    this.nodes = new Map();\n  }\n\n  /**\n   * Adds an element as a new set\n   * @param {*} value\n   * @return {DisjointSetNode} Object holding the element\n   */\n  add(value) {\n    var node = this.nodes.get(value);\n    if (!node) {\n      node = new DisjointSetNode(value);\n      this.nodes.set(value, node);\n    }\n    return node;\n  }\n\n  /**\n   * Merges the sets that contain x and y\n   * @param {DisjointSetNode} x\n   * @param {DisjointSetNode} y\n   */\n  union(x, y) {\n    const rootX = this.find(x);\n    const rootY = this.find(y);\n    if (rootX === rootY) {\n      return;\n    }\n    if (rootX.rank < rootY.rank) {\n      rootX.parent = rootY;\n    } else if (rootX.rank > rootY.rank) {\n      rootY.parent = rootX;\n    } else {\n      rootY.parent = rootX;\n      rootX.rank++;\n    }\n  }\n\n  /**\n   * Finds and returns the root node of the set that contains node\n   * @param {DisjointSetNode} node\n   * @return {DisjointSetNode}\n   */\n  find(node) {\n    var rootX = node;\n    while (rootX.parent !== null) {\n      rootX = rootX.parent;\n    }\n    var toUpdateX = node;\n    while (toUpdateX.parent !== null) {\n      var toUpdateParent = toUpdateX;\n      toUpdateX = toUpdateX.parent;\n      toUpdateParent.parent = rootX;\n    }\n    return rootX;\n  }\n\n  /**\n   * Returns true if x and y belong to the same set\n   * @param {DisjointSetNode} x\n   * @param {DisjointSetNode} y\n   */\n  connected(x, y) {\n    return this.find(x) === this.find(y);\n  }\n}\nmodule.exports = DisjointSet;\nfunction DisjointSetNode(value) {\n  this.value = value;\n  this.parent = null;\n  this.rank = 0;\n}","map":{"version":3,"names":["DisjointSet","constructor","nodes","Map","add","value","node","get","DisjointSetNode","set","union","x","y","rootX","find","rootY","rank","parent","toUpdateX","toUpdateParent","connected","module","exports"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/ml-disjoint-set/src/DisjointSet.js"],"sourcesContent":["'use strict';\n\n/**\n * @class DisjointSet\n */\nclass DisjointSet {\n    constructor() {\n        this.nodes = new Map();\n    }\n\n    /**\n     * Adds an element as a new set\n     * @param {*} value\n     * @return {DisjointSetNode} Object holding the element\n     */\n    add(value) {\n        var node = this.nodes.get(value);\n        if (!node) {\n            node = new DisjointSetNode(value);\n            this.nodes.set(value, node);\n        }\n        return node;\n    }\n\n    /**\n     * Merges the sets that contain x and y\n     * @param {DisjointSetNode} x\n     * @param {DisjointSetNode} y\n     */\n    union(x, y) {\n        const rootX = this.find(x);\n        const rootY = this.find(y);\n        if (rootX === rootY) {\n            return;\n        }\n        if (rootX.rank < rootY.rank) {\n            rootX.parent = rootY;\n        } else if (rootX.rank > rootY.rank) {\n            rootY.parent = rootX;\n        } else {\n            rootY.parent = rootX;\n            rootX.rank++;\n        }\n    }\n\n    /**\n     * Finds and returns the root node of the set that contains node\n     * @param {DisjointSetNode} node\n     * @return {DisjointSetNode}\n     */\n    find(node) {\n        var rootX = node;\n        while (rootX.parent !== null) {\n            rootX = rootX.parent;\n        }\n        var toUpdateX = node;\n        while (toUpdateX.parent !== null) {\n            var toUpdateParent = toUpdateX;\n            toUpdateX = toUpdateX.parent;\n            toUpdateParent.parent = rootX;\n        }\n        return rootX;\n    }\n\n    /**\n     * Returns true if x and y belong to the same set\n     * @param {DisjointSetNode} x\n     * @param {DisjointSetNode} y\n     */\n    connected(x, y) {\n        return this.find(x) === this.find(y);\n    }\n}\n\nmodule.exports = DisjointSet;\n\nfunction DisjointSetNode(value) {\n    this.value = value;\n    this.parent = null;\n    this.rank = 0;\n}\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA,MAAMA,WAAW,CAAC;EACdC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC1B;;EAEA;AACJ;AACA;AACA;AACA;EACIC,GAAGA,CAACC,KAAK,EAAE;IACP,IAAIC,IAAI,GAAG,IAAI,CAACJ,KAAK,CAACK,GAAG,CAACF,KAAK,CAAC;IAChC,IAAI,CAACC,IAAI,EAAE;MACPA,IAAI,GAAG,IAAIE,eAAe,CAACH,KAAK,CAAC;MACjC,IAAI,CAACH,KAAK,CAACO,GAAG,CAACJ,KAAK,EAAEC,IAAI,CAAC;IAC/B;IACA,OAAOA,IAAI;EACf;;EAEA;AACJ;AACA;AACA;AACA;EACII,KAAKA,CAACC,CAAC,EAAEC,CAAC,EAAE;IACR,MAAMC,KAAK,GAAG,IAAI,CAACC,IAAI,CAACH,CAAC,CAAC;IAC1B,MAAMI,KAAK,GAAG,IAAI,CAACD,IAAI,CAACF,CAAC,CAAC;IAC1B,IAAIC,KAAK,KAAKE,KAAK,EAAE;MACjB;IACJ;IACA,IAAIF,KAAK,CAACG,IAAI,GAAGD,KAAK,CAACC,IAAI,EAAE;MACzBH,KAAK,CAACI,MAAM,GAAGF,KAAK;IACxB,CAAC,MAAM,IAAIF,KAAK,CAACG,IAAI,GAAGD,KAAK,CAACC,IAAI,EAAE;MAChCD,KAAK,CAACE,MAAM,GAAGJ,KAAK;IACxB,CAAC,MAAM;MACHE,KAAK,CAACE,MAAM,GAAGJ,KAAK;MACpBA,KAAK,CAACG,IAAI,EAAE;IAChB;EACJ;;EAEA;AACJ;AACA;AACA;AACA;EACIF,IAAIA,CAACR,IAAI,EAAE;IACP,IAAIO,KAAK,GAAGP,IAAI;IAChB,OAAOO,KAAK,CAACI,MAAM,KAAK,IAAI,EAAE;MAC1BJ,KAAK,GAAGA,KAAK,CAACI,MAAM;IACxB;IACA,IAAIC,SAAS,GAAGZ,IAAI;IACpB,OAAOY,SAAS,CAACD,MAAM,KAAK,IAAI,EAAE;MAC9B,IAAIE,cAAc,GAAGD,SAAS;MAC9BA,SAAS,GAAGA,SAAS,CAACD,MAAM;MAC5BE,cAAc,CAACF,MAAM,GAAGJ,KAAK;IACjC;IACA,OAAOA,KAAK;EAChB;;EAEA;AACJ;AACA;AACA;AACA;EACIO,SAASA,CAACT,CAAC,EAAEC,CAAC,EAAE;IACZ,OAAO,IAAI,CAACE,IAAI,CAACH,CAAC,CAAC,KAAK,IAAI,CAACG,IAAI,CAACF,CAAC,CAAC;EACxC;AACJ;AAEAS,MAAM,CAACC,OAAO,GAAGtB,WAAW;AAE5B,SAASQ,eAAeA,CAACH,KAAK,EAAE;EAC5B,IAAI,CAACA,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACY,MAAM,GAAG,IAAI;EAClB,IAAI,CAACD,IAAI,GAAG,CAAC;AACjB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}