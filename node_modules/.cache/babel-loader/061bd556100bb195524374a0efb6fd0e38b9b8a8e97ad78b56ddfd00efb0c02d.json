{"ast":null,"code":"import { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n\n/**\n * Calculate a new image that is the hypotenuse between the current image and the otherImage.\n * @memberof Image\n * @instance\n * @param {Image} otherImage\n * @param {object} [options={}]\n * @param {number} [options.bitDepth=this.bitDepth]\n * @param {number[]|string[]} [options.channels] : to which channel to apply the filter. By default all but alpha.\n * @return {Image}\n */\nexport default function hypotenuse(otherImage, options = {}) {\n  let {\n    bitDepth = this.bitDepth,\n    channels\n  } = options;\n  this.checkProcessable('hypotenuse', {\n    bitDepth: [8, 16, 32]\n  });\n  if (this.width !== otherImage.width || this.height !== otherImage.height) {\n    throw new Error('hypotenuse: both images must have the same size');\n  }\n  if (this.alpha !== otherImage.alpha || this.bitDepth !== otherImage.bitDepth) {\n    throw new Error('hypotenuse: both images must have the same alpha and bitDepth');\n  }\n  if (this.channels !== otherImage.channels) {\n    throw new Error('hypotenuse: both images must have the same number of channels');\n  }\n  let newImage = Image.createFrom(this, {\n    bitDepth: bitDepth\n  });\n  channels = validateArrayOfChannels(this, {\n    channels: channels\n  });\n  let clamped = newImage.isClamped;\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n    for (let i = c; i < this.data.length; i += this.channels) {\n      let value = Math.hypot(this.data[i], otherImage.data[i]);\n      if (clamped) {\n        // we calculate the clamped result\n        newImage.data[i] = Math.min(Math.max(Math.round(value), 0), newImage.maxValue);\n      } else {\n        newImage.data[i] = value;\n      }\n    }\n  }\n  return newImage;\n}","map":{"version":3,"names":["validateArrayOfChannels","Image","hypotenuse","otherImage","options","bitDepth","channels","checkProcessable","width","height","Error","alpha","newImage","createFrom","clamped","isClamped","j","length","c","i","data","value","Math","hypot","min","max","round","maxValue"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/filter/hypotenuse.js"],"sourcesContent":["import { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n\n/**\n * Calculate a new image that is the hypotenuse between the current image and the otherImage.\n * @memberof Image\n * @instance\n * @param {Image} otherImage\n * @param {object} [options={}]\n * @param {number} [options.bitDepth=this.bitDepth]\n * @param {number[]|string[]} [options.channels] : to which channel to apply the filter. By default all but alpha.\n * @return {Image}\n */\nexport default function hypotenuse(otherImage, options = {}) {\n  let { bitDepth = this.bitDepth, channels } = options;\n  this.checkProcessable('hypotenuse', {\n    bitDepth: [8, 16, 32],\n  });\n  if (this.width !== otherImage.width || this.height !== otherImage.height) {\n    throw new Error('hypotenuse: both images must have the same size');\n  }\n  if (\n    this.alpha !== otherImage.alpha ||\n    this.bitDepth !== otherImage.bitDepth\n  ) {\n    throw new Error(\n      'hypotenuse: both images must have the same alpha and bitDepth',\n    );\n  }\n  if (this.channels !== otherImage.channels) {\n    throw new Error(\n      'hypotenuse: both images must have the same number of channels',\n    );\n  }\n\n  let newImage = Image.createFrom(this, { bitDepth: bitDepth });\n\n  channels = validateArrayOfChannels(this, { channels: channels });\n\n  let clamped = newImage.isClamped;\n\n  for (let j = 0; j < channels.length; j++) {\n    let c = channels[j];\n    for (let i = c; i < this.data.length; i += this.channels) {\n      let value = Math.hypot(this.data[i], otherImage.data[i]);\n      if (clamped) {\n        // we calculate the clamped result\n        newImage.data[i] = Math.min(\n          Math.max(Math.round(value), 0),\n          newImage.maxValue,\n        );\n      } else {\n        newImage.data[i] = value;\n      }\n    }\n  }\n\n  return newImage;\n}\n"],"mappings":"AAAA,SAASA,uBAAuB,QAAQ,oBAAoB;AAC5D,OAAOC,KAAK,MAAM,UAAU;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,UAAUA,CAACC,UAAU,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC3D,IAAI;IAAEC,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAAEC;EAAS,CAAC,GAAGF,OAAO;EACpD,IAAI,CAACG,gBAAgB,CAAC,YAAY,EAAE;IAClCF,QAAQ,EAAE,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE;EACtB,CAAC,CAAC;EACF,IAAI,IAAI,CAACG,KAAK,KAAKL,UAAU,CAACK,KAAK,IAAI,IAAI,CAACC,MAAM,KAAKN,UAAU,CAACM,MAAM,EAAE;IACxE,MAAM,IAAIC,KAAK,CAAC,iDAAiD,CAAC;EACpE;EACA,IACE,IAAI,CAACC,KAAK,KAAKR,UAAU,CAACQ,KAAK,IAC/B,IAAI,CAACN,QAAQ,KAAKF,UAAU,CAACE,QAAQ,EACrC;IACA,MAAM,IAAIK,KAAK,CACb,+DACF,CAAC;EACH;EACA,IAAI,IAAI,CAACJ,QAAQ,KAAKH,UAAU,CAACG,QAAQ,EAAE;IACzC,MAAM,IAAII,KAAK,CACb,+DACF,CAAC;EACH;EAEA,IAAIE,QAAQ,GAAGX,KAAK,CAACY,UAAU,CAAC,IAAI,EAAE;IAAER,QAAQ,EAAEA;EAAS,CAAC,CAAC;EAE7DC,QAAQ,GAAGN,uBAAuB,CAAC,IAAI,EAAE;IAAEM,QAAQ,EAAEA;EAAS,CAAC,CAAC;EAEhE,IAAIQ,OAAO,GAAGF,QAAQ,CAACG,SAAS;EAEhC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,QAAQ,CAACW,MAAM,EAAED,CAAC,EAAE,EAAE;IACxC,IAAIE,CAAC,GAAGZ,QAAQ,CAACU,CAAC,CAAC;IACnB,KAAK,IAAIG,CAAC,GAAGD,CAAC,EAAEC,CAAC,GAAG,IAAI,CAACC,IAAI,CAACH,MAAM,EAAEE,CAAC,IAAI,IAAI,CAACb,QAAQ,EAAE;MACxD,IAAIe,KAAK,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACH,IAAI,CAACD,CAAC,CAAC,EAAEhB,UAAU,CAACiB,IAAI,CAACD,CAAC,CAAC,CAAC;MACxD,IAAIL,OAAO,EAAE;QACX;QACAF,QAAQ,CAACQ,IAAI,CAACD,CAAC,CAAC,GAAGG,IAAI,CAACE,GAAG,CACzBF,IAAI,CAACG,GAAG,CAACH,IAAI,CAACI,KAAK,CAACL,KAAK,CAAC,EAAE,CAAC,CAAC,EAC9BT,QAAQ,CAACe,QACX,CAAC;MACH,CAAC,MAAM;QACLf,QAAQ,CAACQ,IAAI,CAACD,CAAC,CAAC,GAAGE,KAAK;MAC1B;IACF;EACF;EAEA,OAAOT,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}