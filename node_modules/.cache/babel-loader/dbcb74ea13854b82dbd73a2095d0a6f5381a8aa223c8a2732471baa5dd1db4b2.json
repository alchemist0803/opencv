{"ast":null,"code":"'use strict';\n\nconst IOBuffer = require('iobuffer');\nconst IFD = require('./ifd');\nconst TiffIFD = require('./tiffIfd');\nconst IFDValue = require('./ifdValue');\nconst defaultOptions = {\n  ignoreImageData: false,\n  onlyFirst: false\n};\nclass TIFFDecoder extends IOBuffer {\n  constructor(data, options) {\n    super(data, options);\n    this._nextIFD = 0;\n  }\n  decode(options) {\n    options = Object.assign({}, defaultOptions, options);\n    const result = [];\n    this.decodeHeader();\n    while (this._nextIFD) {\n      result.push(this.decodeIFD(options));\n      if (options.onlyFirst) {\n        return result[0];\n      }\n    }\n    return result;\n  }\n  decodeHeader() {\n    // Byte offset\n    let value = this.readUint16();\n    if (value === 0x4949) {\n      this.setLittleEndian();\n    } else if (value === 0x4D4D) {\n      this.setBigEndian();\n    } else {\n      throw new Error('invalid byte order: 0x' + value.toString(16));\n    }\n\n    // Magic number\n    value = this.readUint16();\n    if (value !== 42) {\n      throw new Error('not a TIFF file');\n    }\n\n    // Offset of the first IFD\n    this._nextIFD = this.readUint32();\n  }\n  decodeIFD(options) {\n    this.seek(this._nextIFD);\n    var ifd;\n    if (!options.kind) {\n      ifd = new TiffIFD();\n    } else {\n      ifd = new IFD(options.kind);\n    }\n    const numEntries = this.readUint16();\n    for (var i = 0; i < numEntries; i++) {\n      this.decodeIFDEntry(ifd);\n    }\n    if (!options.ignoreImageData) {\n      this.decodeImageData(ifd);\n    }\n    this._nextIFD = this.readUint32();\n    return ifd;\n  }\n  decodeIFDEntry(ifd) {\n    const offset = this.offset;\n    const tag = this.readUint16();\n    const type = this.readUint16();\n    const numValues = this.readUint32();\n    if (type < 1 || type > 12) {\n      this.skip(4); // unknown type, skip this value\n      return;\n    }\n    const valueByteLength = IFDValue.getByteLength(type, numValues);\n    if (valueByteLength > 4) {\n      this.seek(this.readUint32());\n    }\n    const value = IFDValue.readData(this, type, numValues);\n    ifd.fields.set(tag, value);\n\n    // Read sub-IFDs\n    if (tag === 0x8769 || tag === 0x8825) {\n      let currentOffset = this.offset;\n      let kind;\n      if (tag === 0x8769) {\n        kind = 'exif';\n      } else if (tag === 0x8825) {\n        kind = 'gps';\n      }\n      this._nextIFD = value;\n      ifd[kind] = this.decodeIFD({\n        kind,\n        ignoreImageData: true\n      });\n      this.offset = currentOffset;\n    }\n\n    // go to the next entry\n    this.seek(offset);\n    this.skip(12);\n  }\n  decodeImageData(ifd) {\n    const orientation = ifd.orientation;\n    if (orientation && orientation !== 1) {\n      unsupported('orientation', orientation);\n    }\n    switch (ifd.type) {\n      case 1: // BlackIsZero\n      case 2:\n        // RGB\n        this.readStripData(ifd);\n        break;\n      default:\n        unsupported('image type', ifd.type);\n        break;\n    }\n  }\n  readStripData(ifd) {\n    const width = ifd.width;\n    const height = ifd.height;\n    const bitDepth = validateBitDepth(ifd.bitsPerSample);\n    const sampleFormat = ifd.sampleFormat;\n    let size = width * height;\n    const data = getDataArray(size, 1, bitDepth, sampleFormat);\n    const compression = ifd.compression;\n    const rowsPerStrip = ifd.rowsPerStrip;\n    const maxPixels = rowsPerStrip * width;\n    const stripOffsets = ifd.stripOffsets;\n    const stripByteCounts = ifd.stripByteCounts;\n    var pixel = 0;\n    for (var i = 0; i < stripOffsets.length; i++) {\n      var stripData = this.getStripData(compression, stripOffsets[i], stripByteCounts[i]);\n      // Last strip can be smaller\n      var length = size > maxPixels ? maxPixels : size;\n      size -= length;\n      if (bitDepth === 8) {\n        pixel = fill8bit(data, stripData, pixel, length);\n      } else if (bitDepth === 16) {\n        pixel = fill16bit(data, stripData, pixel, length, this.isLittleEndian());\n      } else if (bitDepth === 32 && sampleFormat === 3) {\n        pixel = fillFloat32(data, stripData, pixel, length, this.isLittleEndian());\n      } else {\n        unsupported('bitDepth', bitDepth);\n      }\n    }\n    ifd.data = data;\n  }\n  getStripData(compression, offset, byteCounts) {\n    switch (compression) {\n      case 1:\n        // No compression\n        return new DataView(this.buffer, offset, byteCounts);\n      case 2: // CCITT Group 3 1-Dimensional Modified Huffman run length encoding\n      case 32773:\n        // PackBits compression\n        return unsupported('Compression', compression);\n      default:\n        throw new Error('invalid compression: ' + compression);\n    }\n  }\n}\nmodule.exports = TIFFDecoder;\nfunction getDataArray(size, channels, bitDepth, sampleFormat) {\n  if (bitDepth === 8) {\n    return new Uint8Array(size * channels);\n  } else if (bitDepth === 16) {\n    return new Uint16Array(size * channels);\n  } else if (bitDepth === 32 && sampleFormat === 3) {\n    return new Float32Array(size * channels);\n  } else {\n    return unsupported('bit depth / sample format', bitDepth + ' / ' + sampleFormat);\n  }\n}\nfunction fill8bit(dataTo, dataFrom, index, length) {\n  for (var i = 0; i < length; i++) {\n    dataTo[index++] = dataFrom.getUint8(i);\n  }\n  return index;\n}\nfunction fill16bit(dataTo, dataFrom, index, length, littleEndian) {\n  for (var i = 0; i < length * 2; i += 2) {\n    dataTo[index++] = dataFrom.getUint16(i, littleEndian);\n  }\n  return index;\n}\nfunction fillFloat32(dataTo, dataFrom, index, length, littleEndian) {\n  for (var i = 0; i < length * 4; i += 4) {\n    dataTo[index++] = dataFrom.getFloat32(i, littleEndian);\n  }\n  return index;\n}\nfunction unsupported(type, value) {\n  throw new Error('Unsupported ' + type + ': ' + value);\n}\nfunction validateBitDepth(bitDepth) {\n  if (bitDepth.length) {\n    const bitDepthArray = bitDepth;\n    bitDepth = bitDepthArray[0];\n    for (var i = 0; i < bitDepthArray.length; i++) {\n      if (bitDepthArray[i] !== bitDepth) {\n        unsupported('bit depth', bitDepthArray);\n      }\n    }\n  }\n  return bitDepth;\n}","map":{"version":3,"names":["IOBuffer","require","IFD","TiffIFD","IFDValue","defaultOptions","ignoreImageData","onlyFirst","TIFFDecoder","constructor","data","options","_nextIFD","decode","Object","assign","result","decodeHeader","push","decodeIFD","value","readUint16","setLittleEndian","setBigEndian","Error","toString","readUint32","seek","ifd","kind","numEntries","i","decodeIFDEntry","decodeImageData","offset","tag","type","numValues","skip","valueByteLength","getByteLength","readData","fields","set","currentOffset","orientation","unsupported","readStripData","width","height","bitDepth","validateBitDepth","bitsPerSample","sampleFormat","size","getDataArray","compression","rowsPerStrip","maxPixels","stripOffsets","stripByteCounts","pixel","length","stripData","getStripData","fill8bit","fill16bit","isLittleEndian","fillFloat32","byteCounts","DataView","buffer","module","exports","channels","Uint8Array","Uint16Array","Float32Array","dataTo","dataFrom","index","getUint8","littleEndian","getUint16","getFloat32","bitDepthArray"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/fast-jpeg/node_modules/tiff/src/tiffDecoder.js"],"sourcesContent":["'use strict';\n\nconst IOBuffer = require('iobuffer');\nconst IFD = require('./ifd');\nconst TiffIFD = require('./tiffIfd');\nconst IFDValue = require('./ifdValue');\n\nconst defaultOptions = {\n    ignoreImageData: false,\n    onlyFirst: false\n};\n\nclass TIFFDecoder extends IOBuffer {\n    constructor(data, options) {\n        super(data, options);\n        this._nextIFD = 0;\n    }\n\n    decode(options) {\n        options = Object.assign({}, defaultOptions, options);\n        const result = [];\n        this.decodeHeader();\n        while (this._nextIFD) {\n            result.push(this.decodeIFD(options));\n            if (options.onlyFirst) {\n                return result[0];\n            }\n        }\n        return result;\n    }\n\n    decodeHeader() {\n        // Byte offset\n        let value = this.readUint16();\n        if (value === 0x4949) {\n            this.setLittleEndian();\n        } else if (value === 0x4D4D) {\n            this.setBigEndian();\n        } else {\n            throw new Error('invalid byte order: 0x' + value.toString(16));\n        }\n\n        // Magic number\n        value = this.readUint16();\n        if (value !== 42) {\n            throw new Error('not a TIFF file');\n        }\n\n        // Offset of the first IFD\n        this._nextIFD = this.readUint32();\n    }\n\n    decodeIFD(options) {\n        this.seek(this._nextIFD);\n\n        var ifd;\n        if (!options.kind) {\n            ifd = new TiffIFD();\n        } else {\n            ifd = new IFD(options.kind);\n        }\n\n        const numEntries = this.readUint16();\n        for (var i = 0; i < numEntries; i++) {\n            this.decodeIFDEntry(ifd);\n        }\n        if (!options.ignoreImageData) {\n            this.decodeImageData(ifd);\n        }\n        this._nextIFD = this.readUint32();\n        return ifd;\n    }\n\n    decodeIFDEntry(ifd) {\n        const offset = this.offset;\n        const tag = this.readUint16();\n        const type = this.readUint16();\n        const numValues = this.readUint32();\n\n        if (type < 1 || type > 12) {\n            this.skip(4); // unknown type, skip this value\n            return;\n        }\n\n        const valueByteLength = IFDValue.getByteLength(type, numValues);\n        if (valueByteLength > 4) {\n            this.seek(this.readUint32());\n        }\n\n        const value = IFDValue.readData(this, type, numValues);\n        ifd.fields.set(tag, value);\n\n        // Read sub-IFDs\n        if (tag === 0x8769 || tag === 0x8825) {\n            let currentOffset = this.offset;\n            let kind;\n            if (tag === 0x8769) {\n                kind = 'exif';\n            } else if (tag === 0x8825) {\n                kind = 'gps';\n            }\n            this._nextIFD = value;\n            ifd[kind] = this.decodeIFD({\n                kind,\n                ignoreImageData: true\n            });\n            this.offset = currentOffset;\n        }\n\n        // go to the next entry\n        this.seek(offset);\n        this.skip(12);\n    }\n\n    decodeImageData(ifd) {\n        const orientation = ifd.orientation;\n        if (orientation && orientation !== 1) {\n            unsupported('orientation', orientation);\n        }\n        switch (ifd.type) {\n            case 1: // BlackIsZero\n            case 2: // RGB\n                this.readStripData(ifd);\n                break;\n            default:\n                unsupported('image type', ifd.type);\n                break;\n        }\n    }\n\n    readStripData(ifd) {\n        const width = ifd.width;\n        const height = ifd.height;\n\n        const bitDepth = validateBitDepth(ifd.bitsPerSample);\n        const sampleFormat = ifd.sampleFormat;\n        let size = width * height;\n        const data = getDataArray(size, 1, bitDepth, sampleFormat);\n\n        const compression = ifd.compression;\n        const rowsPerStrip = ifd.rowsPerStrip;\n        const maxPixels = rowsPerStrip * width;\n        const stripOffsets = ifd.stripOffsets;\n        const stripByteCounts = ifd.stripByteCounts;\n\n        var pixel = 0;\n        for (var i = 0; i < stripOffsets.length; i++) {\n            var stripData = this.getStripData(compression, stripOffsets[i], stripByteCounts[i]);\n            // Last strip can be smaller\n            var length = size > maxPixels ? maxPixels : size;\n            size -= length;\n            if (bitDepth === 8) {\n                pixel = fill8bit(data, stripData, pixel, length);\n            } else if (bitDepth === 16) {\n                pixel = fill16bit(data, stripData, pixel, length, this.isLittleEndian());\n            } else if (bitDepth === 32 && sampleFormat === 3) {\n                pixel = fillFloat32(data, stripData, pixel, length, this.isLittleEndian());\n            } else {\n                unsupported('bitDepth', bitDepth);\n            }\n        }\n\n        ifd.data = data;\n    }\n\n    getStripData(compression, offset, byteCounts) {\n        switch (compression) {\n            case 1: // No compression\n                return new DataView(this.buffer, offset, byteCounts);\n            case 2: // CCITT Group 3 1-Dimensional Modified Huffman run length encoding\n            case 32773: // PackBits compression\n                return unsupported('Compression', compression);\n            default:\n                throw new Error('invalid compression: ' + compression);\n        }\n    }\n}\n\nmodule.exports = TIFFDecoder;\n\nfunction getDataArray(size, channels, bitDepth, sampleFormat) {\n    if (bitDepth === 8) {\n        return new Uint8Array(size * channels);\n    } else if (bitDepth === 16) {\n        return new Uint16Array(size * channels);\n    } else if (bitDepth === 32 && sampleFormat === 3) {\n        return new Float32Array(size * channels);\n    } else {\n        return unsupported('bit depth / sample format', bitDepth + ' / ' + sampleFormat);\n    }\n}\n\nfunction fill8bit(dataTo, dataFrom, index, length) {\n    for (var i = 0; i < length; i++) {\n        dataTo[index++] = dataFrom.getUint8(i);\n    }\n    return index;\n}\n\nfunction fill16bit(dataTo, dataFrom, index, length, littleEndian) {\n    for (var i = 0; i < length * 2; i += 2) {\n        dataTo[index++] = dataFrom.getUint16(i, littleEndian);\n    }\n    return index;\n}\n\nfunction fillFloat32(dataTo, dataFrom, index, length, littleEndian) {\n    for (var i = 0; i < length * 4; i += 4) {\n        dataTo[index++] = dataFrom.getFloat32(i, littleEndian);\n    }\n    return index;\n}\n\nfunction unsupported(type, value) {\n    throw new Error('Unsupported ' + type + ': ' + value);\n}\n\nfunction validateBitDepth(bitDepth) {\n    if (bitDepth.length) {\n        const bitDepthArray = bitDepth;\n        bitDepth = bitDepthArray[0];\n        for (var i = 0; i < bitDepthArray.length; i++) {\n            if (bitDepthArray[i] !== bitDepth) {\n                unsupported('bit depth', bitDepthArray);\n            }\n        }\n    }\n    return bitDepth;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}