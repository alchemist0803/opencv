{"ast":null,"code":"import Shape from '../../util/Shape';\nimport { getColors } from '../../util/color';\n\n/**\n * Paint pixels on the current image.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>|string}     [options.color] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {boolean}             [options.randomColors=true] - To paint each mask with a random color if color and colors are undefined\n * @param {boolean}             [options.distinctColors=false] - To paint each mask with a different color if color and colors are undefined\n * @param {object} [options.shape] - Definition of the shape, see Shape contructor.\n * @return {this} The original painted image\n */\nexport default function paintPoints(points, options = {}) {\n  let {\n    shape\n  } = options;\n  this.checkProcessable('paintPoints', {\n    bitDepth: [8, 16]\n  });\n  let colors = getColors(Object.assign({}, options, {\n    numberColors: points.length\n  }));\n  let shapePixels = new Shape(shape).getPoints();\n  let numberChannels = Math.min(this.channels, colors[0].length);\n  for (let i = 0; i < points.length; i++) {\n    let color = colors[i % colors.length];\n    let xP = points[i][0];\n    let yP = points[i][1];\n    for (let j = 0; j < shapePixels.length; j++) {\n      let xS = shapePixels[j][0];\n      let yS = shapePixels[j][1];\n      if (xP + xS >= 0 && yP + yS >= 0 && xP + xS < this.width && yP + yS < this.height) {\n        let position = (xP + xS + (yP + yS) * this.width) * this.channels;\n        for (let channel = 0; channel < numberChannels; channel++) {\n          this.data[position + channel] = color[channel];\n        }\n      }\n    }\n  }\n  return this;\n}","map":{"version":3,"names":["Shape","getColors","paintPoints","points","options","shape","checkProcessable","bitDepth","colors","Object","assign","numberColors","length","shapePixels","getPoints","numberChannels","Math","min","channels","i","color","xP","yP","j","xS","yS","width","height","position","channel","data"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/operator/paintPoints.js"],"sourcesContent":["import Shape from '../../util/Shape';\nimport { getColors } from '../../util/color';\n\n/**\n * Paint pixels on the current image.\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} points - Array of [x,y] points\n * @param {object} [options]\n * @param {Array<number>|string}     [options.color] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each mask\n * @param {boolean}             [options.randomColors=true] - To paint each mask with a random color if color and colors are undefined\n * @param {boolean}             [options.distinctColors=false] - To paint each mask with a different color if color and colors are undefined\n * @param {object} [options.shape] - Definition of the shape, see Shape contructor.\n * @return {this} The original painted image\n */\nexport default function paintPoints(points, options = {}) {\n  let { shape } = options;\n\n  this.checkProcessable('paintPoints', {\n    bitDepth: [8, 16],\n  });\n\n  let colors = getColors(\n    Object.assign({}, options, { numberColors: points.length }),\n  );\n\n  let shapePixels = new Shape(shape).getPoints();\n\n  let numberChannels = Math.min(this.channels, colors[0].length);\n\n  for (let i = 0; i < points.length; i++) {\n    let color = colors[i % colors.length];\n    let xP = points[i][0];\n    let yP = points[i][1];\n    for (let j = 0; j < shapePixels.length; j++) {\n      let xS = shapePixels[j][0];\n      let yS = shapePixels[j][1];\n      if (\n        xP + xS >= 0 &&\n        yP + yS >= 0 &&\n        xP + xS < this.width &&\n        yP + yS < this.height\n      ) {\n        let position = (xP + xS + (yP + yS) * this.width) * this.channels;\n        for (let channel = 0; channel < numberChannels; channel++) {\n          this.data[position + channel] = color[channel];\n        }\n      }\n    }\n  }\n\n  return this;\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,kBAAkB;AACpC,SAASC,SAAS,QAAQ,kBAAkB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,WAAWA,CAACC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACxD,IAAI;IAAEC;EAAM,CAAC,GAAGD,OAAO;EAEvB,IAAI,CAACE,gBAAgB,CAAC,aAAa,EAAE;IACnCC,QAAQ,EAAE,CAAC,CAAC,EAAE,EAAE;EAClB,CAAC,CAAC;EAEF,IAAIC,MAAM,GAAGP,SAAS,CACpBQ,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEN,OAAO,EAAE;IAAEO,YAAY,EAAER,MAAM,CAACS;EAAO,CAAC,CAC5D,CAAC;EAED,IAAIC,WAAW,GAAG,IAAIb,KAAK,CAACK,KAAK,CAAC,CAACS,SAAS,CAAC,CAAC;EAE9C,IAAIC,cAAc,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACC,QAAQ,EAAEV,MAAM,CAAC,CAAC,CAAC,CAACI,MAAM,CAAC;EAE9D,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,MAAM,CAACS,MAAM,EAAEO,CAAC,EAAE,EAAE;IACtC,IAAIC,KAAK,GAAGZ,MAAM,CAACW,CAAC,GAAGX,MAAM,CAACI,MAAM,CAAC;IACrC,IAAIS,EAAE,GAAGlB,MAAM,CAACgB,CAAC,CAAC,CAAC,CAAC,CAAC;IACrB,IAAIG,EAAE,GAAGnB,MAAM,CAACgB,CAAC,CAAC,CAAC,CAAC,CAAC;IACrB,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,WAAW,CAACD,MAAM,EAAEW,CAAC,EAAE,EAAE;MAC3C,IAAIC,EAAE,GAAGX,WAAW,CAACU,CAAC,CAAC,CAAC,CAAC,CAAC;MAC1B,IAAIE,EAAE,GAAGZ,WAAW,CAACU,CAAC,CAAC,CAAC,CAAC,CAAC;MAC1B,IACEF,EAAE,GAAGG,EAAE,IAAI,CAAC,IACZF,EAAE,GAAGG,EAAE,IAAI,CAAC,IACZJ,EAAE,GAAGG,EAAE,GAAG,IAAI,CAACE,KAAK,IACpBJ,EAAE,GAAGG,EAAE,GAAG,IAAI,CAACE,MAAM,EACrB;QACA,IAAIC,QAAQ,GAAG,CAACP,EAAE,GAAGG,EAAE,GAAG,CAACF,EAAE,GAAGG,EAAE,IAAI,IAAI,CAACC,KAAK,IAAI,IAAI,CAACR,QAAQ;QACjE,KAAK,IAAIW,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAGd,cAAc,EAAEc,OAAO,EAAE,EAAE;UACzD,IAAI,CAACC,IAAI,CAACF,QAAQ,GAAGC,OAAO,CAAC,GAAGT,KAAK,CAACS,OAAO,CAAC;QAChD;MACF;IACF;EACF;EAEA,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}