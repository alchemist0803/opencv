{"ast":null,"code":"import { direct, fft } from 'ml-matrix-convolution';\nimport { validateArrayOfChannels } from '../../util/channel';\nimport { validateKernel } from '../../util/kernel';\nimport Image from '../Image';\nimport { clamp } from '../internal/clamp';\nimport convolutionSeparable from './convolutionSeparable';\nimport getSeparatedKernel from './getSeparatedKernel';\n\n/**\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} kernel\n * @param {object} [options] - options\n * @param {Array} [options.channels] - Array of channels to treat. Defaults to all channels\n * @param {number} [options.bitDepth=this.bitDepth] - A new bit depth can be specified. This allows to use 32 bits to avoid clamping of floating-point numbers.\n * @param {boolean} [options.normalize=false]\n * @param {number} [options.divisor=1]\n * @param {string} [options.border='copy']\n * @param {string} [options.algorithm='auto'] - Either 'auto', 'direct', 'fft' or 'separable'. fft is much faster for large kernel.\n * If the separable algorithm is used, one must provide as kernel an array of two 1D kernels.\n * The 'auto' option will try to separate the kernel if that is possible.\n * @return {Image}\n */\nexport default function convolution(kernel, options = {}) {\n  let {\n    channels,\n    bitDepth,\n    normalize = false,\n    divisor = 1,\n    border = 'copy',\n    algorithm = 'auto'\n  } = options;\n  let createOptions = {};\n  if (bitDepth) createOptions.bitDepth = bitDepth;\n  let newImage = Image.createFrom(this, createOptions);\n  channels = validateArrayOfChannels(this, channels, true);\n  if (algorithm !== 'separable') {\n    ({\n      kernel\n    } = validateKernel(kernel));\n  } else if (!Array.isArray(kernel) || kernel.length !== 2) {\n    throw new RangeError('separable convolution requires two arrays of numbers to represent the kernel');\n  }\n  if (algorithm === 'auto') {\n    let separatedKernel = getSeparatedKernel(kernel);\n    if (separatedKernel !== null) {\n      algorithm = 'separable';\n      kernel = separatedKernel;\n    } else if ((kernel.length > 9 || kernel[0].length > 9) && this.width <= 4096 && this.height <= 4096) {\n      algorithm = 'fft';\n    } else {\n      algorithm = 'direct';\n    }\n  }\n  let halfHeight, halfWidth;\n  if (algorithm === 'separable') {\n    halfHeight = Math.floor(kernel[0].length / 2);\n    halfWidth = Math.floor(kernel[1].length / 2);\n  } else {\n    halfHeight = Math.floor(kernel.length / 2);\n    halfWidth = Math.floor(kernel[0].length / 2);\n  }\n  let clamped = newImage.isClamped;\n  let tmpData = new Array(this.height * this.width);\n  let index, x, y, channel, c, tmpResult;\n  for (channel = 0; channel < channels.length; channel++) {\n    c = channels[channel];\n    // Copy the channel in a single array\n    for (y = 0; y < this.height; y++) {\n      for (x = 0; x < this.width; x++) {\n        index = y * this.width + x;\n        tmpData[index] = this.data[index * this.channels + c];\n      }\n    }\n    if (algorithm === 'direct') {\n      tmpResult = direct(tmpData, kernel, {\n        rows: this.height,\n        cols: this.width,\n        normalize: normalize,\n        divisor: divisor\n      });\n    } else if (algorithm === 'separable') {\n      tmpResult = convolutionSeparable(tmpData, kernel, this.width, this.height);\n      if (normalize) {\n        divisor = 0;\n        for (let i = 0; i < kernel[0].length; i++) {\n          for (let j = 0; j < kernel[1].length; j++) {\n            divisor += kernel[0][i] * kernel[1][j];\n          }\n        }\n      }\n      if (divisor !== 1) {\n        for (let i = 0; i < tmpResult.length; i++) {\n          tmpResult[i] /= divisor;\n        }\n      }\n    } else {\n      tmpResult = fft(tmpData, kernel, {\n        rows: this.height,\n        cols: this.width,\n        normalize: normalize,\n        divisor: divisor\n      });\n    }\n\n    // Copy the result to the output image\n    for (y = 0; y < this.height; y++) {\n      for (x = 0; x < this.width; x++) {\n        index = y * this.width + x;\n        if (clamped) {\n          newImage.data[index * this.channels + c] = clamp(tmpResult[index], newImage);\n        } else {\n          newImage.data[index * this.channels + c] = tmpResult[index];\n        }\n      }\n    }\n  }\n  // if the kernel was not applied on the alpha channel we just copy it\n  // TODO: in general we should copy the channels that where not changed\n  // TODO: probably we should just copy the image at the beginning ?\n  if (this.alpha && !channels.includes(this.channels)) {\n    for (x = this.components; x < this.data.length; x = x + this.channels) {\n      newImage.data[x] = this.data[x];\n    }\n  }\n\n  // I only can have 3 types of borders:\n  //  1. Considering the image as periodic: periodic\n  //  2. Extend the interior borders: copy\n  //  3. fill with a color: set\n  if (border !== 'periodic') {\n    newImage.setBorder({\n      size: [halfWidth, halfHeight],\n      algorithm: border\n    });\n  }\n  return newImage;\n}","map":{"version":3,"names":["direct","fft","validateArrayOfChannels","validateKernel","Image","clamp","convolutionSeparable","getSeparatedKernel","convolution","kernel","options","channels","bitDepth","normalize","divisor","border","algorithm","createOptions","newImage","createFrom","Array","isArray","length","RangeError","separatedKernel","width","height","halfHeight","halfWidth","Math","floor","clamped","isClamped","tmpData","index","x","y","channel","c","tmpResult","data","rows","cols","i","j","alpha","includes","components","setBorder","size"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/operator/convolution.js"],"sourcesContent":["import { direct, fft } from 'ml-matrix-convolution';\n\nimport { validateArrayOfChannels } from '../../util/channel';\nimport { validateKernel } from '../../util/kernel';\nimport Image from '../Image';\nimport { clamp } from '../internal/clamp';\n\nimport convolutionSeparable from './convolutionSeparable';\nimport getSeparatedKernel from './getSeparatedKernel';\n\n/**\n * @memberof Image\n * @instance\n * @param {Array<Array<number>>} kernel\n * @param {object} [options] - options\n * @param {Array} [options.channels] - Array of channels to treat. Defaults to all channels\n * @param {number} [options.bitDepth=this.bitDepth] - A new bit depth can be specified. This allows to use 32 bits to avoid clamping of floating-point numbers.\n * @param {boolean} [options.normalize=false]\n * @param {number} [options.divisor=1]\n * @param {string} [options.border='copy']\n * @param {string} [options.algorithm='auto'] - Either 'auto', 'direct', 'fft' or 'separable'. fft is much faster for large kernel.\n * If the separable algorithm is used, one must provide as kernel an array of two 1D kernels.\n * The 'auto' option will try to separate the kernel if that is possible.\n * @return {Image}\n */\nexport default function convolution(kernel, options = {}) {\n  let {\n    channels,\n    bitDepth,\n    normalize = false,\n    divisor = 1,\n    border = 'copy',\n    algorithm = 'auto',\n  } = options;\n  let createOptions = {};\n  if (bitDepth) createOptions.bitDepth = bitDepth;\n  let newImage = Image.createFrom(this, createOptions);\n\n  channels = validateArrayOfChannels(this, channels, true);\n\n  if (algorithm !== 'separable') {\n    ({ kernel } = validateKernel(kernel));\n  } else if (!Array.isArray(kernel) || kernel.length !== 2) {\n    throw new RangeError(\n      'separable convolution requires two arrays of numbers to represent the kernel',\n    );\n  }\n\n  if (algorithm === 'auto') {\n    let separatedKernel = getSeparatedKernel(kernel);\n    if (separatedKernel !== null) {\n      algorithm = 'separable';\n      kernel = separatedKernel;\n    } else if (\n      (kernel.length > 9 || kernel[0].length > 9) &&\n      this.width <= 4096 &&\n      this.height <= 4096\n    ) {\n      algorithm = 'fft';\n    } else {\n      algorithm = 'direct';\n    }\n  }\n\n  let halfHeight, halfWidth;\n  if (algorithm === 'separable') {\n    halfHeight = Math.floor(kernel[0].length / 2);\n    halfWidth = Math.floor(kernel[1].length / 2);\n  } else {\n    halfHeight = Math.floor(kernel.length / 2);\n    halfWidth = Math.floor(kernel[0].length / 2);\n  }\n  let clamped = newImage.isClamped;\n\n  let tmpData = new Array(this.height * this.width);\n  let index, x, y, channel, c, tmpResult;\n  for (channel = 0; channel < channels.length; channel++) {\n    c = channels[channel];\n    // Copy the channel in a single array\n    for (y = 0; y < this.height; y++) {\n      for (x = 0; x < this.width; x++) {\n        index = y * this.width + x;\n        tmpData[index] = this.data[index * this.channels + c];\n      }\n    }\n    if (algorithm === 'direct') {\n      tmpResult = direct(tmpData, kernel, {\n        rows: this.height,\n        cols: this.width,\n        normalize: normalize,\n        divisor: divisor,\n      });\n    } else if (algorithm === 'separable') {\n      tmpResult = convolutionSeparable(\n        tmpData,\n        kernel,\n        this.width,\n        this.height,\n      );\n      if (normalize) {\n        divisor = 0;\n        for (let i = 0; i < kernel[0].length; i++) {\n          for (let j = 0; j < kernel[1].length; j++) {\n            divisor += kernel[0][i] * kernel[1][j];\n          }\n        }\n      }\n      if (divisor !== 1) {\n        for (let i = 0; i < tmpResult.length; i++) {\n          tmpResult[i] /= divisor;\n        }\n      }\n    } else {\n      tmpResult = fft(tmpData, kernel, {\n        rows: this.height,\n        cols: this.width,\n        normalize: normalize,\n        divisor: divisor,\n      });\n    }\n\n    // Copy the result to the output image\n    for (y = 0; y < this.height; y++) {\n      for (x = 0; x < this.width; x++) {\n        index = y * this.width + x;\n        if (clamped) {\n          newImage.data[index * this.channels + c] = clamp(\n            tmpResult[index],\n            newImage,\n          );\n        } else {\n          newImage.data[index * this.channels + c] = tmpResult[index];\n        }\n      }\n    }\n  }\n  // if the kernel was not applied on the alpha channel we just copy it\n  // TODO: in general we should copy the channels that where not changed\n  // TODO: probably we should just copy the image at the beginning ?\n  if (this.alpha && !channels.includes(this.channels)) {\n    for (x = this.components; x < this.data.length; x = x + this.channels) {\n      newImage.data[x] = this.data[x];\n    }\n  }\n\n  // I only can have 3 types of borders:\n  //  1. Considering the image as periodic: periodic\n  //  2. Extend the interior borders: copy\n  //  3. fill with a color: set\n  if (border !== 'periodic') {\n    newImage.setBorder({ size: [halfWidth, halfHeight], algorithm: border });\n  }\n\n  return newImage;\n}\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,GAAG,QAAQ,uBAAuB;AAEnD,SAASC,uBAAuB,QAAQ,oBAAoB;AAC5D,SAASC,cAAc,QAAQ,mBAAmB;AAClD,OAAOC,KAAK,MAAM,UAAU;AAC5B,SAASC,KAAK,QAAQ,mBAAmB;AAEzC,OAAOC,oBAAoB,MAAM,wBAAwB;AACzD,OAAOC,kBAAkB,MAAM,sBAAsB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,WAAWA,CAACC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACxD,IAAI;IACFC,QAAQ;IACRC,QAAQ;IACRC,SAAS,GAAG,KAAK;IACjBC,OAAO,GAAG,CAAC;IACXC,MAAM,GAAG,MAAM;IACfC,SAAS,GAAG;EACd,CAAC,GAAGN,OAAO;EACX,IAAIO,aAAa,GAAG,CAAC,CAAC;EACtB,IAAIL,QAAQ,EAAEK,aAAa,CAACL,QAAQ,GAAGA,QAAQ;EAC/C,IAAIM,QAAQ,GAAGd,KAAK,CAACe,UAAU,CAAC,IAAI,EAAEF,aAAa,CAAC;EAEpDN,QAAQ,GAAGT,uBAAuB,CAAC,IAAI,EAAES,QAAQ,EAAE,IAAI,CAAC;EAExD,IAAIK,SAAS,KAAK,WAAW,EAAE;IAC7B,CAAC;MAAEP;IAAO,CAAC,GAAGN,cAAc,CAACM,MAAM,CAAC;EACtC,CAAC,MAAM,IAAI,CAACW,KAAK,CAACC,OAAO,CAACZ,MAAM,CAAC,IAAIA,MAAM,CAACa,MAAM,KAAK,CAAC,EAAE;IACxD,MAAM,IAAIC,UAAU,CAClB,8EACF,CAAC;EACH;EAEA,IAAIP,SAAS,KAAK,MAAM,EAAE;IACxB,IAAIQ,eAAe,GAAGjB,kBAAkB,CAACE,MAAM,CAAC;IAChD,IAAIe,eAAe,KAAK,IAAI,EAAE;MAC5BR,SAAS,GAAG,WAAW;MACvBP,MAAM,GAAGe,eAAe;IAC1B,CAAC,MAAM,IACL,CAACf,MAAM,CAACa,MAAM,GAAG,CAAC,IAAIb,MAAM,CAAC,CAAC,CAAC,CAACa,MAAM,GAAG,CAAC,KAC1C,IAAI,CAACG,KAAK,IAAI,IAAI,IAClB,IAAI,CAACC,MAAM,IAAI,IAAI,EACnB;MACAV,SAAS,GAAG,KAAK;IACnB,CAAC,MAAM;MACLA,SAAS,GAAG,QAAQ;IACtB;EACF;EAEA,IAAIW,UAAU,EAAEC,SAAS;EACzB,IAAIZ,SAAS,KAAK,WAAW,EAAE;IAC7BW,UAAU,GAAGE,IAAI,CAACC,KAAK,CAACrB,MAAM,CAAC,CAAC,CAAC,CAACa,MAAM,GAAG,CAAC,CAAC;IAC7CM,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACrB,MAAM,CAAC,CAAC,CAAC,CAACa,MAAM,GAAG,CAAC,CAAC;EAC9C,CAAC,MAAM;IACLK,UAAU,GAAGE,IAAI,CAACC,KAAK,CAACrB,MAAM,CAACa,MAAM,GAAG,CAAC,CAAC;IAC1CM,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACrB,MAAM,CAAC,CAAC,CAAC,CAACa,MAAM,GAAG,CAAC,CAAC;EAC9C;EACA,IAAIS,OAAO,GAAGb,QAAQ,CAACc,SAAS;EAEhC,IAAIC,OAAO,GAAG,IAAIb,KAAK,CAAC,IAAI,CAACM,MAAM,GAAG,IAAI,CAACD,KAAK,CAAC;EACjD,IAAIS,KAAK,EAAEC,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEC,CAAC,EAAEC,SAAS;EACtC,KAAKF,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG1B,QAAQ,CAACW,MAAM,EAAEe,OAAO,EAAE,EAAE;IACtDC,CAAC,GAAG3B,QAAQ,CAAC0B,OAAO,CAAC;IACrB;IACA,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACV,MAAM,EAAEU,CAAC,EAAE,EAAE;MAChC,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACV,KAAK,EAAEU,CAAC,EAAE,EAAE;QAC/BD,KAAK,GAAGE,CAAC,GAAG,IAAI,CAACX,KAAK,GAAGU,CAAC;QAC1BF,OAAO,CAACC,KAAK,CAAC,GAAG,IAAI,CAACM,IAAI,CAACN,KAAK,GAAG,IAAI,CAACvB,QAAQ,GAAG2B,CAAC,CAAC;MACvD;IACF;IACA,IAAItB,SAAS,KAAK,QAAQ,EAAE;MAC1BuB,SAAS,GAAGvC,MAAM,CAACiC,OAAO,EAAExB,MAAM,EAAE;QAClCgC,IAAI,EAAE,IAAI,CAACf,MAAM;QACjBgB,IAAI,EAAE,IAAI,CAACjB,KAAK;QAChBZ,SAAS,EAAEA,SAAS;QACpBC,OAAO,EAAEA;MACX,CAAC,CAAC;IACJ,CAAC,MAAM,IAAIE,SAAS,KAAK,WAAW,EAAE;MACpCuB,SAAS,GAAGjC,oBAAoB,CAC9B2B,OAAO,EACPxB,MAAM,EACN,IAAI,CAACgB,KAAK,EACV,IAAI,CAACC,MACP,CAAC;MACD,IAAIb,SAAS,EAAE;QACbC,OAAO,GAAG,CAAC;QACX,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlC,MAAM,CAAC,CAAC,CAAC,CAACa,MAAM,EAAEqB,CAAC,EAAE,EAAE;UACzC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnC,MAAM,CAAC,CAAC,CAAC,CAACa,MAAM,EAAEsB,CAAC,EAAE,EAAE;YACzC9B,OAAO,IAAIL,MAAM,CAAC,CAAC,CAAC,CAACkC,CAAC,CAAC,GAAGlC,MAAM,CAAC,CAAC,CAAC,CAACmC,CAAC,CAAC;UACxC;QACF;MACF;MACA,IAAI9B,OAAO,KAAK,CAAC,EAAE;QACjB,KAAK,IAAI6B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,SAAS,CAACjB,MAAM,EAAEqB,CAAC,EAAE,EAAE;UACzCJ,SAAS,CAACI,CAAC,CAAC,IAAI7B,OAAO;QACzB;MACF;IACF,CAAC,MAAM;MACLyB,SAAS,GAAGtC,GAAG,CAACgC,OAAO,EAAExB,MAAM,EAAE;QAC/BgC,IAAI,EAAE,IAAI,CAACf,MAAM;QACjBgB,IAAI,EAAE,IAAI,CAACjB,KAAK;QAChBZ,SAAS,EAAEA,SAAS;QACpBC,OAAO,EAAEA;MACX,CAAC,CAAC;IACJ;;IAEA;IACA,KAAKsB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACV,MAAM,EAAEU,CAAC,EAAE,EAAE;MAChC,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACV,KAAK,EAAEU,CAAC,EAAE,EAAE;QAC/BD,KAAK,GAAGE,CAAC,GAAG,IAAI,CAACX,KAAK,GAAGU,CAAC;QAC1B,IAAIJ,OAAO,EAAE;UACXb,QAAQ,CAACsB,IAAI,CAACN,KAAK,GAAG,IAAI,CAACvB,QAAQ,GAAG2B,CAAC,CAAC,GAAGjC,KAAK,CAC9CkC,SAAS,CAACL,KAAK,CAAC,EAChBhB,QACF,CAAC;QACH,CAAC,MAAM;UACLA,QAAQ,CAACsB,IAAI,CAACN,KAAK,GAAG,IAAI,CAACvB,QAAQ,GAAG2B,CAAC,CAAC,GAAGC,SAAS,CAACL,KAAK,CAAC;QAC7D;MACF;IACF;EACF;EACA;EACA;EACA;EACA,IAAI,IAAI,CAACW,KAAK,IAAI,CAAClC,QAAQ,CAACmC,QAAQ,CAAC,IAAI,CAACnC,QAAQ,CAAC,EAAE;IACnD,KAAKwB,CAAC,GAAG,IAAI,CAACY,UAAU,EAAEZ,CAAC,GAAG,IAAI,CAACK,IAAI,CAAClB,MAAM,EAAEa,CAAC,GAAGA,CAAC,GAAG,IAAI,CAACxB,QAAQ,EAAE;MACrEO,QAAQ,CAACsB,IAAI,CAACL,CAAC,CAAC,GAAG,IAAI,CAACK,IAAI,CAACL,CAAC,CAAC;IACjC;EACF;;EAEA;EACA;EACA;EACA;EACA,IAAIpB,MAAM,KAAK,UAAU,EAAE;IACzBG,QAAQ,CAAC8B,SAAS,CAAC;MAAEC,IAAI,EAAE,CAACrB,SAAS,EAAED,UAAU,CAAC;MAAEX,SAAS,EAAED;IAAO,CAAC,CAAC;EAC1E;EAEA,OAAOG,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}