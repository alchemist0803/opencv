{"ast":null,"code":"import isInteger from 'is-integer';\nimport newArray from 'new-array';\n\n/**\n * Returns a histogram for the specified channel\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.maxSlots=256]\n * @param {number} [options.channel]\n * @param {boolean} [options.useAlpha=true]\n * @return {number[]}\n */\nexport function getHistogram(options = {}) {\n  let {\n    maxSlots = 256,\n    channel,\n    useAlpha = true\n  } = options;\n  this.checkProcessable('getHistogram', {\n    bitDepth: [1, 8, 16]\n  });\n  if (channel === undefined) {\n    if (this.components > 1) {\n      throw new RangeError('You need to define the channel for an image that contains more than one channel');\n    }\n    channel = 0;\n  }\n  return getChannelHistogram.call(this, channel, {\n    useAlpha,\n    maxSlots\n  });\n}\n\n/**\n * Returns an array (number of channels) of array (number of slots) containing\n * the number of data of a specific intensity.\n * Intensity may be grouped by the maxSlots parameter.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.maxSlots] - Number of slots in the resulting\n *      array. The intensity will be evently distributed between 0 and\n *      the maxValue allowed for this image (255 for usual images).\n *      If maxSlots = 8, all the intensities between 0 and 31 will be\n *      placed in the slot 0, 32 to 63 in slot 1, ...\n * @return {Array<Array<number>>}\n * @example\n *      image.getHistograms({\n *          maxSlots: 8,\n *          useAlpha: false\n *      });\n */\nexport function getHistograms(options = {}) {\n  const {\n    maxSlots = 256,\n    useAlpha = true\n  } = options;\n  this.checkProcessable('getHistograms', {\n    bitDepth: [8, 16]\n  });\n  let results = new Array(useAlpha ? this.components : this.channels);\n  for (let i = 0; i < results.length; i++) {\n    results[i] = getChannelHistogram.call(this, i, {\n      useAlpha,\n      maxSlots\n    });\n  }\n  return results;\n}\nfunction getChannelHistogram(channel, options) {\n  let {\n    useAlpha,\n    maxSlots\n  } = options;\n\n  // for a mask, return a number array containing count of black and white points (black = array[0], white = array[1])\n\n  if (this.bitDepth === 1) {\n    let blackWhiteCount = [0, 0];\n    for (let i = 0; i < this.height; i++) {\n      for (let j = 0; j < this.width; j++) {\n        let value = this.getBitXY(i, j);\n        if (value === 0) {\n          blackWhiteCount[0] += 1;\n        } else if (value === 1) {\n          blackWhiteCount[1] += 1;\n        }\n      }\n    }\n    return blackWhiteCount;\n  }\n  let bitSlots = Math.log2(maxSlots);\n  if (!isInteger(bitSlots)) {\n    throw new RangeError('maxSlots must be a power of 2, for example: 64, 256, 1024');\n  }\n  // we will compare the bitSlots to the bitDepth of the image\n  // based on this we will shift the values. This allows to generate a histogram\n  // of 16 grey even if the images has 256 shade of grey\n\n  let bitShift = 0;\n  if (this.bitDepth > bitSlots) {\n    bitShift = this.bitDepth - bitSlots;\n  }\n  let data = this.data;\n  let result = newArray(Math.pow(2, Math.min(this.bitDepth, bitSlots)), 0);\n  if (useAlpha && this.alpha) {\n    let alphaChannelDiff = this.channels - channel - 1;\n    for (let i = channel; i < data.length; i += this.channels) {\n      result[data[i] >> bitShift] += data[i + alphaChannelDiff] / this.maxValue;\n    }\n  } else {\n    for (let i = channel; i < data.length; i += this.channels) {\n      result[data[i] >> bitShift]++;\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["isInteger","newArray","getHistogram","options","maxSlots","channel","useAlpha","checkProcessable","bitDepth","undefined","components","RangeError","getChannelHistogram","call","getHistograms","results","Array","channels","i","length","blackWhiteCount","height","j","width","value","getBitXY","bitSlots","Math","log2","bitShift","data","result","pow","min","alpha","alphaChannelDiff","maxValue"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/compute/histogram.js"],"sourcesContent":["import isInteger from 'is-integer';\nimport newArray from 'new-array';\n\n/**\n * Returns a histogram for the specified channel\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.maxSlots=256]\n * @param {number} [options.channel]\n * @param {boolean} [options.useAlpha=true]\n * @return {number[]}\n */\nexport function getHistogram(options = {}) {\n  let { maxSlots = 256, channel, useAlpha = true } = options;\n  this.checkProcessable('getHistogram', {\n    bitDepth: [1, 8, 16],\n  });\n  if (channel === undefined) {\n    if (this.components > 1) {\n      throw new RangeError(\n        'You need to define the channel for an image that contains more than one channel',\n      );\n    }\n    channel = 0;\n  }\n  return getChannelHistogram.call(this, channel, { useAlpha, maxSlots });\n}\n\n/**\n * Returns an array (number of channels) of array (number of slots) containing\n * the number of data of a specific intensity.\n * Intensity may be grouped by the maxSlots parameter.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.maxSlots] - Number of slots in the resulting\n *      array. The intensity will be evently distributed between 0 and\n *      the maxValue allowed for this image (255 for usual images).\n *      If maxSlots = 8, all the intensities between 0 and 31 will be\n *      placed in the slot 0, 32 to 63 in slot 1, ...\n * @return {Array<Array<number>>}\n * @example\n *      image.getHistograms({\n *          maxSlots: 8,\n *          useAlpha: false\n *      });\n */\nexport function getHistograms(options = {}) {\n  const { maxSlots = 256, useAlpha = true } = options;\n  this.checkProcessable('getHistograms', {\n    bitDepth: [8, 16],\n  });\n  let results = new Array(useAlpha ? this.components : this.channels);\n  for (let i = 0; i < results.length; i++) {\n    results[i] = getChannelHistogram.call(this, i, { useAlpha, maxSlots });\n  }\n  return results;\n}\n\nfunction getChannelHistogram(channel, options) {\n  let { useAlpha, maxSlots } = options;\n\n  // for a mask, return a number array containing count of black and white points (black = array[0], white = array[1])\n\n  if (this.bitDepth === 1) {\n    let blackWhiteCount = [0, 0];\n    for (let i = 0; i < this.height; i++) {\n      for (let j = 0; j < this.width; j++) {\n        let value = this.getBitXY(i, j);\n        if (value === 0) {\n          blackWhiteCount[0] += 1;\n        } else if (value === 1) {\n          blackWhiteCount[1] += 1;\n        }\n      }\n    }\n    return blackWhiteCount;\n  }\n\n  let bitSlots = Math.log2(maxSlots);\n  if (!isInteger(bitSlots)) {\n    throw new RangeError(\n      'maxSlots must be a power of 2, for example: 64, 256, 1024',\n    );\n  }\n  // we will compare the bitSlots to the bitDepth of the image\n  // based on this we will shift the values. This allows to generate a histogram\n  // of 16 grey even if the images has 256 shade of grey\n\n  let bitShift = 0;\n  if (this.bitDepth > bitSlots) {\n    bitShift = this.bitDepth - bitSlots;\n  }\n\n  let data = this.data;\n  let result = newArray(Math.pow(2, Math.min(this.bitDepth, bitSlots)), 0);\n  if (useAlpha && this.alpha) {\n    let alphaChannelDiff = this.channels - channel - 1;\n\n    for (let i = channel; i < data.length; i += this.channels) {\n      result[data[i] >> bitShift] += data[i + alphaChannelDiff] / this.maxValue;\n    }\n  } else {\n    for (let i = channel; i < data.length; i += this.channels) {\n      result[data[i] >> bitShift]++;\n    }\n  }\n\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}