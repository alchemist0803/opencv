{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\nimport { pngSignature, crc } from './common';\nimport { ColorType, CompressionMethod, FilterMethod, InterlaceMethod } from './internalTypes';\nconst defaultZlibOptions = {\n  level: 3\n};\nexport default class PngEncoder extends IOBuffer {\n  constructor(data, options = {}) {\n    super();\n    this._colorType = ColorType.UNKNOWN;\n    this._zlibOptions = {\n      ...defaultZlibOptions,\n      ...options.zlib\n    };\n    this._png = this._checkData(data);\n    this.setBigEndian();\n  }\n  encode() {\n    this.encodeSignature();\n    this.encodeIHDR();\n    this.encodeData();\n    this.encodeIEND();\n    return this.toArray();\n  }\n  // https://www.w3.org/TR/PNG/#5PNG-file-signature\n  encodeSignature() {\n    this.writeBytes(pngSignature);\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  encodeIHDR() {\n    this.writeUint32(13);\n    this.writeChars('IHDR');\n    this.writeUint32(this._png.width);\n    this.writeUint32(this._png.height);\n    this.writeByte(this._png.depth);\n    this.writeByte(this._colorType);\n    this.writeByte(CompressionMethod.DEFLATE);\n    this.writeByte(FilterMethod.ADAPTIVE);\n    this.writeByte(InterlaceMethod.NO_INTERLACE);\n    this.writeCrc(17);\n  }\n  // https://www.w3.org/TR/PNG/#11IEND\n  encodeIEND() {\n    this.writeUint32(0);\n    this.writeChars('IEND');\n    this.writeCrc(4);\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  encodeIDAT(data) {\n    this.writeUint32(data.length);\n    this.writeChars('IDAT');\n    this.writeBytes(data);\n    this.writeCrc(data.length + 4);\n  }\n  encodeData() {\n    const {\n      width,\n      height,\n      channels,\n      depth,\n      data\n    } = this._png;\n    const slotsPerLine = channels * width;\n    const newData = new IOBuffer().setBigEndian();\n    let offset = 0;\n    for (let i = 0; i < height; i++) {\n      newData.writeByte(0); // no filter\n      /* istanbul ignore else */\n      if (depth === 8) {\n        offset = writeDataBytes(data, newData, slotsPerLine, offset);\n      } else if (depth === 16) {\n        offset = writeDataUint16(data, newData, slotsPerLine, offset);\n      } else {\n        throw new Error('unreachable');\n      }\n    }\n    const buffer = newData.toArray();\n    const compressed = deflate(buffer, this._zlibOptions);\n    this.encodeIDAT(compressed);\n  }\n  _checkData(data) {\n    const {\n      colorType,\n      channels,\n      depth\n    } = getColorType(data);\n    const png = {\n      width: checkInteger(data.width, 'width'),\n      height: checkInteger(data.height, 'height'),\n      channels,\n      data: data.data,\n      depth,\n      text: {}\n    };\n    this._colorType = colorType;\n    const expectedSize = png.width * png.height * channels;\n    if (png.data.length !== expectedSize) {\n      throw new RangeError(`wrong data size. Found ${png.data.length}, expected ${expectedSize}`);\n    }\n    return png;\n  }\n  writeCrc(length) {\n    this.writeUint32(crc(new Uint8Array(this.buffer, this.byteOffset + this.offset - length, length), length));\n  }\n}\nfunction checkInteger(value, name) {\n  if (Number.isInteger(value) && value > 0) {\n    return value;\n  }\n  throw new TypeError(`${name} must be a positive integer`);\n}\nfunction getColorType(data) {\n  const {\n    channels = 4,\n    depth = 8\n  } = data;\n  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n    throw new RangeError(`unsupported number of channels: ${channels}`);\n  }\n  if (depth !== 8 && depth !== 16) {\n    throw new RangeError(`unsupported bit depth: ${depth}`);\n  }\n  const returnValue = {\n    channels,\n    depth,\n    colorType: ColorType.UNKNOWN\n  };\n  switch (channels) {\n    case 4:\n      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n      break;\n    case 3:\n      returnValue.colorType = ColorType.TRUECOLOUR;\n      break;\n    case 1:\n      returnValue.colorType = ColorType.GREYSCALE;\n      break;\n    case 2:\n      returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n      break;\n    default:\n      throw new Error('unsupported number of channels');\n  }\n  return returnValue;\n}\nfunction writeDataBytes(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeByte(data[offset++]);\n  }\n  return offset;\n}\nfunction writeDataUint16(data, newData, slotsPerLine, offset) {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeUint16(data[offset++]);\n  }\n  return offset;\n}","map":{"version":3,"names":["IOBuffer","deflate","pngSignature","crc","ColorType","CompressionMethod","FilterMethod","InterlaceMethod","defaultZlibOptions","level","PngEncoder","constructor","data","options","_colorType","UNKNOWN","_zlibOptions","zlib","_png","_checkData","setBigEndian","encode","encodeSignature","encodeIHDR","encodeData","encodeIEND","toArray","writeBytes","writeUint32","writeChars","width","height","writeByte","depth","DEFLATE","ADAPTIVE","NO_INTERLACE","writeCrc","encodeIDAT","length","channels","slotsPerLine","newData","offset","i","writeDataBytes","writeDataUint16","Error","buffer","compressed","colorType","getColorType","png","checkInteger","text","expectedSize","RangeError","Uint8Array","byteOffset","value","name","Number","isInteger","TypeError","returnValue","TRUECOLOUR_ALPHA","TRUECOLOUR","GREYSCALE","GREYSCALE_ALPHA","j","writeUint16"],"sources":["C:\\Users\\Admin\\Documents\\Workspace\\opencv\\opencv\\node_modules\\fast-png\\src\\PngEncoder.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\nimport { deflate } from 'pako';\n\nimport { pngSignature, crc } from './common';\nimport {\n  ColorType,\n  CompressionMethod,\n  FilterMethod,\n  InterlaceMethod,\n} from './internalTypes';\nimport {\n  DeflateFunctionOptions,\n  PngEncoderOptions,\n  ImageData,\n  DecodedPng,\n  PngDataArray,\n  BitDepth,\n} from './types';\n\nconst defaultZlibOptions: DeflateFunctionOptions = {\n  level: 3,\n};\n\nexport default class PngEncoder extends IOBuffer {\n  private _png: DecodedPng;\n  private _zlibOptions: DeflateFunctionOptions;\n  private _colorType: ColorType;\n\n  public constructor(data: ImageData, options: PngEncoderOptions = {}) {\n    super();\n    this._colorType = ColorType.UNKNOWN;\n    this._zlibOptions = { ...defaultZlibOptions, ...options.zlib };\n    this._png = this._checkData(data);\n    this.setBigEndian();\n  }\n\n  public encode(): Uint8Array {\n    this.encodeSignature();\n    this.encodeIHDR();\n    this.encodeData();\n    this.encodeIEND();\n    return this.toArray();\n  }\n\n  // https://www.w3.org/TR/PNG/#5PNG-file-signature\n  private encodeSignature(): void {\n    this.writeBytes(pngSignature);\n  }\n\n  // https://www.w3.org/TR/PNG/#11IHDR\n  private encodeIHDR(): void {\n    this.writeUint32(13);\n\n    this.writeChars('IHDR');\n\n    this.writeUint32(this._png.width);\n    this.writeUint32(this._png.height);\n    this.writeByte(this._png.depth);\n    this.writeByte(this._colorType);\n    this.writeByte(CompressionMethod.DEFLATE);\n    this.writeByte(FilterMethod.ADAPTIVE);\n    this.writeByte(InterlaceMethod.NO_INTERLACE);\n\n    this.writeCrc(17);\n  }\n\n  // https://www.w3.org/TR/PNG/#11IEND\n  private encodeIEND(): void {\n    this.writeUint32(0);\n\n    this.writeChars('IEND');\n\n    this.writeCrc(4);\n  }\n\n  // https://www.w3.org/TR/PNG/#11IDAT\n  private encodeIDAT(data: PngDataArray): void {\n    this.writeUint32(data.length);\n\n    this.writeChars('IDAT');\n\n    this.writeBytes(data);\n\n    this.writeCrc(data.length + 4);\n  }\n\n  private encodeData(): void {\n    const { width, height, channels, depth, data } = this._png;\n    const slotsPerLine = channels * width;\n    const newData = new IOBuffer().setBigEndian();\n    let offset = 0;\n    for (let i = 0; i < height; i++) {\n      newData.writeByte(0); // no filter\n      /* istanbul ignore else */\n      if (depth === 8) {\n        offset = writeDataBytes(data, newData, slotsPerLine, offset);\n      } else if (depth === 16) {\n        offset = writeDataUint16(data, newData, slotsPerLine, offset);\n      } else {\n        throw new Error('unreachable');\n      }\n    }\n    const buffer = newData.toArray();\n    const compressed = deflate(buffer, this._zlibOptions);\n    this.encodeIDAT(compressed);\n  }\n\n  private _checkData(data: ImageData): DecodedPng {\n    const { colorType, channels, depth } = getColorType(data);\n    const png: DecodedPng = {\n      width: checkInteger(data.width, 'width'),\n      height: checkInteger(data.height, 'height'),\n      channels,\n      data: data.data,\n      depth,\n      text: {},\n    };\n    this._colorType = colorType;\n    const expectedSize = png.width * png.height * channels;\n    if (png.data.length !== expectedSize) {\n      throw new RangeError(\n        `wrong data size. Found ${png.data.length}, expected ${expectedSize}`,\n      );\n    }\n    return png;\n  }\n\n  private writeCrc(length: number): void {\n    this.writeUint32(\n      crc(\n        new Uint8Array(\n          this.buffer,\n          this.byteOffset + this.offset - length,\n          length,\n        ),\n        length,\n      ),\n    );\n  }\n}\n\nfunction checkInteger(value: number, name: string): number {\n  if (Number.isInteger(value) && value > 0) {\n    return value;\n  }\n  throw new TypeError(`${name} must be a positive integer`);\n}\n\nfunction getColorType(data: ImageData): {\n  channels: number;\n  depth: BitDepth;\n  colorType: ColorType;\n} {\n  const { channels = 4, depth = 8 } = data;\n  if (channels !== 4 && channels !== 3 && channels !== 2 && channels !== 1) {\n    throw new RangeError(`unsupported number of channels: ${channels}`);\n  }\n  if (depth !== 8 && depth !== 16) {\n    throw new RangeError(`unsupported bit depth: ${depth}`);\n  }\n\n  const returnValue = { channels, depth, colorType: ColorType.UNKNOWN };\n  switch (channels) {\n    case 4:\n      returnValue.colorType = ColorType.TRUECOLOUR_ALPHA;\n      break;\n    case 3:\n      returnValue.colorType = ColorType.TRUECOLOUR;\n      break;\n    case 1:\n      returnValue.colorType = ColorType.GREYSCALE;\n      break;\n    case 2:\n      returnValue.colorType = ColorType.GREYSCALE_ALPHA;\n      break;\n    default:\n      throw new Error('unsupported number of channels');\n  }\n  return returnValue;\n}\n\nfunction writeDataBytes(\n  data: PngDataArray,\n  newData: IOBuffer,\n  slotsPerLine: number,\n  offset: number,\n): number {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeByte(data[offset++]);\n  }\n  return offset;\n}\n\nfunction writeDataUint16(\n  data: PngDataArray,\n  newData: IOBuffer,\n  slotsPerLine: number,\n  offset: number,\n): number {\n  for (let j = 0; j < slotsPerLine; j++) {\n    newData.writeUint16(data[offset++]);\n  }\n  return offset;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}