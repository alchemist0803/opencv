{"ast":null,"code":"/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: An iterative implementation of Kittler and Illingworth's Minimum Error\n * thresholding:Kittler, J & Illingworth, J (1986), \"Minimum error thresholding\", Pattern Recognition 19: 41-47\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n\nexport default function minError(histogram, total) {\n  let threshold;\n  let Tprev = -2;\n  let mu, nu, p, q, sigma2, tau2, w0, w1, w2, sqterm, temp;\n\n  /* Calculate the mean gray-level */\n  let mean = 0.0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    mean += ih * histogram[ih];\n  }\n  mean /= total;\n  threshold = mean;\n  while (threshold !== Tprev) {\n    // Calculate some statistics.\n    let sumA1 = sumA(histogram, threshold);\n    let sumA2 = sumA(histogram, histogram.length - 1);\n    let sumB1 = sumB(histogram, threshold);\n    let sumB2 = sumB(histogram, histogram.length - 1);\n    let sumC1 = sumC(histogram, threshold);\n    let sumC2 = sumC(histogram, histogram.length - 1);\n    mu = sumB1 / sumA1;\n    nu = (sumB2 - sumB1) / (sumA2 - sumA1);\n    p = sumA1 / sumA2;\n    q = (sumA2 - sumA1) / sumA2;\n    sigma2 = sumC1 / sumA1 - mu * mu;\n    tau2 = (sumC2 - sumC1) / (sumA2 - sumA1) - nu * nu;\n\n    // The terms of the quadratic equation to be solved.\n    w0 = 1.0 / sigma2 - 1.0 / tau2;\n    w1 = mu / sigma2 - nu / tau2;\n    w2 = mu * mu / sigma2 - nu * nu / tau2 + Math.log10(sigma2 * (q * q) / (tau2 * (p * p)));\n\n    // If the next threshold would be imaginary, return with the current one.\n    sqterm = w1 * w1 - w0 * w2;\n    if (sqterm < 0) {\n      return threshold;\n    }\n\n    // The updated threshold is the integer part of the solution of the quadratic equation.\n    Tprev = threshold;\n    temp = (w1 + Math.sqrt(sqterm)) / w0;\n    if (isNaN(temp)) {\n      threshold = Tprev;\n    } else {\n      threshold = Math.floor(temp);\n    }\n  }\n  return threshold;\n}\n\n// aux func\n\nfunction sumA(y, j) {\n  let x = 0;\n  for (let i = 0; i <= j; i++) {\n    x += y[i];\n  }\n  return x;\n}\nfunction sumB(y, j) {\n  let x = 0;\n  for (let i = 0; i <= j; i++) {\n    x += i * y[i];\n  }\n  return x;\n}\nfunction sumC(y, j) {\n  let x = 0;\n  for (let i = 0; i <= j; i++) {\n    x += i * i * y[i];\n  }\n  return x;\n}","map":{"version":3,"names":["minError","histogram","total","threshold","Tprev","mu","nu","p","q","sigma2","tau2","w0","w1","w2","sqterm","temp","mean","ih","length","sumA1","sumA","sumA2","sumB1","sumB","sumB2","sumC1","sumC","sumC2","Math","log10","sqrt","isNaN","floor","y","j","x","i"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/minError.js"],"sourcesContent":["/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: An iterative implementation of Kittler and Illingworth's Minimum Error\n * thresholding:Kittler, J & Illingworth, J (1986), \"Minimum error thresholding\", Pattern Recognition 19: 41-47\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n\nexport default function minError(histogram, total) {\n  let threshold;\n  let Tprev = -2;\n  let mu, nu, p, q, sigma2, tau2, w0, w1, w2, sqterm, temp;\n\n  /* Calculate the mean gray-level */\n  let mean = 0.0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    mean += ih * histogram[ih];\n  }\n\n  mean /= total;\n\n  threshold = mean;\n\n  while (threshold !== Tprev) {\n    // Calculate some statistics.\n    let sumA1 = sumA(histogram, threshold);\n    let sumA2 = sumA(histogram, histogram.length - 1);\n    let sumB1 = sumB(histogram, threshold);\n    let sumB2 = sumB(histogram, histogram.length - 1);\n    let sumC1 = sumC(histogram, threshold);\n    let sumC2 = sumC(histogram, histogram.length - 1);\n\n    mu = sumB1 / sumA1;\n    nu = (sumB2 - sumB1) / (sumA2 - sumA1);\n    p = sumA1 / sumA2;\n    q = (sumA2 - sumA1) / sumA2;\n    sigma2 = sumC1 / sumA1 - mu * mu;\n    tau2 = (sumC2 - sumC1) / (sumA2 - sumA1) - nu * nu;\n\n    // The terms of the quadratic equation to be solved.\n    w0 = 1.0 / sigma2 - 1.0 / tau2;\n    w1 = mu / sigma2 - nu / tau2;\n    w2 =\n      (mu * mu) / sigma2 -\n      (nu * nu) / tau2 +\n      Math.log10((sigma2 * (q * q)) / (tau2 * (p * p)));\n\n    // If the next threshold would be imaginary, return with the current one.\n    sqterm = w1 * w1 - w0 * w2;\n    if (sqterm < 0) {\n      return threshold;\n    }\n\n    // The updated threshold is the integer part of the solution of the quadratic equation.\n    Tprev = threshold;\n    temp = (w1 + Math.sqrt(sqterm)) / w0;\n\n    if (isNaN(temp)) {\n      threshold = Tprev;\n    } else {\n      threshold = Math.floor(temp);\n    }\n  }\n  return threshold;\n}\n\n// aux func\n\nfunction sumA(y, j) {\n  let x = 0;\n  for (let i = 0; i <= j; i++) {\n    x += y[i];\n  }\n  return x;\n}\n\nfunction sumB(y, j) {\n  let x = 0;\n  for (let i = 0; i <= j; i++) {\n    x += i * y[i];\n  }\n  return x;\n}\n\nfunction sumC(y, j) {\n  let x = 0;\n  for (let i = 0; i <= j; i++) {\n    x += i * i * y[i];\n  }\n  return x;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}