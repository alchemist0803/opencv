{"ast":null,"code":"/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Li's Minimum Cross Entropy thresholding method\n * This implementation is based on the iterative version (Ref. 2nd reference below) of the algorithm.\n *  1) Li, CH & Lee, CK (1993), \"Minimum Cross Entropy Thresholding\", Pattern Recognition 26(4): 61 625\n *  2) Li, CH & Tam, PKS (1998), \"An Iterative Algorithm for Minimum Cross Entropy Thresholding\",\n *     Pattern Recognition Letters 18(8): 771-776\n *  3) Sezgin, M & Sankur, B (2004), \"Survey over Image Thresholding Techniques and Quantitative Performance\n *     Evaluation\",Journal of Electronic Imaging 13(1): 146-165\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n\nexport default function li(histogram, total) {\n  let threshold;\n  let sumBack; /* sum of the background pixels at a given threshold */\n  let sumObj; /* sum of the object pixels at a given threshold */\n  let numBack; /* number of background pixels at a given threshold */\n  let numObj; /* number of object pixels at a given threshold */\n  let oldThresh;\n  let newThresh;\n  let meanBack; /* mean of the background pixels at a given threshold */\n  let meanObj; /* mean of the object pixels at a given threshold */\n  let mean; /* mean gray-level in the image */\n  let tolerance; /* threshold tolerance */\n  let temp;\n  tolerance = 0.5;\n\n  /* Calculate the mean gray-level */\n  mean = 0.0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    mean += ih * histogram[ih];\n  }\n  mean /= total;\n  /* Initial estimate */\n  newThresh = mean;\n  do {\n    oldThresh = newThresh;\n    threshold = oldThresh + 0.5 | 0; /* range */\n\n    /* Calculate the means of background and object pixels */\n    /* Background */\n    sumBack = 0;\n    numBack = 0;\n    for (let ih = 0; ih <= threshold; ih++) {\n      sumBack += ih * histogram[ih];\n      numBack += histogram[ih];\n    }\n    meanBack = numBack === 0 ? 0.0 : sumBack / numBack;\n\n    /* Object */\n    sumObj = 0;\n    numObj = 0;\n    for (let ih = threshold + 1; ih < histogram.length; ih++) {\n      sumObj += ih * histogram[ih];\n      numObj += histogram[ih];\n    }\n    meanObj = numObj === 0 ? 0.0 : sumObj / numObj;\n    temp = (meanBack - meanObj) / (Math.log(meanBack) - Math.log(meanObj));\n    if (temp < -Number.EPSILON) {\n      newThresh = temp - 0.5 | 0;\n    } else {\n      newThresh = temp + 0.5 | 0;\n    }\n    /*  Stop the iterations when the difference between the\n         new and old threshold values is less than the tolerance */\n  } while (Math.abs(newThresh - oldThresh) > tolerance);\n  return threshold;\n}","map":{"version":3,"names":["li","histogram","total","threshold","sumBack","sumObj","numBack","numObj","oldThresh","newThresh","meanBack","meanObj","mean","tolerance","temp","ih","length","Math","log","Number","EPSILON","abs"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/li.js"],"sourcesContent":["/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Li's Minimum Cross Entropy thresholding method\n * This implementation is based on the iterative version (Ref. 2nd reference below) of the algorithm.\n *  1) Li, CH & Lee, CK (1993), \"Minimum Cross Entropy Thresholding\", Pattern Recognition 26(4): 61 625\n *  2) Li, CH & Tam, PKS (1998), \"An Iterative Algorithm for Minimum Cross Entropy Thresholding\",\n *     Pattern Recognition Letters 18(8): 771-776\n *  3) Sezgin, M & Sankur, B (2004), \"Survey over Image Thresholding Techniques and Quantitative Performance\n *     Evaluation\",Journal of Electronic Imaging 13(1): 146-165\n * @param histogram - the histogram of the image\n * @param total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n\nexport default function li(histogram, total) {\n  let threshold;\n  let sumBack; /* sum of the background pixels at a given threshold */\n  let sumObj; /* sum of the object pixels at a given threshold */\n  let numBack; /* number of background pixels at a given threshold */\n  let numObj; /* number of object pixels at a given threshold */\n  let oldThresh;\n  let newThresh;\n  let meanBack; /* mean of the background pixels at a given threshold */\n  let meanObj; /* mean of the object pixels at a given threshold */\n  let mean; /* mean gray-level in the image */\n  let tolerance; /* threshold tolerance */\n  let temp;\n  tolerance = 0.5;\n\n  /* Calculate the mean gray-level */\n  mean = 0.0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    mean += ih * histogram[ih];\n  }\n\n  mean /= total;\n  /* Initial estimate */\n  newThresh = mean;\n\n  do {\n    oldThresh = newThresh;\n    threshold = (oldThresh + 0.5) | 0; /* range */\n\n    /* Calculate the means of background and object pixels */\n    /* Background */\n    sumBack = 0;\n    numBack = 0;\n\n    for (let ih = 0; ih <= threshold; ih++) {\n      sumBack += ih * histogram[ih];\n      numBack += histogram[ih];\n    }\n    meanBack = numBack === 0 ? 0.0 : sumBack / numBack;\n\n    /* Object */\n    sumObj = 0;\n    numObj = 0;\n    for (let ih = threshold + 1; ih < histogram.length; ih++) {\n      sumObj += ih * histogram[ih];\n      numObj += histogram[ih];\n    }\n    meanObj = numObj === 0 ? 0.0 : sumObj / numObj;\n    temp = (meanBack - meanObj) / (Math.log(meanBack) - Math.log(meanObj));\n\n    if (temp < -Number.EPSILON) {\n      newThresh = (temp - 0.5) | 0;\n    } else {\n      newThresh = (temp + 0.5) | 0;\n    }\n    /*  Stop the iterations when the difference between the\n         new and old threshold values is less than the tolerance */\n  } while (Math.abs(newThresh - oldThresh) > tolerance);\n\n  return threshold;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASA,EAAEA,CAACC,SAAS,EAAEC,KAAK,EAAE;EAC3C,IAAIC,SAAS;EACb,IAAIC,OAAO,CAAC,CAAC;EACb,IAAIC,MAAM,CAAC,CAAC;EACZ,IAAIC,OAAO,CAAC,CAAC;EACb,IAAIC,MAAM,CAAC,CAAC;EACZ,IAAIC,SAAS;EACb,IAAIC,SAAS;EACb,IAAIC,QAAQ,CAAC,CAAC;EACd,IAAIC,OAAO,CAAC,CAAC;EACb,IAAIC,IAAI,CAAC,CAAC;EACV,IAAIC,SAAS,CAAC,CAAC;EACf,IAAIC,IAAI;EACRD,SAAS,GAAG,GAAG;;EAEf;EACAD,IAAI,GAAG,GAAG;EACV,KAAK,IAAIG,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGd,SAAS,CAACe,MAAM,EAAED,EAAE,EAAE,EAAE;IAC5CH,IAAI,IAAIG,EAAE,GAAGd,SAAS,CAACc,EAAE,CAAC;EAC5B;EAEAH,IAAI,IAAIV,KAAK;EACb;EACAO,SAAS,GAAGG,IAAI;EAEhB,GAAG;IACDJ,SAAS,GAAGC,SAAS;IACrBN,SAAS,GAAIK,SAAS,GAAG,GAAG,GAAI,CAAC,CAAC,CAAC;;IAEnC;IACA;IACAJ,OAAO,GAAG,CAAC;IACXE,OAAO,GAAG,CAAC;IAEX,KAAK,IAAIS,EAAE,GAAG,CAAC,EAAEA,EAAE,IAAIZ,SAAS,EAAEY,EAAE,EAAE,EAAE;MACtCX,OAAO,IAAIW,EAAE,GAAGd,SAAS,CAACc,EAAE,CAAC;MAC7BT,OAAO,IAAIL,SAAS,CAACc,EAAE,CAAC;IAC1B;IACAL,QAAQ,GAAGJ,OAAO,KAAK,CAAC,GAAG,GAAG,GAAGF,OAAO,GAAGE,OAAO;;IAElD;IACAD,MAAM,GAAG,CAAC;IACVE,MAAM,GAAG,CAAC;IACV,KAAK,IAAIQ,EAAE,GAAGZ,SAAS,GAAG,CAAC,EAAEY,EAAE,GAAGd,SAAS,CAACe,MAAM,EAAED,EAAE,EAAE,EAAE;MACxDV,MAAM,IAAIU,EAAE,GAAGd,SAAS,CAACc,EAAE,CAAC;MAC5BR,MAAM,IAAIN,SAAS,CAACc,EAAE,CAAC;IACzB;IACAJ,OAAO,GAAGJ,MAAM,KAAK,CAAC,GAAG,GAAG,GAAGF,MAAM,GAAGE,MAAM;IAC9CO,IAAI,GAAG,CAACJ,QAAQ,GAAGC,OAAO,KAAKM,IAAI,CAACC,GAAG,CAACR,QAAQ,CAAC,GAAGO,IAAI,CAACC,GAAG,CAACP,OAAO,CAAC,CAAC;IAEtE,IAAIG,IAAI,GAAG,CAACK,MAAM,CAACC,OAAO,EAAE;MAC1BX,SAAS,GAAIK,IAAI,GAAG,GAAG,GAAI,CAAC;IAC9B,CAAC,MAAM;MACLL,SAAS,GAAIK,IAAI,GAAG,GAAG,GAAI,CAAC;IAC9B;IACA;AACJ;EACE,CAAC,QAAQG,IAAI,CAACI,GAAG,CAACZ,SAAS,GAAGD,SAAS,CAAC,GAAGK,SAAS;EAEpD,OAAOV,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}