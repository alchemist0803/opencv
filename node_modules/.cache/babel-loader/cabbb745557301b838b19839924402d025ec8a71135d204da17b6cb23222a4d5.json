{"ast":null,"code":"/**\n * @typedef {('luma709'|'luma601'|'maximum'|'minimum'|'average'|'minmax'|'red'|'green'|'blue'|'cyan'|'magenta'|'yellow'|'black'|'hue'|'saturation'|'lightness')} GreyAlgorithm\n */\n\nexport const methods = {\n  luma709(red, green, blue) {\n    // sRGB\n    // return red * 0.2126 + green * 0.7152 + blue * 0.0722;\n    // Let's do a little trick ... in order not convert the integer to a double we do\n    // the multiplication with integer to reach a total of 32768 and then shift the bits\n    // of 15 to the right\n    // This does a Math.floor and may lead to small (max 1) difference\n    // Same result, > 10% faster on the full grey conversion\n    return red * 6966 + green * 23436 + blue * 2366 >> 15;\n  },\n  luma601(red, green, blue) {\n    // NTSC\n    // return this.red * 0.299 + green * 0.587 + blue * 0.114;\n    return red * 9798 + green * 19235 + blue * 3735 >> 15;\n  },\n  maximum(red, green, blue) {\n    return Math.max(red, green, blue);\n  },\n  minimum(red, green, blue) {\n    return Math.min(red, green, blue);\n  },\n  average(red, green, blue) {\n    return (red + green + blue) / 3 >> 0;\n  },\n  minmax(red, green, blue) {\n    return (Math.max(red, green, blue) + Math.min(red, green, blue)) / 2;\n  },\n  red(red) {\n    return red;\n  },\n  green(red, green) {\n    return green;\n  },\n  blue(red, green, blue) {\n    return blue;\n  },\n  cyan(red, green, blue, image) {\n    let black = methods.black(red, green, blue, image);\n    return (image.maxValue - red - black) / (1 - black / image.maxValue) >> 0;\n  },\n  magenta(red, green, blue, image) {\n    let black = methods.black(red, green, blue, image);\n    return (image.maxValue - green - black) / (1 - black / image.maxValue) >> 0;\n  },\n  yellow(red, green, blue, image) {\n    let black = methods.black(red, green, blue, image);\n    return (image.maxValue - blue - black) / (1 - black / image.maxValue) >> 0;\n  },\n  black(red, green, blue, image) {\n    return Math.min(image.maxValue - red, image.maxValue - green, image.maxValue - blue);\n  },\n  hue(red, green, blue, image) {\n    let min = methods.min(red, green, blue);\n    let max = methods.max(red, green, blue);\n    if (max === min) {\n      return 0;\n    }\n    let hue = 0;\n    let delta = max - min;\n    switch (max) {\n      case red:\n        hue = (green - blue) / delta + (green < blue ? 6 : 0);\n        break;\n      case green:\n        hue = (blue - red) / delta + 2;\n        break;\n      case blue:\n        hue = (red - green) / delta + 4;\n        break;\n      default:\n        throw new Error('unreachable');\n    }\n    return hue / 6 * image.maxValue >> 0;\n  },\n  saturation(red, green, blue, image) {\n    // from HSV model\n    let min = methods.min(red, green, blue);\n    let max = methods.max(red, green, blue);\n    let delta = max - min;\n    return max === 0 ? 0 : delta / max * image.maxValue;\n  },\n  lightness(red, green, blue) {\n    let min = methods.min(red, green, blue);\n    let max = methods.max(red, green, blue);\n    return (max + min) / 2;\n  }\n};\nObject.defineProperty(methods, 'luminosity', {\n  enumerable: false,\n  value: methods.lightness\n});\nObject.defineProperty(methods, 'luminance', {\n  enumerable: false,\n  value: methods.lightness\n});\nObject.defineProperty(methods, 'min', {\n  enumerable: false,\n  value: methods.minimum\n});\nObject.defineProperty(methods, 'max', {\n  enumerable: false,\n  value: methods.maximum\n});\nObject.defineProperty(methods, 'brightness', {\n  enumerable: false,\n  value: methods.maximum\n});\nexport const names = {};\nObject.keys(methods).forEach(name => {\n  names[name] = name;\n});","map":{"version":3,"names":["methods","luma709","red","green","blue","luma601","maximum","Math","max","minimum","min","average","minmax","cyan","image","black","maxValue","magenta","yellow","hue","delta","Error","saturation","lightness","Object","defineProperty","enumerable","value","names","keys","forEach","name"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/greyAlgorithms.js"],"sourcesContent":["/**\n * @typedef {('luma709'|'luma601'|'maximum'|'minimum'|'average'|'minmax'|'red'|'green'|'blue'|'cyan'|'magenta'|'yellow'|'black'|'hue'|'saturation'|'lightness')} GreyAlgorithm\n */\n\nexport const methods = {\n  luma709(red, green, blue) {\n    // sRGB\n    // return red * 0.2126 + green * 0.7152 + blue * 0.0722;\n    // Let's do a little trick ... in order not convert the integer to a double we do\n    // the multiplication with integer to reach a total of 32768 and then shift the bits\n    // of 15 to the right\n    // This does a Math.floor and may lead to small (max 1) difference\n    // Same result, > 10% faster on the full grey conversion\n    return (red * 6966 + green * 23436 + blue * 2366) >> 15;\n  },\n  luma601(red, green, blue) {\n    // NTSC\n    // return this.red * 0.299 + green * 0.587 + blue * 0.114;\n    return (red * 9798 + green * 19235 + blue * 3735) >> 15;\n  },\n  maximum(red, green, blue) {\n    return Math.max(red, green, blue);\n  },\n  minimum(red, green, blue) {\n    return Math.min(red, green, blue);\n  },\n  average(red, green, blue) {\n    return ((red + green + blue) / 3) >> 0;\n  },\n  minmax(red, green, blue) {\n    return (Math.max(red, green, blue) + Math.min(red, green, blue)) / 2;\n  },\n  red(red) {\n    return red;\n  },\n  green(red, green) {\n    return green;\n  },\n  blue(red, green, blue) {\n    return blue;\n  },\n  cyan(red, green, blue, image) {\n    let black = methods.black(red, green, blue, image);\n    return ((image.maxValue - red - black) / (1 - black / image.maxValue)) >> 0;\n  },\n  magenta(red, green, blue, image) {\n    let black = methods.black(red, green, blue, image);\n    return (\n      ((image.maxValue - green - black) / (1 - black / image.maxValue)) >> 0\n    );\n  },\n  yellow(red, green, blue, image) {\n    let black = methods.black(red, green, blue, image);\n    return (\n      ((image.maxValue - blue - black) / (1 - black / image.maxValue)) >> 0\n    );\n  },\n  black(red, green, blue, image) {\n    return Math.min(\n      image.maxValue - red,\n      image.maxValue - green,\n      image.maxValue - blue,\n    );\n  },\n  hue(red, green, blue, image) {\n    let min = methods.min(red, green, blue);\n    let max = methods.max(red, green, blue);\n    if (max === min) {\n      return 0;\n    }\n    let hue = 0;\n    let delta = max - min;\n\n    switch (max) {\n      case red:\n        hue = (green - blue) / delta + (green < blue ? 6 : 0);\n        break;\n      case green:\n        hue = (blue - red) / delta + 2;\n        break;\n      case blue:\n        hue = (red - green) / delta + 4;\n        break;\n      default:\n        throw new Error('unreachable');\n    }\n    return ((hue / 6) * image.maxValue) >> 0;\n  },\n  saturation(red, green, blue, image) {\n    // from HSV model\n    let min = methods.min(red, green, blue);\n    let max = methods.max(red, green, blue);\n    let delta = max - min;\n    return max === 0 ? 0 : (delta / max) * image.maxValue;\n  },\n  lightness(red, green, blue) {\n    let min = methods.min(red, green, blue);\n    let max = methods.max(red, green, blue);\n    return (max + min) / 2;\n  },\n};\n\nObject.defineProperty(methods, 'luminosity', {\n  enumerable: false,\n  value: methods.lightness,\n});\nObject.defineProperty(methods, 'luminance', {\n  enumerable: false,\n  value: methods.lightness,\n});\nObject.defineProperty(methods, 'min', {\n  enumerable: false,\n  value: methods.minimum,\n});\nObject.defineProperty(methods, 'max', {\n  enumerable: false,\n  value: methods.maximum,\n});\nObject.defineProperty(methods, 'brightness', {\n  enumerable: false,\n  value: methods.maximum,\n});\n\nexport const names = {};\nObject.keys(methods).forEach((name) => {\n  names[name] = name;\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}