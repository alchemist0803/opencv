{"ast":null,"code":"import { decode as decodeJpegExif } from 'fast-jpeg';\nimport { decode as decodePng } from 'fast-png';\nimport imageType from 'image-type';\nimport { decode as decodeJpeg } from 'jpeg-js';\nimport { decode as decodeTiff } from 'tiff';\nimport Stack from '../../stack/Stack';\nimport { decode as base64Decode, toBase64URL } from '../../util/base64';\nimport Image from '../Image';\nimport { GREY, RGB } from '../model/model';\nimport { fetchBinary, DOMImage, createCanvas } from './environment';\nconst isDataURL = /^data:[a-z]+\\/(?:[a-z]+);base64,/;\n\n/**\n * Load an image\n * @memberof Image\n * @static\n * @param {string|ArrayBuffer|Buffer|Uint8Array} image - URL of the image (browser, can be a dataURL) or path (Node.js)\n * or buffer containing the binary data\n * @param {object} [options] - In the browser, the options object is passed to the underlying `fetch` call, along with\n * the data URL. For binary data, the option specify decoding options.\n * @param {boolean} [options.ignorePalette] - When set to true and loading a tiff from binary data, if the tiff is of\n * type 3 (palette), load as single channel greyscale rather than as a pseudo-colored RGB.\n * @return {Promise<Image>}\n * @example\n * const image = await Image.load('https://example.com/image.png');\n */\nexport default function load(image, options) {\n  if (typeof image === 'string') {\n    return loadURL(image, options);\n  } else if (image instanceof ArrayBuffer) {\n    return Promise.resolve(loadBinary(new Uint8Array(image), undefined, options && options.ignorePalette));\n  } else if (image.buffer) {\n    return Promise.resolve(loadBinary(image, undefined, options && options.ignorePalette));\n  } else {\n    throw new Error('argument to \"load\" must be a string or buffer.');\n  }\n}\nfunction loadBinary(image, base64Url, ignorePalette) {\n  const type = imageType(image);\n  if (type) {\n    switch (type.mime) {\n      case 'image/png':\n        return loadPNG(image);\n      case 'image/jpeg':\n        return loadJPEG(image);\n      case 'image/tiff':\n        return loadTIFF(image, ignorePalette);\n      default:\n        return loadGeneric(getBase64(type.mime));\n    }\n  }\n  return loadGeneric(getBase64('application/octet-stream'));\n  function getBase64(type) {\n    if (base64Url) {\n      return base64Url;\n    } else {\n      return toBase64URL(image, type);\n    }\n  }\n}\nfunction loadURL(url, options) {\n  const dataURL = url.slice(0, 64).match(isDataURL);\n  let binaryDataP;\n  if (dataURL !== null) {\n    binaryDataP = Promise.resolve(base64Decode(url.slice(dataURL[0].length)));\n  } else {\n    binaryDataP = fetchBinary(url, options);\n  }\n  return binaryDataP.then(binaryData => {\n    const uint8 = new Uint8Array(binaryData);\n    return loadBinary(uint8, dataURL ? url : undefined, options && options.ignorePalette);\n  });\n}\nfunction loadPNG(data) {\n  const png = decodePng(data);\n  let channels = png.channels;\n  let components;\n  let alpha = 0;\n  if (channels === 2 || channels === 4) {\n    components = channels - 1;\n    alpha = 1;\n  } else {\n    components = channels;\n  }\n  if (png.palette) {\n    return loadPNGFromPalette(png);\n  }\n  return new Image(png.width, png.height, png.data, {\n    components,\n    alpha,\n    bitDepth: png.depth,\n    meta: {\n      text: png.text\n    }\n  });\n}\nfunction loadPNGFromPalette(png) {\n  const pixels = png.width * png.height;\n  const channels = png.palette[0].length;\n  const data = new Uint8Array(pixels * channels);\n  const pixelsPerByte = 8 / png.depth;\n  const factor = png.depth < 8 ? pixelsPerByte : 1;\n  const mask = parseInt('1'.repeat(png.depth), 2);\n  const hasAlpha = channels === 4;\n  let dataIndex = 0;\n  for (let i = 0; i < pixels; i++) {\n    const index = Math.floor(i / factor);\n    let value = png.data[index];\n    if (png.depth < 8) {\n      value = value >>> png.depth * (pixelsPerByte - 1 - i % pixelsPerByte) & mask;\n    }\n    const paletteValue = png.palette[value];\n    data[dataIndex++] = paletteValue[0];\n    data[dataIndex++] = paletteValue[1];\n    data[dataIndex++] = paletteValue[2];\n    if (hasAlpha) {\n      data[dataIndex++] = paletteValue[3];\n    }\n  }\n  return new Image(png.width, png.height, data, {\n    components: 3,\n    alpha: hasAlpha,\n    bitDepth: 8\n  });\n}\nfunction loadJPEG(data) {\n  const decodedExif = decodeJpegExif(data);\n  let meta;\n  if (decodedExif.exif) {\n    meta = getMetadata(decodedExif.exif);\n  }\n  const jpeg = decodeJpeg(data, {\n    useTArray: true,\n    maxMemoryUsageInMB: 1024\n  });\n  let image = new Image(jpeg.width, jpeg.height, jpeg.data, {\n    meta\n  });\n  if (meta && meta.tiff.tags.Orientation) {\n    const orientation = meta.tiff.tags.Orientation;\n    if (orientation > 2) {\n      image = image.rotate({\n        3: 180,\n        4: 180,\n        5: 90,\n        6: 90,\n        7: 270,\n        8: 270\n      }[orientation]);\n    }\n    if ([2, 4, 5, 7].includes(orientation)) {\n      image = image.flipX();\n    }\n  }\n  return image;\n}\nfunction loadTIFF(data, ignorePalette) {\n  let result = decodeTiff(data);\n  if (result.length === 1) {\n    return getImageFromIFD(result[0], ignorePalette);\n  } else {\n    return new Stack(result.map(function (image) {\n      return getImageFromIFD(image, ignorePalette);\n    }));\n  }\n}\nfunction getMetadata(image) {\n  const metadata = {\n    tiff: {\n      fields: image.fields,\n      tags: image.map\n    }\n  };\n  if (image.exif) {\n    metadata.exif = image.exif;\n  }\n  if (image.gps) {\n    metadata.gps = image.gps;\n  }\n  return metadata;\n}\nfunction getImageFromIFD(image, ignorePalette) {\n  if (!ignorePalette && image.type === 3) {\n    // Palette\n    const data = new Uint16Array(3 * image.width * image.height);\n    const palette = image.palette;\n    let ptr = 0;\n    for (let i = 0; i < image.data.length; i++) {\n      const index = image.data[i];\n      const color = palette[index];\n      data[ptr++] = color[0];\n      data[ptr++] = color[1];\n      data[ptr++] = color[2];\n    }\n    return new Image(image.width, image.height, data, {\n      components: 3,\n      alpha: image.alpha,\n      colorModel: RGB,\n      bitDepth: 16,\n      meta: getMetadata(image)\n    });\n  } else {\n    return new Image(image.width, image.height, image.data, {\n      components: image.type === 2 ? 3 : 1,\n      alpha: image.alpha,\n      colorModel: image.type === 2 ? RGB : GREY,\n      bitDepth: image.bitsPerSample.length ? image.bitsPerSample[0] : image.bitsPerSample,\n      meta: getMetadata(image)\n    });\n  }\n}\nfunction loadGeneric(url, options) {\n  options = options || {};\n  return new Promise(function (resolve, reject) {\n    let image = new DOMImage();\n    image.onload = function () {\n      let w = image.width;\n      let h = image.height;\n      let canvas = createCanvas(w, h);\n      let ctx = canvas.getContext('2d');\n      ctx.drawImage(image, 0, 0, w, h);\n      let data = ctx.getImageData(0, 0, w, h).data;\n      resolve(new Image(w, h, data, options));\n    };\n    image.onerror = function () {\n      reject(new Error(`Could not load ${url}`));\n    };\n    image.src = url;\n  });\n}","map":{"version":3,"names":["decode","decodeJpegExif","decodePng","imageType","decodeJpeg","decodeTiff","Stack","base64Decode","toBase64URL","Image","GREY","RGB","fetchBinary","DOMImage","createCanvas","isDataURL","load","image","options","loadURL","ArrayBuffer","Promise","resolve","loadBinary","Uint8Array","undefined","ignorePalette","buffer","Error","base64Url","type","mime","loadPNG","loadJPEG","loadTIFF","loadGeneric","getBase64","url","dataURL","slice","match","binaryDataP","length","then","binaryData","uint8","data","png","channels","components","alpha","palette","loadPNGFromPalette","width","height","bitDepth","depth","meta","text","pixels","pixelsPerByte","factor","mask","parseInt","repeat","hasAlpha","dataIndex","i","index","Math","floor","value","paletteValue","decodedExif","exif","getMetadata","jpeg","useTArray","maxMemoryUsageInMB","tiff","tags","Orientation","orientation","rotate","includes","flipX","result","getImageFromIFD","map","metadata","fields","gps","Uint16Array","ptr","color","colorModel","bitsPerSample","reject","onload","w","h","canvas","ctx","getContext","drawImage","getImageData","onerror","src"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/core/load.js"],"sourcesContent":["import { decode as decodeJpegExif } from 'fast-jpeg';\nimport { decode as decodePng } from 'fast-png';\nimport imageType from 'image-type';\nimport { decode as decodeJpeg } from 'jpeg-js';\nimport { decode as decodeTiff } from 'tiff';\n\nimport Stack from '../../stack/Stack';\nimport { decode as base64Decode, toBase64URL } from '../../util/base64';\nimport Image from '../Image';\nimport { GREY, RGB } from '../model/model';\n\nimport { fetchBinary, DOMImage, createCanvas } from './environment';\n\nconst isDataURL = /^data:[a-z]+\\/(?:[a-z]+);base64,/;\n\n/**\n * Load an image\n * @memberof Image\n * @static\n * @param {string|ArrayBuffer|Buffer|Uint8Array} image - URL of the image (browser, can be a dataURL) or path (Node.js)\n * or buffer containing the binary data\n * @param {object} [options] - In the browser, the options object is passed to the underlying `fetch` call, along with\n * the data URL. For binary data, the option specify decoding options.\n * @param {boolean} [options.ignorePalette] - When set to true and loading a tiff from binary data, if the tiff is of\n * type 3 (palette), load as single channel greyscale rather than as a pseudo-colored RGB.\n * @return {Promise<Image>}\n * @example\n * const image = await Image.load('https://example.com/image.png');\n */\nexport default function load(image, options) {\n  if (typeof image === 'string') {\n    return loadURL(image, options);\n  } else if (image instanceof ArrayBuffer) {\n    return Promise.resolve(\n      loadBinary(\n        new Uint8Array(image),\n        undefined,\n        options && options.ignorePalette,\n      ),\n    );\n  } else if (image.buffer) {\n    return Promise.resolve(\n      loadBinary(image, undefined, options && options.ignorePalette),\n    );\n  } else {\n    throw new Error('argument to \"load\" must be a string or buffer.');\n  }\n}\n\nfunction loadBinary(image, base64Url, ignorePalette) {\n  const type = imageType(image);\n  if (type) {\n    switch (type.mime) {\n      case 'image/png':\n        return loadPNG(image);\n      case 'image/jpeg':\n        return loadJPEG(image);\n      case 'image/tiff':\n        return loadTIFF(image, ignorePalette);\n      default:\n        return loadGeneric(getBase64(type.mime));\n    }\n  }\n  return loadGeneric(getBase64('application/octet-stream'));\n\n  function getBase64(type) {\n    if (base64Url) {\n      return base64Url;\n    } else {\n      return toBase64URL(image, type);\n    }\n  }\n}\n\nfunction loadURL(url, options) {\n  const dataURL = url.slice(0, 64).match(isDataURL);\n  let binaryDataP;\n  if (dataURL !== null) {\n    binaryDataP = Promise.resolve(base64Decode(url.slice(dataURL[0].length)));\n  } else {\n    binaryDataP = fetchBinary(url, options);\n  }\n  return binaryDataP.then((binaryData) => {\n    const uint8 = new Uint8Array(binaryData);\n    return loadBinary(\n      uint8,\n      dataURL ? url : undefined,\n      options && options.ignorePalette,\n    );\n  });\n}\n\nfunction loadPNG(data) {\n  const png = decodePng(data);\n  let channels = png.channels;\n  let components;\n  let alpha = 0;\n  if (channels === 2 || channels === 4) {\n    components = channels - 1;\n    alpha = 1;\n  } else {\n    components = channels;\n  }\n  if (png.palette) {\n    return loadPNGFromPalette(png);\n  }\n\n  return new Image(png.width, png.height, png.data, {\n    components,\n    alpha,\n    bitDepth: png.depth,\n    meta: { text: png.text },\n  });\n}\n\nfunction loadPNGFromPalette(png) {\n  const pixels = png.width * png.height;\n  const channels = png.palette[0].length;\n  const data = new Uint8Array(pixels * channels);\n  const pixelsPerByte = 8 / png.depth;\n  const factor = png.depth < 8 ? pixelsPerByte : 1;\n  const mask = parseInt('1'.repeat(png.depth), 2);\n  const hasAlpha = channels === 4;\n  let dataIndex = 0;\n\n  for (let i = 0; i < pixels; i++) {\n    const index = Math.floor(i / factor);\n    let value = png.data[index];\n    if (png.depth < 8) {\n      value =\n        (value >>> (png.depth * (pixelsPerByte - 1 - (i % pixelsPerByte)))) &\n        mask;\n    }\n    const paletteValue = png.palette[value];\n    data[dataIndex++] = paletteValue[0];\n    data[dataIndex++] = paletteValue[1];\n    data[dataIndex++] = paletteValue[2];\n    if (hasAlpha) {\n      data[dataIndex++] = paletteValue[3];\n    }\n  }\n\n  return new Image(png.width, png.height, data, {\n    components: 3,\n    alpha: hasAlpha,\n    bitDepth: 8,\n  });\n}\n\nfunction loadJPEG(data) {\n  const decodedExif = decodeJpegExif(data);\n  let meta;\n  if (decodedExif.exif) {\n    meta = getMetadata(decodedExif.exif);\n  }\n  const jpeg = decodeJpeg(data, { useTArray: true, maxMemoryUsageInMB: 1024 });\n  let image = new Image(jpeg.width, jpeg.height, jpeg.data, { meta });\n  if (meta && meta.tiff.tags.Orientation) {\n    const orientation = meta.tiff.tags.Orientation;\n    if (orientation > 2) {\n      image = image.rotate(\n        {\n          3: 180,\n          4: 180,\n          5: 90,\n          6: 90,\n          7: 270,\n          8: 270,\n        }[orientation],\n      );\n    }\n    if ([2, 4, 5, 7].includes(orientation)) {\n      image = image.flipX();\n    }\n  }\n  return image;\n}\n\nfunction loadTIFF(data, ignorePalette) {\n  let result = decodeTiff(data);\n  if (result.length === 1) {\n    return getImageFromIFD(result[0], ignorePalette);\n  } else {\n    return new Stack(\n      result.map(function (image) {\n        return getImageFromIFD(image, ignorePalette);\n      }),\n    );\n  }\n}\n\nfunction getMetadata(image) {\n  const metadata = {\n    tiff: {\n      fields: image.fields,\n      tags: image.map,\n    },\n  };\n  if (image.exif) {\n    metadata.exif = image.exif;\n  }\n  if (image.gps) {\n    metadata.gps = image.gps;\n  }\n  return metadata;\n}\n\nfunction getImageFromIFD(image, ignorePalette) {\n  if (!ignorePalette && image.type === 3) {\n    // Palette\n    const data = new Uint16Array(3 * image.width * image.height);\n    const palette = image.palette;\n    let ptr = 0;\n    for (let i = 0; i < image.data.length; i++) {\n      const index = image.data[i];\n      const color = palette[index];\n      data[ptr++] = color[0];\n      data[ptr++] = color[1];\n      data[ptr++] = color[2];\n    }\n    return new Image(image.width, image.height, data, {\n      components: 3,\n      alpha: image.alpha,\n      colorModel: RGB,\n      bitDepth: 16,\n      meta: getMetadata(image),\n    });\n  } else {\n    return new Image(image.width, image.height, image.data, {\n      components: image.type === 2 ? 3 : 1,\n      alpha: image.alpha,\n      colorModel: image.type === 2 ? RGB : GREY,\n      bitDepth: image.bitsPerSample.length\n        ? image.bitsPerSample[0]\n        : image.bitsPerSample,\n      meta: getMetadata(image),\n    });\n  }\n}\n\nfunction loadGeneric(url, options) {\n  options = options || {};\n  return new Promise(function (resolve, reject) {\n    let image = new DOMImage();\n    image.onload = function () {\n      let w = image.width;\n      let h = image.height;\n      let canvas = createCanvas(w, h);\n      let ctx = canvas.getContext('2d');\n      ctx.drawImage(image, 0, 0, w, h);\n      let data = ctx.getImageData(0, 0, w, h).data;\n      resolve(new Image(w, h, data, options));\n    };\n    image.onerror = function () {\n      reject(new Error(`Could not load ${url}`));\n    };\n    image.src = url;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}