{"ast":null,"code":"import { clamp } from '../internal/clamp';\nimport { getOutputImage } from '../internal/getOutputImage';\nimport { GREY } from '../model/model';\nimport { methods } from './greyAlgorithms';\n\n/**\n * Call back that converts the RGB channels to grey. It will be clamped after.\n * @callback GreyAlgorithmCallback\n * @param {number} red - value of the red channel\n * @param {number} green - value of the green channel\n * @param {number} blue - value of the blue channel\n * @return {number} value of the grey channel\n */\n\n/**\n * Converts the current image to greyscale.\n * The source image has to be RGB.\n * If there is an alpha channel we need to decide what to do:\n * * keepAlpha : we will keep the alpha channel and you will get a GREY / A image\n * * mergeAlpha : we will multiply each pixel of the image by the alpha\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {GreyAlgorithm|GreyAlgorithmCallback} [options.algorithm='luma709'] - Algorithm to get the grey value from RGB values\n * @param {boolean} [options.keepAlpha=false] - If true, the RGB values are treated\n *          separately from the alpha channel and the method returns a GREYA image.\n * @param {boolean} [options.mergeAlpha=true] - If true, the alpha channel will be used to scale the grey pixel.\n * @param {Image} [options.out]\n * @return {Image}\n */\nexport default function grey(options = {}) {\n  let {\n    algorithm = 'luma709',\n    keepAlpha = false,\n    mergeAlpha = true\n  } = options;\n  if (typeof algorithm !== 'string' && typeof algorithm !== 'function') {\n    throw new TypeError('algorithm must be a string or a function');\n  }\n  this.checkProcessable('grey', {\n    bitDepth: [8, 16],\n    alpha: [0, 1]\n  });\n  if (this.components === 1) {\n    algorithm = 'red'; // actually we just take the first channel if it is a grey image\n  }\n  keepAlpha &= this.alpha;\n  mergeAlpha &= this.alpha;\n  if (keepAlpha) {\n    mergeAlpha = false;\n  }\n  let newImage = getOutputImage(this, options, {\n    components: 1,\n    alpha: keepAlpha,\n    colorModel: GREY\n  });\n  let method;\n  if (typeof algorithm === 'function') {\n    method = algorithm;\n  } else {\n    method = methods[algorithm.toLowerCase()];\n    if (!method) {\n      throw new Error(`unsupported grey algorithm: ${algorithm}`);\n    }\n  }\n  let ptr = 0;\n  for (let i = 0; i < this.data.length; i += this.channels) {\n    if (mergeAlpha) {\n      newImage.data[ptr++] = clamp(method(this.data[i], this.data[i + 1], this.data[i + 2], this) * this.data[i + this.components] / this.maxValue, this);\n    } else {\n      newImage.data[ptr++] = clamp(method(this.data[i], this.data[i + 1], this.data[i + 2], this), this);\n      if (newImage.alpha) {\n        newImage.data[ptr++] = this.data[i + this.components];\n      }\n    }\n  }\n  return newImage;\n}","map":{"version":3,"names":["clamp","getOutputImage","GREY","methods","grey","options","algorithm","keepAlpha","mergeAlpha","TypeError","checkProcessable","bitDepth","alpha","components","newImage","colorModel","method","toLowerCase","Error","ptr","i","data","length","channels","maxValue"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/grey.js"],"sourcesContent":["import { clamp } from '../internal/clamp';\nimport { getOutputImage } from '../internal/getOutputImage';\nimport { GREY } from '../model/model';\n\nimport { methods } from './greyAlgorithms';\n\n/**\n * Call back that converts the RGB channels to grey. It will be clamped after.\n * @callback GreyAlgorithmCallback\n * @param {number} red - value of the red channel\n * @param {number} green - value of the green channel\n * @param {number} blue - value of the blue channel\n * @return {number} value of the grey channel\n */\n\n/**\n * Converts the current image to greyscale.\n * The source image has to be RGB.\n * If there is an alpha channel we need to decide what to do:\n * * keepAlpha : we will keep the alpha channel and you will get a GREY / A image\n * * mergeAlpha : we will multiply each pixel of the image by the alpha\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {GreyAlgorithm|GreyAlgorithmCallback} [options.algorithm='luma709'] - Algorithm to get the grey value from RGB values\n * @param {boolean} [options.keepAlpha=false] - If true, the RGB values are treated\n *          separately from the alpha channel and the method returns a GREYA image.\n * @param {boolean} [options.mergeAlpha=true] - If true, the alpha channel will be used to scale the grey pixel.\n * @param {Image} [options.out]\n * @return {Image}\n */\nexport default function grey(options = {}) {\n  let { algorithm = 'luma709', keepAlpha = false, mergeAlpha = true } = options;\n\n  if (typeof algorithm !== 'string' && typeof algorithm !== 'function') {\n    throw new TypeError('algorithm must be a string or a function');\n  }\n\n  this.checkProcessable('grey', {\n    bitDepth: [8, 16],\n    alpha: [0, 1],\n  });\n\n  if (this.components === 1) {\n    algorithm = 'red'; // actually we just take the first channel if it is a grey image\n  }\n\n  keepAlpha &= this.alpha;\n  mergeAlpha &= this.alpha;\n  if (keepAlpha) {\n    mergeAlpha = false;\n  }\n\n  let newImage = getOutputImage(this, options, {\n    components: 1,\n    alpha: keepAlpha,\n    colorModel: GREY,\n  });\n\n  let method;\n  if (typeof algorithm === 'function') {\n    method = algorithm;\n  } else {\n    method = methods[algorithm.toLowerCase()];\n    if (!method) {\n      throw new Error(`unsupported grey algorithm: ${algorithm}`);\n    }\n  }\n\n  let ptr = 0;\n  for (let i = 0; i < this.data.length; i += this.channels) {\n    if (mergeAlpha) {\n      newImage.data[ptr++] = clamp(\n        (method(this.data[i], this.data[i + 1], this.data[i + 2], this) *\n          this.data[i + this.components]) /\n          this.maxValue,\n        this,\n      );\n    } else {\n      newImage.data[ptr++] = clamp(\n        method(this.data[i], this.data[i + 1], this.data[i + 2], this),\n        this,\n      );\n      if (newImage.alpha) {\n        newImage.data[ptr++] = this.data[i + this.components];\n      }\n    }\n  }\n\n  return newImage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}