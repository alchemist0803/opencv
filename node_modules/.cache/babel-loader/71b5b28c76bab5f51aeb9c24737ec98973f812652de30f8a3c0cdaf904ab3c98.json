{"ast":null,"code":"import Image from '../Image';\n\n/**\n * Extracts a part of an original image based on a mask. By default the mask may contain\n * a relative position and this part of the original image will be extracted.\n * @memberof Image\n * @instance\n * @param {Image} mask - Image containing a binary mask\n * @param {object} [options]\n * @param {number[]} [options.position] - Array of 2 elements to force the x,y coordinates\n * @return {Image} A new image\n */\nexport default function extract(mask, options = {}) {\n  let {\n    position\n  } = options;\n  this.checkProcessable('extract', {\n    bitDepth: [1, 8, 16]\n  });\n\n  // we need to find the relative position to the parent\n  if (!position) {\n    position = mask.getRelativePosition(this);\n    if (!position) {\n      throw new Error('extract : can not extract an image because the relative position can not be ' + 'determined, try to specify manually the position as an array of 2 elements [x,y].');\n    }\n  }\n  if (this.bitDepth > 1) {\n    let extract = Image.createFrom(this, {\n      width: mask.width,\n      height: mask.height,\n      alpha: 1,\n      // we force the alpha, otherwise difficult to extract a mask ...\n      position: position,\n      parent: this\n    });\n    for (let x = 0; x < mask.width; x++) {\n      for (let y = 0; y < mask.height; y++) {\n        // we copy the point\n        for (let channel = 0; channel < this.channels; channel++) {\n          let value = this.getValueXY(x + position[0], y + position[1], channel);\n          extract.setValueXY(x, y, channel, value);\n        }\n        // we make it transparent in case it is not in the mask\n        if (!mask.getBitXY(x, y)) {\n          extract.setValueXY(x, y, this.components, 0);\n        }\n      }\n    }\n    return extract;\n  } else {\n    let extract = Image.createFrom(this, {\n      width: mask.width,\n      height: mask.height,\n      position: position,\n      parent: this\n    });\n    for (let y = 0; y < mask.height; y++) {\n      for (let x = 0; x < mask.width; x++) {\n        if (mask.getBitXY(x, y)) {\n          if (this.getBitXY(x + position[0], y + position[1])) {\n            extract.setBitXY(x, y);\n          }\n        }\n      }\n    }\n    return extract;\n  }\n}","map":{"version":3,"names":["Image","extract","mask","options","position","checkProcessable","bitDepth","getRelativePosition","Error","createFrom","width","height","alpha","parent","x","y","channel","channels","value","getValueXY","setValueXY","getBitXY","components","setBitXY"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/operator/extract.js"],"sourcesContent":["import Image from '../Image';\n\n/**\n * Extracts a part of an original image based on a mask. By default the mask may contain\n * a relative position and this part of the original image will be extracted.\n * @memberof Image\n * @instance\n * @param {Image} mask - Image containing a binary mask\n * @param {object} [options]\n * @param {number[]} [options.position] - Array of 2 elements to force the x,y coordinates\n * @return {Image} A new image\n */\nexport default function extract(mask, options = {}) {\n  let { position } = options;\n  this.checkProcessable('extract', {\n    bitDepth: [1, 8, 16],\n  });\n\n  // we need to find the relative position to the parent\n  if (!position) {\n    position = mask.getRelativePosition(this);\n    if (!position) {\n      throw new Error(\n        'extract : can not extract an image because the relative position can not be ' +\n          'determined, try to specify manually the position as an array of 2 elements [x,y].',\n      );\n    }\n  }\n\n  if (this.bitDepth > 1) {\n    let extract = Image.createFrom(this, {\n      width: mask.width,\n      height: mask.height,\n      alpha: 1, // we force the alpha, otherwise difficult to extract a mask ...\n      position: position,\n      parent: this,\n    });\n\n    for (let x = 0; x < mask.width; x++) {\n      for (let y = 0; y < mask.height; y++) {\n        // we copy the point\n        for (let channel = 0; channel < this.channels; channel++) {\n          let value = this.getValueXY(\n            x + position[0],\n            y + position[1],\n            channel,\n          );\n          extract.setValueXY(x, y, channel, value);\n        }\n        // we make it transparent in case it is not in the mask\n        if (!mask.getBitXY(x, y)) {\n          extract.setValueXY(x, y, this.components, 0);\n        }\n      }\n    }\n\n    return extract;\n  } else {\n    let extract = Image.createFrom(this, {\n      width: mask.width,\n      height: mask.height,\n      position: position,\n      parent: this,\n    });\n    for (let y = 0; y < mask.height; y++) {\n      for (let x = 0; x < mask.width; x++) {\n        if (mask.getBitXY(x, y)) {\n          if (this.getBitXY(x + position[0], y + position[1])) {\n            extract.setBitXY(x, y);\n          }\n        }\n      }\n    }\n\n    return extract;\n  }\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,UAAU;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,OAAOA,CAACC,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAClD,IAAI;IAAEC;EAAS,CAAC,GAAGD,OAAO;EAC1B,IAAI,CAACE,gBAAgB,CAAC,SAAS,EAAE;IAC/BC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;EACrB,CAAC,CAAC;;EAEF;EACA,IAAI,CAACF,QAAQ,EAAE;IACbA,QAAQ,GAAGF,IAAI,CAACK,mBAAmB,CAAC,IAAI,CAAC;IACzC,IAAI,CAACH,QAAQ,EAAE;MACb,MAAM,IAAII,KAAK,CACb,8EAA8E,GAC5E,mFACJ,CAAC;IACH;EACF;EAEA,IAAI,IAAI,CAACF,QAAQ,GAAG,CAAC,EAAE;IACrB,IAAIL,OAAO,GAAGD,KAAK,CAACS,UAAU,CAAC,IAAI,EAAE;MACnCC,KAAK,EAAER,IAAI,CAACQ,KAAK;MACjBC,MAAM,EAAET,IAAI,CAACS,MAAM;MACnBC,KAAK,EAAE,CAAC;MAAE;MACVR,QAAQ,EAAEA,QAAQ;MAClBS,MAAM,EAAE;IACV,CAAC,CAAC;IAEF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,IAAI,CAACQ,KAAK,EAAEI,CAAC,EAAE,EAAE;MACnC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,IAAI,CAACS,MAAM,EAAEI,CAAC,EAAE,EAAE;QACpC;QACA,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAG,IAAI,CAACC,QAAQ,EAAED,OAAO,EAAE,EAAE;UACxD,IAAIE,KAAK,GAAG,IAAI,CAACC,UAAU,CACzBL,CAAC,GAAGV,QAAQ,CAAC,CAAC,CAAC,EACfW,CAAC,GAAGX,QAAQ,CAAC,CAAC,CAAC,EACfY,OACF,CAAC;UACDf,OAAO,CAACmB,UAAU,CAACN,CAAC,EAAEC,CAAC,EAAEC,OAAO,EAAEE,KAAK,CAAC;QAC1C;QACA;QACA,IAAI,CAAChB,IAAI,CAACmB,QAAQ,CAACP,CAAC,EAAEC,CAAC,CAAC,EAAE;UACxBd,OAAO,CAACmB,UAAU,CAACN,CAAC,EAAEC,CAAC,EAAE,IAAI,CAACO,UAAU,EAAE,CAAC,CAAC;QAC9C;MACF;IACF;IAEA,OAAOrB,OAAO;EAChB,CAAC,MAAM;IACL,IAAIA,OAAO,GAAGD,KAAK,CAACS,UAAU,CAAC,IAAI,EAAE;MACnCC,KAAK,EAAER,IAAI,CAACQ,KAAK;MACjBC,MAAM,EAAET,IAAI,CAACS,MAAM;MACnBP,QAAQ,EAAEA,QAAQ;MAClBS,MAAM,EAAE;IACV,CAAC,CAAC;IACF,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,IAAI,CAACS,MAAM,EAAEI,CAAC,EAAE,EAAE;MACpC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,IAAI,CAACQ,KAAK,EAAEI,CAAC,EAAE,EAAE;QACnC,IAAIZ,IAAI,CAACmB,QAAQ,CAACP,CAAC,EAAEC,CAAC,CAAC,EAAE;UACvB,IAAI,IAAI,CAACM,QAAQ,CAACP,CAAC,GAAGV,QAAQ,CAAC,CAAC,CAAC,EAAEW,CAAC,GAAGX,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;YACnDH,OAAO,CAACsB,QAAQ,CAACT,CAAC,EAAEC,CAAC,CAAC;UACxB;QACF;MACF;IACF;IAEA,OAAOd,OAAO;EAChB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}