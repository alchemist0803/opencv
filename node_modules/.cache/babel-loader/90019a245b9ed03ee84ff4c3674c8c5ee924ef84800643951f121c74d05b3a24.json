{"ast":null,"code":"import Stack from '../Stack';\n\n// TODO this code seems buggy if it is not 0,0\n/**\n * We will try to move a set of images in order to get only the best common part of them.\n * In a stack, we compare 2 consecutive images or directly to a parent.\n * Ignoring border may be dangerous ! If there is a shape on the side of the image there will be a\n * continuous shift if you ignore border. By default it is better to leave it to 0,0\n * Now if the background is not black there will also be no way to shift ...\n * It may therefore be much better to make a background correction before trying to match and crop.\n * @memberof Stack\n * @instance\n * @param {object} [options]\n * @param {string} [options.algorithm='matchToPrevious'] - matchToPrevious or matchToFirst\n * @param {number[]} [options.ignoreBorder=[0, 0]]\n * @return {Stack}\n */\nexport default function matchAndCrop(options = {}) {\n  let {\n    algorithm = 'matchToPrevious',\n    ignoreBorder = [0, 0]\n  } = options;\n  this.checkProcessable('matchAndCrop', {\n    bitDepth: [8, 16]\n  });\n  let matchToPrevious = algorithm === 'matchToPrevious';\n  let parent = this[0];\n  let results = [];\n  results[0] = {\n    position: [0, 0],\n    image: this[0]\n  };\n  let relativePosition = [0, 0];\n\n  // we calculate the best relative position to the parent image\n  for (let i = 1; i < this.length; i++) {\n    let position = parent.getBestMatch(this[i], {\n      border: ignoreBorder\n    });\n    results[i] = {\n      position: [position[0] + relativePosition[0], position[1] + relativePosition[1]],\n      image: this[i]\n    };\n    if (matchToPrevious) {\n      relativePosition[0] += position[0];\n      relativePosition[1] += position[1];\n      parent = this[i];\n    }\n  }\n  // now we can calculate the cropping that we need to do\n\n  let leftShift = 0;\n  let rightShift = 0;\n  let topShift = 0;\n  let bottomShift = 0;\n  for (let i = 0; i < results.length; i++) {\n    let result = results[i];\n    if (result.position[0] > leftShift) {\n      leftShift = result.position[0];\n    }\n    if (result.position[0] < rightShift) {\n      rightShift = result.position[0];\n    }\n    if (result.position[1] > topShift) {\n      topShift = result.position[1];\n    }\n    if (result.position[1] < bottomShift) {\n      bottomShift = result.position[1];\n    }\n  }\n  rightShift = 0 - rightShift;\n  bottomShift = 0 - bottomShift;\n  for (let i = 0; i < results.length; i++) {\n    let result = results[i];\n    result.crop = result.image.crop({\n      x: leftShift - result.position[0],\n      y: topShift - result.position[1],\n      width: parent.width - rightShift - leftShift,\n      height: parent.height - bottomShift - topShift\n    });\n  }\n\n  // finally we crop and create a new array of images\n  let newImages = [];\n  for (let i = 0; i < results.length; i++) {\n    newImages[i] = results[i].crop;\n  }\n  return new Stack(newImages);\n}","map":{"version":3,"names":["Stack","matchAndCrop","options","algorithm","ignoreBorder","checkProcessable","bitDepth","matchToPrevious","parent","results","position","image","relativePosition","i","length","getBestMatch","border","leftShift","rightShift","topShift","bottomShift","result","crop","x","y","width","height","newImages"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/stack/transform/matchAndCrop.js"],"sourcesContent":["import Stack from '../Stack';\n\n// TODO this code seems buggy if it is not 0,0\n/**\n * We will try to move a set of images in order to get only the best common part of them.\n * In a stack, we compare 2 consecutive images or directly to a parent.\n * Ignoring border may be dangerous ! If there is a shape on the side of the image there will be a\n * continuous shift if you ignore border. By default it is better to leave it to 0,0\n * Now if the background is not black there will also be no way to shift ...\n * It may therefore be much better to make a background correction before trying to match and crop.\n * @memberof Stack\n * @instance\n * @param {object} [options]\n * @param {string} [options.algorithm='matchToPrevious'] - matchToPrevious or matchToFirst\n * @param {number[]} [options.ignoreBorder=[0, 0]]\n * @return {Stack}\n */\nexport default function matchAndCrop(options = {}) {\n  let { algorithm = 'matchToPrevious', ignoreBorder = [0, 0] } = options;\n\n  this.checkProcessable('matchAndCrop', {\n    bitDepth: [8, 16],\n  });\n\n  let matchToPrevious = algorithm === 'matchToPrevious';\n\n  let parent = this[0];\n  let results = [];\n  results[0] = {\n    position: [0, 0],\n    image: this[0],\n  };\n\n  let relativePosition = [0, 0];\n\n  // we calculate the best relative position to the parent image\n  for (let i = 1; i < this.length; i++) {\n    let position = parent.getBestMatch(this[i], { border: ignoreBorder });\n\n    results[i] = {\n      position: [\n        position[0] + relativePosition[0],\n        position[1] + relativePosition[1],\n      ],\n      image: this[i],\n    };\n    if (matchToPrevious) {\n      relativePosition[0] += position[0];\n      relativePosition[1] += position[1];\n      parent = this[i];\n    }\n  }\n  // now we can calculate the cropping that we need to do\n\n  let leftShift = 0;\n  let rightShift = 0;\n  let topShift = 0;\n  let bottomShift = 0;\n\n  for (let i = 0; i < results.length; i++) {\n    let result = results[i];\n    if (result.position[0] > leftShift) {\n      leftShift = result.position[0];\n    }\n    if (result.position[0] < rightShift) {\n      rightShift = result.position[0];\n    }\n    if (result.position[1] > topShift) {\n      topShift = result.position[1];\n    }\n    if (result.position[1] < bottomShift) {\n      bottomShift = result.position[1];\n    }\n  }\n  rightShift = 0 - rightShift;\n  bottomShift = 0 - bottomShift;\n\n  for (let i = 0; i < results.length; i++) {\n    let result = results[i];\n\n    result.crop = result.image.crop({\n      x: leftShift - result.position[0],\n      y: topShift - result.position[1],\n      width: parent.width - rightShift - leftShift,\n      height: parent.height - bottomShift - topShift,\n    });\n  }\n\n  // finally we crop and create a new array of images\n  let newImages = [];\n  for (let i = 0; i < results.length; i++) {\n    newImages[i] = results[i].crop;\n  }\n\n  return new Stack(newImages);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}