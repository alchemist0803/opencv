{"ast":null,"code":"import { css2array } from '../../util/color';\nimport { RGB } from '../model/model';\n\n/**\n * Paint a label or labels on the current image.\n * @memberof Image\n * @instance\n *\n * @param {Array<string>}           [labels] - Array of labels to display.\n * @param {Array<Array<number>>}    [positions] - Array of points [x,y] where the labels should be displayed.\n * @param {object}                  [options]\n * @param {Array<number>|string}    [options.color='red'] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each label.\n * @param {string|Array<string>} [options.font='12px Helvetica'] - Paint the labels in a different CSS style\n * @param {number|Array<number>} [options.rotate=0] - Rotate each label of a define angle\n * @return {this} The original painted image\n */\nexport default function paintLabels(labels, positions, options = {}) {\n  let {\n    color = 'blue',\n    colors,\n    font = '12px Helvetica',\n    rotate = 0\n  } = options;\n  this.checkProcessable('paintMasks', {\n    channels: [3, 4],\n    bitDepth: [8, 16],\n    colorModel: RGB\n  });\n  if (!Array.isArray(labels)) {\n    throw Error('paintLabels: labels must be an array');\n  }\n  if (!Array.isArray(positions)) {\n    throw Error('paintLabels: positions must be an array');\n  }\n  if (color && !Array.isArray(color)) {\n    color = css2array(color);\n  }\n  if (colors) {\n    colors = colors.map(function (color) {\n      if (!Array.isArray(color)) {\n        return css2array(color);\n      }\n      return color;\n    });\n  } else {\n    colors = [color];\n  }\n  if (labels.length !== positions.length) {\n    throw Error('paintLabels: positions and labels must be arrays from the same size');\n  }\n\n  // We convert everything to array so that we can simply loop thourgh all the labels\n  if (!Array.isArray(font)) font = [font];\n  if (!Array.isArray(rotate)) rotate = [rotate];\n  let canvas = this.getCanvas();\n  let ctx = canvas.getContext('2d');\n  for (let i = 0; i < labels.length; i++) {\n    ctx.save();\n    let color = colors[i % colors.length];\n    ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${color[3] / this.maxValue})`;\n    ctx.font = font[i % font.length];\n    let position = positions[i];\n    ctx.translate(position[0], position[1]);\n    ctx.rotate(rotate[i % rotate.length] / 180 * Math.PI);\n    ctx.fillText(labels[i], 0, 0);\n    ctx.restore();\n  }\n  this.data = Uint8Array.from(ctx.getImageData(0, 0, this.width, this.height).data);\n  return this;\n}","map":{"version":3,"names":["css2array","RGB","paintLabels","labels","positions","options","color","colors","font","rotate","checkProcessable","channels","bitDepth","colorModel","Array","isArray","Error","map","length","canvas","getCanvas","ctx","getContext","i","save","fillStyle","maxValue","position","translate","Math","PI","fillText","restore","data","Uint8Array","from","getImageData","width","height"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/operator/paintLabels.js"],"sourcesContent":["import { css2array } from '../../util/color';\nimport { RGB } from '../model/model';\n\n/**\n * Paint a label or labels on the current image.\n * @memberof Image\n * @instance\n *\n * @param {Array<string>}           [labels] - Array of labels to display.\n * @param {Array<Array<number>>}    [positions] - Array of points [x,y] where the labels should be displayed.\n * @param {object}                  [options]\n * @param {Array<number>|string}    [options.color='red'] - Array of 3 elements (R, G, B) or a valid css color.\n * @param {Array<Array<number>>|Array<string>} [options.colors] - Array of Array of 3 elements (R, G, B) for each color of each label.\n * @param {string|Array<string>} [options.font='12px Helvetica'] - Paint the labels in a different CSS style\n * @param {number|Array<number>} [options.rotate=0] - Rotate each label of a define angle\n * @return {this} The original painted image\n */\nexport default function paintLabels(labels, positions, options = {}) {\n  let { color = 'blue', colors, font = '12px Helvetica', rotate = 0 } = options;\n\n  this.checkProcessable('paintMasks', {\n    channels: [3, 4],\n    bitDepth: [8, 16],\n    colorModel: RGB,\n  });\n\n  if (!Array.isArray(labels)) {\n    throw Error('paintLabels: labels must be an array');\n  }\n\n  if (!Array.isArray(positions)) {\n    throw Error('paintLabels: positions must be an array');\n  }\n\n  if (color && !Array.isArray(color)) {\n    color = css2array(color);\n  }\n\n  if (colors) {\n    colors = colors.map(function (color) {\n      if (!Array.isArray(color)) {\n        return css2array(color);\n      }\n      return color;\n    });\n  } else {\n    colors = [color];\n  }\n\n  if (labels.length !== positions.length) {\n    throw Error(\n      'paintLabels: positions and labels must be arrays from the same size',\n    );\n  }\n\n  // We convert everything to array so that we can simply loop thourgh all the labels\n  if (!Array.isArray(font)) font = [font];\n  if (!Array.isArray(rotate)) rotate = [rotate];\n\n  let canvas = this.getCanvas();\n  let ctx = canvas.getContext('2d');\n  for (let i = 0; i < labels.length; i++) {\n    ctx.save();\n    let color = colors[i % colors.length];\n    ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${\n      color[3] / this.maxValue\n    })`;\n    ctx.font = font[i % font.length];\n    let position = positions[i];\n    ctx.translate(position[0], position[1]);\n    ctx.rotate((rotate[i % rotate.length] / 180) * Math.PI);\n    ctx.fillText(labels[i], 0, 0);\n    ctx.restore();\n  }\n  this.data = Uint8Array.from(\n    ctx.getImageData(0, 0, this.width, this.height).data,\n  );\n\n  return this;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}