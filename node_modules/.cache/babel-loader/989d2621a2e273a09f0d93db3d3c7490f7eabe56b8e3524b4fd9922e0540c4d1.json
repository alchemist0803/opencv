{"ast":null,"code":"import PriorityQueue from 'js-priority-queue';\nimport { dxs, dys } from '../../../util/dxdy.js';\nimport RoiMap from '../RoiMap';\n\n/**\n * This method allows to create a ROIMap using the water shed algorithm. By default this algorithm\n * will fill the holes and therefore the lowest value of the image (black zones).\n * If no points are given, the function will look for all the minimal points.\n * If no mask is given the algorithm will completely fill the image.\n * Please take care about the value that has be in the mask ! In order to be coherent with the expected mask,\n * meaning that if it is a dark zone, the mask will be dark the normal behaviour to fill a zone\n * is that the mask pixel is clear (value of 0) !\n * However if you work in the 'invert' mode, the mask value has to be 'set' and the method will look for\n * maxima.\n * @memberof RoiManager\n * @instance\n * @param {object} [options={}]\n * @param {Array<Array<number>>} [options.points] - Array of points [[x1,y1], [x2,y2], ...].\n * @param {number} [options.fillMaxValue] - Limit of filling. By example, we can fill to a maximum value 32000 of a 16 bitDepth image.\n *          If invert this will corresponds to the minimal value\n * @param {Image} [options.image=this] - By default the waterShed will be applied on the current image. However waterShed can only be applied\n *                              on 1 component image. This allows to specify a grey scale image on which to apply waterShed..\n * @param {Image} [options.mask] - A binary image, the same size as the image. The algorithm will fill only if the current pixel in the binary mask is true.\n * @param {boolean} [options.invert=false] - By default we fill the minima\n * @return {RoiMap}\n */\nexport default function fromWaterShed(options = {}) {\n  let {\n    points,\n    mask,\n    image,\n    fillMaxValue = this.maxValue,\n    invert = false\n  } = options;\n  let currentImage = image || this;\n  currentImage.checkProcessable('fromWaterShed', {\n    bitDepth: [8, 16],\n    components: 1\n  });\n\n  /*\n     We need to invert the logic because we are always using method to look for maxima and not minima and\n     here water is expected to fill the minima first ...\n    */\n\n  invert = !invert;\n\n  // WaterShed is done from points in the image. We can either specify those points in options,\n  // or it is gonna take the minimum locals of the image by default.\n  if (!points) {\n    points = currentImage.getLocalMaxima({\n      invert,\n      mask\n    });\n  }\n  let maskExpectedValue = invert ? 0 : 1;\n  let data = new Int16Array(currentImage.size);\n  let width = currentImage.width;\n  let height = currentImage.height;\n  let toProcess = new PriorityQueue({\n    comparator: (a, b) => a[2] - b[2],\n    strategy: PriorityQueue.BinaryHeapStrategy\n  });\n  for (let i = 0; i < points.length; i++) {\n    let index = points[i][0] + points[i][1] * width;\n    data[index] = i + 1;\n    let intensity = currentImage.data[index];\n    if (invert && intensity <= fillMaxValue || !invert && intensity >= fillMaxValue) {\n      toProcess.queue([points[i][0], points[i][1], intensity]);\n    }\n  }\n\n  // Then we iterate through each points\n  while (toProcess.length > 0) {\n    let currentPoint = toProcess.dequeue();\n    let currentValueIndex = currentPoint[0] + currentPoint[1] * width;\n    for (let dir = 0; dir < 4; dir++) {\n      let newX = currentPoint[0] + dxs[dir];\n      let newY = currentPoint[1] + dys[dir];\n      if (newX >= 0 && newY >= 0 && newX < width && newY < height) {\n        let currentNeighbourIndex = newX + newY * width;\n        if (!mask || mask.getBit(currentNeighbourIndex) === maskExpectedValue) {\n          let intensity = currentImage.data[currentNeighbourIndex];\n          if (invert && intensity <= fillMaxValue || !invert && intensity >= fillMaxValue) {\n            if (data[currentNeighbourIndex] === 0) {\n              data[currentNeighbourIndex] = data[currentValueIndex];\n              toProcess.queue([currentPoint[0] + dxs[dir], currentPoint[1] + dys[dir], intensity]);\n            }\n          }\n        }\n      }\n    }\n  }\n  return new RoiMap(currentImage, data);\n}","map":{"version":3,"names":["PriorityQueue","dxs","dys","RoiMap","fromWaterShed","options","points","mask","image","fillMaxValue","maxValue","invert","currentImage","checkProcessable","bitDepth","components","getLocalMaxima","maskExpectedValue","data","Int16Array","size","width","height","toProcess","comparator","a","b","strategy","BinaryHeapStrategy","i","length","index","intensity","queue","currentPoint","dequeue","currentValueIndex","dir","newX","newY","currentNeighbourIndex","getBit"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/roi/creator/fromWaterShed.js"],"sourcesContent":["import PriorityQueue from 'js-priority-queue';\n\nimport { dxs, dys } from '../../../util/dxdy.js';\nimport RoiMap from '../RoiMap';\n\n/**\n * This method allows to create a ROIMap using the water shed algorithm. By default this algorithm\n * will fill the holes and therefore the lowest value of the image (black zones).\n * If no points are given, the function will look for all the minimal points.\n * If no mask is given the algorithm will completely fill the image.\n * Please take care about the value that has be in the mask ! In order to be coherent with the expected mask,\n * meaning that if it is a dark zone, the mask will be dark the normal behaviour to fill a zone\n * is that the mask pixel is clear (value of 0) !\n * However if you work in the 'invert' mode, the mask value has to be 'set' and the method will look for\n * maxima.\n * @memberof RoiManager\n * @instance\n * @param {object} [options={}]\n * @param {Array<Array<number>>} [options.points] - Array of points [[x1,y1], [x2,y2], ...].\n * @param {number} [options.fillMaxValue] - Limit of filling. By example, we can fill to a maximum value 32000 of a 16 bitDepth image.\n *          If invert this will corresponds to the minimal value\n * @param {Image} [options.image=this] - By default the waterShed will be applied on the current image. However waterShed can only be applied\n *                              on 1 component image. This allows to specify a grey scale image on which to apply waterShed..\n * @param {Image} [options.mask] - A binary image, the same size as the image. The algorithm will fill only if the current pixel in the binary mask is true.\n * @param {boolean} [options.invert=false] - By default we fill the minima\n * @return {RoiMap}\n */\nexport default function fromWaterShed(options = {}) {\n  let {\n    points,\n    mask,\n    image,\n    fillMaxValue = this.maxValue,\n    invert = false,\n  } = options;\n  let currentImage = image || this;\n  currentImage.checkProcessable('fromWaterShed', {\n    bitDepth: [8, 16],\n    components: 1,\n  });\n\n  /*\n     We need to invert the logic because we are always using method to look for maxima and not minima and\n     here water is expected to fill the minima first ...\n    */\n\n  invert = !invert;\n\n  // WaterShed is done from points in the image. We can either specify those points in options,\n  // or it is gonna take the minimum locals of the image by default.\n  if (!points) {\n    points = currentImage.getLocalMaxima({\n      invert,\n      mask,\n    });\n  }\n\n  let maskExpectedValue = invert ? 0 : 1;\n\n  let data = new Int16Array(currentImage.size);\n  let width = currentImage.width;\n  let height = currentImage.height;\n  let toProcess = new PriorityQueue({\n    comparator: (a, b) => a[2] - b[2],\n    strategy: PriorityQueue.BinaryHeapStrategy,\n  });\n  for (let i = 0; i < points.length; i++) {\n    let index = points[i][0] + points[i][1] * width;\n    data[index] = i + 1;\n    let intensity = currentImage.data[index];\n    if (\n      (invert && intensity <= fillMaxValue) ||\n      (!invert && intensity >= fillMaxValue)\n    ) {\n      toProcess.queue([points[i][0], points[i][1], intensity]);\n    }\n  }\n\n  // Then we iterate through each points\n  while (toProcess.length > 0) {\n    let currentPoint = toProcess.dequeue();\n    let currentValueIndex = currentPoint[0] + currentPoint[1] * width;\n\n    for (let dir = 0; dir < 4; dir++) {\n      let newX = currentPoint[0] + dxs[dir];\n      let newY = currentPoint[1] + dys[dir];\n      if (newX >= 0 && newY >= 0 && newX < width && newY < height) {\n        let currentNeighbourIndex = newX + newY * width;\n        if (!mask || mask.getBit(currentNeighbourIndex) === maskExpectedValue) {\n          let intensity = currentImage.data[currentNeighbourIndex];\n          if (\n            (invert && intensity <= fillMaxValue) ||\n            (!invert && intensity >= fillMaxValue)\n          ) {\n            if (data[currentNeighbourIndex] === 0) {\n              data[currentNeighbourIndex] = data[currentValueIndex];\n              toProcess.queue([\n                currentPoint[0] + dxs[dir],\n                currentPoint[1] + dys[dir],\n                intensity,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return new RoiMap(currentImage, data);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}