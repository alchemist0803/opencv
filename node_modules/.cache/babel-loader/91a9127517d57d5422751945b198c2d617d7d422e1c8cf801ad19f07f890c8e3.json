{"ast":null,"code":"/**\n * In place modification of the roiMap that joins regions of interest\n * @param {object} [options]\n * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.\n *      Current implemented algorithms are 'commonBorderLength' that use the parameters\n *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses\n *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.\n * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging\n * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging\n * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging\n * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging\n * @return {this}\n * @private\n */\nexport default function mergeRoi(options = {}) {\n  const {\n    algorithm = 'commonBorderLength',\n    minCommonBorderLength = 5,\n    maxCommonBorderLength = 100,\n    minCommonBorderRatio = 0.3,\n    maxCommonBorderRatio = 1\n  } = options;\n  let checkFunction = function (currentInfo, currentID, neighbourID) {\n    return currentInfo[neighbourID] >= minCommonBorderLength && currentInfo[neighbourID] <= maxCommonBorderLength;\n  };\n  if (typeof algorithm === 'function') {\n    checkFunction = algorithm;\n  }\n  if (algorithm.toLowerCase() === 'commonborderratio') {\n    checkFunction = function (currentInfo, currentID, neighbourID) {\n      let ratio = Math.min(currentInfo[neighbourID] / currentInfo[currentID], 1);\n      return ratio >= minCommonBorderRatio && ratio <= maxCommonBorderRatio;\n    };\n  }\n  const roiMap = this;\n  const borderLengths = roiMap.commonBorderLength;\n  let newMap = {};\n  let oldToNew = {};\n  for (let currentID of Object.keys(borderLengths)) {\n    let currentInfo = borderLengths[currentID];\n    let neighbourIDs = Object.keys(currentInfo);\n    for (let neighbourID of neighbourIDs) {\n      if (neighbourID !== currentID) {\n        // it is not myself ...\n        if (checkFunction(currentInfo, currentID, neighbourID)) {\n          // the common border are in the range. We should merge\n          let newNeighbourID = neighbourID;\n          if (oldToNew[neighbourID]) newNeighbourID = oldToNew[neighbourID];\n          let newCurrentID = currentID;\n          if (oldToNew[currentID]) newCurrentID = oldToNew[currentID];\n          if (Number(newNeighbourID) !== newCurrentID) {\n            let smallerID = Math.min(newNeighbourID, newCurrentID);\n            let largerID = Math.max(newNeighbourID, newCurrentID);\n            if (!newMap[smallerID]) {\n              newMap[smallerID] = {};\n            }\n            newMap[smallerID][largerID] = true;\n            oldToNew[largerID] = smallerID;\n            if (newMap[largerID]) {\n              // need to put everything to smallerID and remove property\n              for (let id of Object.keys(newMap[largerID])) {\n                newMap[smallerID][id] = true;\n                oldToNew[id] = smallerID;\n              }\n              delete newMap[largerID];\n            }\n          }\n        }\n      }\n    }\n  }\n  let minMax = roiMap.minMax;\n  let shift = -minMax.min;\n  let max = minMax.max + shift;\n  let oldToNewArray = new Array(max + 1).fill(0);\n  for (let key of Object.keys(oldToNew)) {\n    oldToNewArray[Number(key) + shift] = oldToNew[key];\n  }\n  // time to change the roiMap\n  let data = roiMap.data;\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data[i];\n    if (currentValue !== 0) {\n      let newValue = oldToNewArray[currentValue + shift];\n      if (newValue !== 0) {\n        data[i] = newValue;\n      }\n    }\n  }\n  roiMap.computed = {};\n  return roiMap;\n}","map":{"version":3,"names":["mergeRoi","options","algorithm","minCommonBorderLength","maxCommonBorderLength","minCommonBorderRatio","maxCommonBorderRatio","checkFunction","currentInfo","currentID","neighbourID","toLowerCase","ratio","Math","min","roiMap","borderLengths","commonBorderLength","newMap","oldToNew","Object","keys","neighbourIDs","newNeighbourID","newCurrentID","Number","smallerID","largerID","max","id","minMax","shift","oldToNewArray","Array","fill","key","data","i","length","currentValue","newValue","computed"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/roi/util/mergeRoi.js"],"sourcesContent":["/**\n * In place modification of the roiMap that joins regions of interest\n * @param {object} [options]\n * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.\n *      Current implemented algorithms are 'commonBorderLength' that use the parameters\n *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses\n *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.\n * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging\n * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging\n * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging\n * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging\n * @return {this}\n * @private\n */\nexport default function mergeRoi(options = {}) {\n  const {\n    algorithm = 'commonBorderLength',\n    minCommonBorderLength = 5,\n    maxCommonBorderLength = 100,\n    minCommonBorderRatio = 0.3,\n    maxCommonBorderRatio = 1,\n  } = options;\n\n  let checkFunction = function (currentInfo, currentID, neighbourID) {\n    return (\n      currentInfo[neighbourID] >= minCommonBorderLength &&\n      currentInfo[neighbourID] <= maxCommonBorderLength\n    );\n  };\n  if (typeof algorithm === 'function') {\n    checkFunction = algorithm;\n  }\n  if (algorithm.toLowerCase() === 'commonborderratio') {\n    checkFunction = function (currentInfo, currentID, neighbourID) {\n      let ratio = Math.min(\n        currentInfo[neighbourID] / currentInfo[currentID],\n        1,\n      );\n      return ratio >= minCommonBorderRatio && ratio <= maxCommonBorderRatio;\n    };\n  }\n  const roiMap = this;\n  const borderLengths = roiMap.commonBorderLength;\n  let newMap = {};\n  let oldToNew = {};\n\n  for (let currentID of Object.keys(borderLengths)) {\n    let currentInfo = borderLengths[currentID];\n    let neighbourIDs = Object.keys(currentInfo);\n    for (let neighbourID of neighbourIDs) {\n      if (neighbourID !== currentID) {\n        // it is not myself ...\n        if (checkFunction(currentInfo, currentID, neighbourID)) {\n          // the common border are in the range. We should merge\n          let newNeighbourID = neighbourID;\n          if (oldToNew[neighbourID]) newNeighbourID = oldToNew[neighbourID];\n          let newCurrentID = currentID;\n          if (oldToNew[currentID]) newCurrentID = oldToNew[currentID];\n\n          if (Number(newNeighbourID) !== newCurrentID) {\n            let smallerID = Math.min(newNeighbourID, newCurrentID);\n            let largerID = Math.max(newNeighbourID, newCurrentID);\n\n            if (!newMap[smallerID]) {\n              newMap[smallerID] = {};\n            }\n            newMap[smallerID][largerID] = true;\n            oldToNew[largerID] = smallerID;\n            if (newMap[largerID]) {\n              // need to put everything to smallerID and remove property\n              for (let id of Object.keys(newMap[largerID])) {\n                newMap[smallerID][id] = true;\n                oldToNew[id] = smallerID;\n              }\n              delete newMap[largerID];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  let minMax = roiMap.minMax;\n  let shift = -minMax.min;\n  let max = minMax.max + shift;\n  let oldToNewArray = new Array(max + 1).fill(0);\n  for (let key of Object.keys(oldToNew)) {\n    oldToNewArray[Number(key) + shift] = oldToNew[key];\n  }\n  // time to change the roiMap\n  let data = roiMap.data;\n  for (let i = 0; i < data.length; i++) {\n    let currentValue = data[i];\n    if (currentValue !== 0) {\n      let newValue = oldToNewArray[currentValue + shift];\n      if (newValue !== 0) {\n        data[i] = newValue;\n      }\n    }\n  }\n\n  roiMap.computed = {};\n  return roiMap;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}