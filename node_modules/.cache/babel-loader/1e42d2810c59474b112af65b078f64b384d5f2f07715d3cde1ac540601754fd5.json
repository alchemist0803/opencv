{"ast":null,"code":"'use strict';\n\nconst {\n  Matrix,\n  MatrixTransposeView\n} = require('ml-matrix');\nconst GaussianKernel = require('ml-kernel-gaussian');\nconst PolynomialKernel = require('ml-kernel-polynomial');\nconst SigmoidKernel = require('ml-kernel-sigmoid');\nconst ANOVAKernel = require('./kernels/anova-kernel');\nconst CauchyKernel = require('./kernels/cauchy-kernel');\nconst ExponentialKernel = require('./kernels/exponential-kernel');\nconst HistogramKernel = require('./kernels/histogram-intersection-kernel');\nconst LaplacianKernel = require('./kernels/laplacian-kernel');\nconst MultiquadraticKernel = require('./kernels/multiquadratic-kernel');\nconst RationalKernel = require('./kernels/rational-quadratic-kernel');\nconst kernelType = {\n  gaussian: GaussianKernel,\n  rbf: GaussianKernel,\n  polynomial: PolynomialKernel,\n  poly: PolynomialKernel,\n  anova: ANOVAKernel,\n  cauchy: CauchyKernel,\n  exponential: ExponentialKernel,\n  histogram: HistogramKernel,\n  min: HistogramKernel,\n  laplacian: LaplacianKernel,\n  multiquadratic: MultiquadraticKernel,\n  rational: RationalKernel,\n  sigmoid: SigmoidKernel,\n  mlp: SigmoidKernel\n};\nclass Kernel {\n  constructor(type, options) {\n    this.kernelType = type;\n    if (type === 'linear') return;\n    if (typeof type === 'string') {\n      type = type.toLowerCase();\n      var KernelConstructor = kernelType[type];\n      if (KernelConstructor) {\n        this.kernelFunction = new KernelConstructor(options);\n      } else {\n        throw new Error(`unsupported kernel type: ${type}`);\n      }\n    } else if (typeof type === 'object' && typeof type.compute === 'function') {\n      this.kernelFunction = type;\n    } else {\n      throw new TypeError('first argument must be a valid kernel type or instance');\n    }\n  }\n  compute(inputs, landmarks) {\n    inputs = Matrix.checkMatrix(inputs);\n    if (landmarks === undefined) {\n      landmarks = inputs;\n    } else {\n      landmarks = Matrix.checkMatrix(landmarks);\n    }\n    if (this.kernelType === 'linear') {\n      return inputs.mmul(new MatrixTransposeView(landmarks));\n    }\n    const kernelMatrix = new Matrix(inputs.rows, landmarks.rows);\n    if (inputs === landmarks) {\n      // fast path, matrix is symmetric\n      for (let i = 0; i < inputs.rows; i++) {\n        for (let j = i; j < inputs.rows; j++) {\n          const value = this.kernelFunction.compute(inputs.getRow(i), inputs.getRow(j));\n          kernelMatrix.set(i, j, value);\n          kernelMatrix.set(j, i, value);\n        }\n      }\n    } else {\n      for (let i = 0; i < inputs.rows; i++) {\n        for (let j = 0; j < landmarks.rows; j++) {\n          kernelMatrix.set(i, j, this.kernelFunction.compute(inputs.getRow(i), landmarks.getRow(j)));\n        }\n      }\n    }\n    return kernelMatrix;\n  }\n}\nmodule.exports = Kernel;","map":{"version":3,"names":["Matrix","MatrixTransposeView","require","GaussianKernel","PolynomialKernel","SigmoidKernel","ANOVAKernel","CauchyKernel","ExponentialKernel","HistogramKernel","LaplacianKernel","MultiquadraticKernel","RationalKernel","kernelType","gaussian","rbf","polynomial","poly","anova","cauchy","exponential","histogram","min","laplacian","multiquadratic","rational","sigmoid","mlp","Kernel","constructor","type","options","toLowerCase","KernelConstructor","kernelFunction","Error","compute","TypeError","inputs","landmarks","checkMatrix","undefined","mmul","kernelMatrix","rows","i","j","value","getRow","set","module","exports"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/ml-kernel/src/kernel.js"],"sourcesContent":["'use strict';\n\nconst { Matrix, MatrixTransposeView } = require('ml-matrix');\nconst GaussianKernel = require('ml-kernel-gaussian');\nconst PolynomialKernel = require('ml-kernel-polynomial');\nconst SigmoidKernel = require('ml-kernel-sigmoid');\n\nconst ANOVAKernel = require('./kernels/anova-kernel');\nconst CauchyKernel = require('./kernels/cauchy-kernel');\nconst ExponentialKernel = require('./kernels/exponential-kernel');\nconst HistogramKernel = require('./kernels/histogram-intersection-kernel');\nconst LaplacianKernel = require('./kernels/laplacian-kernel');\nconst MultiquadraticKernel = require('./kernels/multiquadratic-kernel');\nconst RationalKernel = require('./kernels/rational-quadratic-kernel');\n\nconst kernelType = {\n  gaussian: GaussianKernel,\n  rbf: GaussianKernel,\n  polynomial: PolynomialKernel,\n  poly: PolynomialKernel,\n  anova: ANOVAKernel,\n  cauchy: CauchyKernel,\n  exponential: ExponentialKernel,\n  histogram: HistogramKernel,\n  min: HistogramKernel,\n  laplacian: LaplacianKernel,\n  multiquadratic: MultiquadraticKernel,\n  rational: RationalKernel,\n  sigmoid: SigmoidKernel,\n  mlp: SigmoidKernel\n};\n\nclass Kernel {\n  constructor(type, options) {\n    this.kernelType = type;\n    if (type === 'linear') return;\n\n    if (typeof type === 'string') {\n      type = type.toLowerCase();\n\n      var KernelConstructor = kernelType[type];\n      if (KernelConstructor) {\n        this.kernelFunction = new KernelConstructor(options);\n      } else {\n        throw new Error(`unsupported kernel type: ${type}`);\n      }\n    } else if (typeof type === 'object' && typeof type.compute === 'function') {\n      this.kernelFunction = type;\n    } else {\n      throw new TypeError(\n        'first argument must be a valid kernel type or instance'\n      );\n    }\n  }\n\n  compute(inputs, landmarks) {\n    inputs = Matrix.checkMatrix(inputs);\n    if (landmarks === undefined) {\n      landmarks = inputs;\n    } else {\n      landmarks = Matrix.checkMatrix(landmarks);\n    }\n    if (this.kernelType === 'linear') {\n      return inputs.mmul(new MatrixTransposeView(landmarks));\n    }\n\n    const kernelMatrix = new Matrix(inputs.rows, landmarks.rows);\n    if (inputs === landmarks) {\n      // fast path, matrix is symmetric\n      for (let i = 0; i < inputs.rows; i++) {\n        for (let j = i; j < inputs.rows; j++) {\n          const value = this.kernelFunction.compute(\n            inputs.getRow(i),\n            inputs.getRow(j)\n          );\n          kernelMatrix.set(i, j, value);\n          kernelMatrix.set(j, i, value);\n        }\n      }\n    } else {\n      for (let i = 0; i < inputs.rows; i++) {\n        for (let j = 0; j < landmarks.rows; j++) {\n          kernelMatrix.set(\n            i,\n            j,\n            this.kernelFunction.compute(inputs.getRow(i), landmarks.getRow(j))\n          );\n        }\n      }\n    }\n    return kernelMatrix;\n  }\n}\n\nmodule.exports = Kernel;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}