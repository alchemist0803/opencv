{"ast":null,"code":"import { canvasToBlob } from 'blob-util';\nimport { encode as encodeBmp } from 'fast-bmp';\nimport { encode as realEncodePng } from 'fast-png';\nimport { encode as realEncodeJpeg } from 'jpeg-js';\nimport { toBase64URL } from '../../util/base64';\nimport { ImageData, createCanvas, createWriteStream, writeFile } from './environment';\nimport { getType } from './mediaTypes';\nfunction encodeJpeg(image, options = {}) {\n  const data = {\n    width: image.width,\n    height: image.height,\n    data: image.getRGBAData()\n  };\n  return realEncodeJpeg(data, options.quality).data;\n}\nfunction encodePng(image, options) {\n  const data = {\n    width: image.width,\n    height: image.height,\n    channels: image.channels,\n    depth: image.bitDepth,\n    data: image.data\n  };\n  if (data.depth === 1 || data.depth === 32) {\n    data.depth = 8;\n    data.channels = 4;\n    data.data = image.getRGBAData();\n  }\n  return realEncodePng(data, options);\n}\nconst exportMethods = {\n  /**\n   * Save the image to disk (Node.js only)\n   * @memberof Image\n   * @instance\n   * @param {string} path\n   * @param {object} [options]\n   * @param {string} [options.format] - One of: png, jpg, bmp (limited support for bmp). If not specified will try to infer from filename\n   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of a JavaScript implementation\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {Promise} - Resolves when the file is fully written\n   */\n  save(path, options = {}) {\n    const {\n      useCanvas = false,\n      encoder: encoderOptions = undefined\n    } = options;\n    let {\n      format\n    } = options;\n    if (!format) {\n      // try to infer format from filename\n      const m = /\\.(?<format>[a-zA-Z]+)$/.exec(path);\n      if (m) {\n        format = m.groups.format.toLowerCase();\n      }\n    }\n    if (!format) {\n      throw new Error('file format not provided');\n    }\n    return new Promise((resolve, reject) => {\n      let stream, buffer;\n      switch (format.toLowerCase()) {\n        case 'png':\n          {\n            if (useCanvas) {\n              stream = this.getCanvas().pngStream();\n            } else {\n              buffer = encodePng(this, encoderOptions);\n            }\n            break;\n          }\n        case 'jpg':\n        case 'jpeg':\n          if (useCanvas) {\n            stream = this.getCanvas().jpegStream();\n          } else {\n            buffer = encodeJpeg(this, encoderOptions);\n          }\n          break;\n        case 'bmp':\n          buffer = encodeBmp(this, encoderOptions);\n          break;\n        default:\n          throw new RangeError(`invalid output format: ${format}`);\n      }\n      if (stream) {\n        let out = createWriteStream(path);\n        out.on('finish', resolve);\n        out.on('error', reject);\n        stream.pipe(out);\n      } else if (buffer) {\n        writeFile(path, buffer, err => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          resolve();\n        });\n      }\n    });\n  },\n  /**\n   * Creates a dataURL string from the image.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png']\n   * @param {object} [options]\n   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of JavaScript implementation.\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {string|Promise<string>}\n   */\n  toDataURL(type = 'image/png', options = {}) {\n    if (typeof type === 'object') {\n      options = type;\n      type = 'image/png';\n    }\n    const {\n      useCanvas = false,\n      encoder: encoderOptions = undefined\n    } = options;\n    type = getType(type);\n    function dataUrl(encoder, ctx) {\n      const u8 = encoder(ctx, encoderOptions);\n      return toBase64URL(u8, type);\n    }\n    if (type === 'image/bmp') {\n      return dataUrl(encodeBmp, this);\n    } else if (type === 'image/png' && !useCanvas) {\n      return dataUrl(encodePng, this);\n    } else if (type === 'image/jpeg' && !useCanvas) {\n      return dataUrl(encodeJpeg, this);\n    } else {\n      return this.getCanvas().toDataURL(type);\n    }\n  },\n  /**\n   * Encodes the image and returns a buffer\n   * @memberof Image\n   * @instance\n   * @param {object} [options]\n   * @param {string} [options.format='png']\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {Uint8Array}\n   */\n  toBuffer(options = {}) {\n    const {\n      format = 'png',\n      encoder: encoderOptions = undefined\n    } = options;\n    switch (format.toLowerCase()) {\n      case 'png':\n        return encodePng(this, encoderOptions);\n      case 'jpeg':\n      case 'jpg':\n        return encodeJpeg(this, encoderOptions);\n      case 'bmp':\n        return encodeBmp(this, encoderOptions);\n      default:\n        throw new RangeError(`invalid output format: ${format}`);\n    }\n  },\n  /**\n   * Creates a base64 string from the image.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png']\n   * @param {object} [options] - Same options as toDataURL\n   * @return {string|Promise<string>}\n   */\n  toBase64(type = 'image/png', options = {}) {\n    if (options.async) {\n      return this.toDataURL(type, options).then(function (dataURL) {\n        return dataURL.substring(dataURL.indexOf(',') + 1);\n      });\n    } else {\n      const dataURL = this.toDataURL(type, options);\n      return dataURL.substring(dataURL.indexOf(',') + 1);\n    }\n  },\n  /**\n   * Creates a blob from the image and return a Promise.\n   * This function is only available in the browser.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png'] A String indicating the image format. The default type is image/png.\n   * @param {string} [quality=0.8] A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp. If this argument is anything else, the default value for image quality is used. Other arguments are ignored.\n   * @return {Promise}\n   */\n  toBlob(type = 'image/png', quality = 0.8) {\n    return canvasToBlob(this.getCanvas(), type, quality);\n  },\n  /**\n   * Creates a new canvas element and draw the image inside it\n   * @memberof Image\n   * @instance\n   * @return {Canvas}\n   */\n  getCanvas() {\n    const data = new ImageData(this.getRGBAData({\n      clamped: true\n    }), this.width, this.height);\n    let canvas = createCanvas(this.width, this.height);\n    let ctx = canvas.getContext('2d');\n    ctx.putImageData(data, 0, 0);\n    return canvas;\n  }\n};\nexport default function setExportMethods(Image) {\n  for (const i in exportMethods) {\n    Image.prototype[i] = exportMethods[i];\n  }\n}","map":{"version":3,"names":["canvasToBlob","encode","encodeBmp","realEncodePng","realEncodeJpeg","toBase64URL","ImageData","createCanvas","createWriteStream","writeFile","getType","encodeJpeg","image","options","data","width","height","getRGBAData","quality","encodePng","channels","depth","bitDepth","exportMethods","save","path","useCanvas","encoder","encoderOptions","undefined","format","m","exec","groups","toLowerCase","Error","Promise","resolve","reject","stream","buffer","getCanvas","pngStream","jpegStream","RangeError","out","on","pipe","err","toDataURL","type","dataUrl","ctx","u8","toBuffer","toBase64","async","then","dataURL","substring","indexOf","toBlob","clamped","canvas","getContext","putImageData","setExportMethods","Image","i","prototype"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/core/export.js"],"sourcesContent":["import { canvasToBlob } from 'blob-util';\nimport { encode as encodeBmp } from 'fast-bmp';\nimport { encode as realEncodePng } from 'fast-png';\nimport { encode as realEncodeJpeg } from 'jpeg-js';\n\nimport { toBase64URL } from '../../util/base64';\n\nimport {\n  ImageData,\n  createCanvas,\n  createWriteStream,\n  writeFile,\n} from './environment';\nimport { getType } from './mediaTypes';\n\nfunction encodeJpeg(image, options = {}) {\n  const data = {\n    width: image.width,\n    height: image.height,\n    data: image.getRGBAData(),\n  };\n  return realEncodeJpeg(data, options.quality).data;\n}\n\nfunction encodePng(image, options) {\n  const data = {\n    width: image.width,\n    height: image.height,\n    channels: image.channels,\n    depth: image.bitDepth,\n    data: image.data,\n  };\n\n  if (data.depth === 1 || data.depth === 32) {\n    data.depth = 8;\n    data.channels = 4;\n    data.data = image.getRGBAData();\n  }\n\n  return realEncodePng(data, options);\n}\n\nconst exportMethods = {\n  /**\n   * Save the image to disk (Node.js only)\n   * @memberof Image\n   * @instance\n   * @param {string} path\n   * @param {object} [options]\n   * @param {string} [options.format] - One of: png, jpg, bmp (limited support for bmp). If not specified will try to infer from filename\n   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of a JavaScript implementation\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {Promise} - Resolves when the file is fully written\n   */\n  save(path, options = {}) {\n    const { useCanvas = false, encoder: encoderOptions = undefined } = options;\n\n    let { format } = options;\n    if (!format) {\n      // try to infer format from filename\n      const m = /\\.(?<format>[a-zA-Z]+)$/.exec(path);\n      if (m) {\n        format = m.groups.format.toLowerCase();\n      }\n    }\n    if (!format) {\n      throw new Error('file format not provided');\n    }\n    return new Promise((resolve, reject) => {\n      let stream, buffer;\n      switch (format.toLowerCase()) {\n        case 'png': {\n          if (useCanvas) {\n            stream = this.getCanvas().pngStream();\n          } else {\n            buffer = encodePng(this, encoderOptions);\n          }\n          break;\n        }\n        case 'jpg':\n        case 'jpeg':\n          if (useCanvas) {\n            stream = this.getCanvas().jpegStream();\n          } else {\n            buffer = encodeJpeg(this, encoderOptions);\n          }\n          break;\n        case 'bmp':\n          buffer = encodeBmp(this, encoderOptions);\n          break;\n        default:\n          throw new RangeError(`invalid output format: ${format}`);\n      }\n      if (stream) {\n        let out = createWriteStream(path);\n        out.on('finish', resolve);\n        out.on('error', reject);\n        stream.pipe(out);\n      } else if (buffer) {\n        writeFile(path, buffer, (err) => {\n          if (err) {\n            reject(err);\n            return;\n          }\n          resolve();\n        });\n      }\n    });\n  },\n\n  /**\n   * Creates a dataURL string from the image.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png']\n   * @param {object} [options]\n   * @param {boolean} [options.useCanvas=false] - Force use of the canvas API to save the image instead of JavaScript implementation.\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {string|Promise<string>}\n   */\n  toDataURL(type = 'image/png', options = {}) {\n    if (typeof type === 'object') {\n      options = type;\n      type = 'image/png';\n    }\n    const { useCanvas = false, encoder: encoderOptions = undefined } = options;\n    type = getType(type);\n\n    function dataUrl(encoder, ctx) {\n      const u8 = encoder(ctx, encoderOptions);\n      return toBase64URL(u8, type);\n    }\n\n    if (type === 'image/bmp') {\n      return dataUrl(encodeBmp, this);\n    } else if (type === 'image/png' && !useCanvas) {\n      return dataUrl(encodePng, this);\n    } else if (type === 'image/jpeg' && !useCanvas) {\n      return dataUrl(encodeJpeg, this);\n    } else {\n      return this.getCanvas().toDataURL(type);\n    }\n  },\n\n  /**\n   * Encodes the image and returns a buffer\n   * @memberof Image\n   * @instance\n   * @param {object} [options]\n   * @param {string} [options.format='png']\n   * @param {object} [options.encoder] - Specify options for the encoder if applicable.\n   * @return {Uint8Array}\n   */\n  toBuffer(options = {}) {\n    const { format = 'png', encoder: encoderOptions = undefined } = options;\n    switch (format.toLowerCase()) {\n      case 'png':\n        return encodePng(this, encoderOptions);\n      case 'jpeg':\n      case 'jpg':\n        return encodeJpeg(this, encoderOptions);\n      case 'bmp':\n        return encodeBmp(this, encoderOptions);\n      default:\n        throw new RangeError(`invalid output format: ${format}`);\n    }\n  },\n\n  /**\n   * Creates a base64 string from the image.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png']\n   * @param {object} [options] - Same options as toDataURL\n   * @return {string|Promise<string>}\n   */\n  toBase64(type = 'image/png', options = {}) {\n    if (options.async) {\n      return this.toDataURL(type, options).then(function (dataURL) {\n        return dataURL.substring(dataURL.indexOf(',') + 1);\n      });\n    } else {\n      const dataURL = this.toDataURL(type, options);\n      return dataURL.substring(dataURL.indexOf(',') + 1);\n    }\n  },\n\n  /**\n   * Creates a blob from the image and return a Promise.\n   * This function is only available in the browser.\n   * @memberof Image\n   * @instance\n   * @param {string} [type='image/png'] A String indicating the image format. The default type is image/png.\n   * @param {string} [quality=0.8] A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp. If this argument is anything else, the default value for image quality is used. Other arguments are ignored.\n   * @return {Promise}\n   */\n  toBlob(type = 'image/png', quality = 0.8) {\n    return canvasToBlob(this.getCanvas(), type, quality);\n  },\n\n  /**\n   * Creates a new canvas element and draw the image inside it\n   * @memberof Image\n   * @instance\n   * @return {Canvas}\n   */\n  getCanvas() {\n    const data = new ImageData(\n      this.getRGBAData({ clamped: true }),\n      this.width,\n      this.height,\n    );\n    let canvas = createCanvas(this.width, this.height);\n    let ctx = canvas.getContext('2d');\n    ctx.putImageData(data, 0, 0);\n    return canvas;\n  },\n};\n\nexport default function setExportMethods(Image) {\n  for (const i in exportMethods) {\n    Image.prototype[i] = exportMethods[i];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}