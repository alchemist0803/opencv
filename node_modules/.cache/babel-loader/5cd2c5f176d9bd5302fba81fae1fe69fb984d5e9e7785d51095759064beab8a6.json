{"ast":null,"code":"const defaultOptions = {\n  lowThreshold: 10,\n  highThreshold: 30,\n  gaussianBlur: 1.1\n};\nconst Gx = [[-1, 0, +1], [-2, 0, +2], [-1, 0, +1]];\nconst Gy = [[-1, -2, -1], [0, 0, 0], [+1, +2, +1]];\nconst convOptions = {\n  bitDepth: 32,\n  mode: 'periodic'\n};\nexport default function cannyEdgeDetector(image, options) {\n  image.checkProcessable('Canny edge detector', {\n    bitDepth: 8,\n    channels: 1,\n    components: 1\n  });\n  options = Object.assign({}, defaultOptions, options);\n  const width = image.width;\n  const height = image.height;\n  const brightness = image.maxValue;\n  const gfOptions = {\n    sigma: options.gaussianBlur,\n    radius: 3\n  };\n  const gf = image.gaussianFilter(gfOptions);\n  const gradientX = gf.convolution(Gy, convOptions);\n  const gradientY = gf.convolution(Gx, convOptions);\n  const G = gradientY.hypotenuse(gradientX);\n  const Image = image.constructor;\n  const nms = new Image(width, height, {\n    kind: 'GREY',\n    bitDepth: 32\n  });\n  const edges = new Image(width, height, {\n    kind: 'GREY',\n    bitDepth: 32\n  });\n  const finalImage = new Image(width, height, {\n    kind: 'GREY'\n  });\n\n  // Non-Maximum supression\n  for (var i = 1; i < width - 1; i++) {\n    for (var j = 1; j < height - 1; j++) {\n      var dir = (Math.round(Math.atan2(gradientY.getValueXY(i, j, 0), gradientX.getValueXY(i, j, 0)) * (5.0 / Math.PI)) + 5) % 5;\n      if (!(dir === 0 && (G.getValueXY(i, j, 0) <= G.getValueXY(i, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i, j + 1, 0)) || dir === 1 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j + 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j - 1, 0)) || dir === 2 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j, 0)) || dir === 3 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j + 1, 0)))) {\n        nms.setValueXY(i, j, 0, G.getValueXY(i, j, 0));\n      }\n    }\n  }\n  for (i = 0; i < width * height; ++i) {\n    var currentNms = nms.data[i];\n    var currentEdge = 0;\n    if (currentNms > options.highThreshold) {\n      currentEdge++;\n      finalImage.data[i] = brightness;\n    }\n    if (currentNms > options.lowThreshold) {\n      currentEdge++;\n    }\n    edges.data[i] = currentEdge;\n  }\n\n  // Hysteresis: first pass\n  var currentPixels = [];\n  for (i = 1; i < width - 1; ++i) {\n    for (j = 1; j < height - 1; ++j) {\n      if (edges.getValueXY(i, j, 0) !== 1) {\n        continue;\n      }\n      outer: for (var k = i - 1; k < i + 2; ++k) {\n        for (var l = j - 1; l < j + 2; ++l) {\n          if (edges.getValueXY(k, l, 0) === 2) {\n            currentPixels.push([i, j]);\n            finalImage.setValueXY(i, j, 0, brightness);\n            break outer;\n          }\n        }\n      }\n    }\n  }\n\n  // Hysteresis: second pass\n  while (currentPixels.length > 0) {\n    var newPixels = [];\n    for (i = 0; i < currentPixels.length; ++i) {\n      for (j = -1; j < 2; ++j) {\n        for (k = -1; k < 2; ++k) {\n          if (j === 0 && k === 0) {\n            continue;\n          }\n          var row = currentPixels[i][0] + j;\n          var col = currentPixels[i][1] + k;\n          if (edges.getValueXY(row, col, 0) === 1 && finalImage.getValueXY(row, col, 0) === 0) {\n            newPixels.push([row, col]);\n            finalImage.setValueXY(row, col, 0, brightness);\n          }\n        }\n      }\n    }\n    currentPixels = newPixels;\n  }\n  return finalImage;\n}","map":{"version":3,"names":["defaultOptions","lowThreshold","highThreshold","gaussianBlur","Gx","Gy","convOptions","bitDepth","mode","cannyEdgeDetector","image","options","checkProcessable","channels","components","Object","assign","width","height","brightness","maxValue","gfOptions","sigma","radius","gf","gaussianFilter","gradientX","convolution","gradientY","G","hypotenuse","Image","constructor","nms","kind","edges","finalImage","i","j","dir","Math","round","atan2","getValueXY","PI","setValueXY","currentNms","data","currentEdge","currentPixels","outer","k","l","push","length","newPixels","row","col"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/canny-edge-detector/src/index.js"],"sourcesContent":["const defaultOptions = {\n    lowThreshold: 10,\n    highThreshold: 30,\n    gaussianBlur: 1.1\n};\n\nconst Gx = [\n    [-1, 0, +1],\n    [-2, 0, +2],\n    [-1, 0, +1]\n];\n\nconst Gy = [\n    [-1, -2, -1],\n    [0, 0, 0],\n    [+1, +2, +1]\n];\n\nconst convOptions = {\n    bitDepth: 32,\n    mode: 'periodic'\n};\n\nexport default function cannyEdgeDetector(image, options) {\n    image.checkProcessable('Canny edge detector', {\n        bitDepth: 8,\n        channels: 1,\n        components: 1\n    });\n\n    options = Object.assign({}, defaultOptions, options);\n\n    const width = image.width;\n    const height = image.height;\n    const brightness = image.maxValue;\n\n    const gfOptions = {\n        sigma: options.gaussianBlur,\n        radius: 3\n    };\n\n    const gf = image.gaussianFilter(gfOptions);\n\n    const gradientX = gf.convolution(Gy, convOptions);\n    const gradientY = gf.convolution(Gx, convOptions);\n\n    const G = gradientY.hypotenuse(gradientX);\n\n    const Image = image.constructor;\n\n    const nms = new Image(width, height, {\n        kind: 'GREY',\n        bitDepth: 32\n    });\n\n    const edges = new Image(width, height, {\n        kind: 'GREY',\n        bitDepth: 32\n    });\n\n    const finalImage = new Image(width, height, {\n        kind: 'GREY'\n    });\n\n    // Non-Maximum supression\n    for (var i = 1; i < width - 1; i++) {\n        for (var j = 1; j < height - 1; j++) {\n\n            var dir = (Math.round(Math.atan2(gradientY.getValueXY(i, j, 0), gradientX.getValueXY(i, j, 0)) * (5.0 / Math.PI)) + 5) % 5;\n\n            if (\n                !((dir === 0 && (G.getValueXY(i, j, 0) <= G.getValueXY(i, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i, j + 1, 0)))\n                    || (dir === 1 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j + 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j - 1, 0)))\n                    || (dir === 2 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j, 0)))\n                    || (dir === 3 && (G.getValueXY(i, j, 0) <= G.getValueXY(i - 1, j - 1, 0) || G.getValueXY(i, j, 0) <= G.getValueXY(i + 1, j + 1, 0))))\n            ) {\n                nms.setValueXY(i, j, 0, G.getValueXY(i, j, 0));\n            }\n        }\n    }\n\n    for (i = 0; i < width * height; ++i) {\n        var currentNms = nms.data[i];\n        var currentEdge = 0;\n        if (currentNms > options.highThreshold) {\n            currentEdge++;\n            finalImage.data[i] = brightness;\n        }\n        if (currentNms > options.lowThreshold) {\n            currentEdge++;\n        }\n\n        edges.data[i] = currentEdge;\n    }\n\n    // Hysteresis: first pass\n    var currentPixels = [];\n    for (i = 1; i < width - 1; ++i) {\n        for (j = 1; j < height - 1; ++j) {\n            if (edges.getValueXY(i, j, 0) !== 1) {\n                continue;\n            }\n\n            outer: for (var k = i - 1; k < i + 2; ++k) {\n                for (var l = j - 1; l < j + 2; ++l) {\n                    if (edges.getValueXY(k, l, 0) === 2) {\n                        currentPixels.push([i, j]);\n                        finalImage.setValueXY(i, j, 0, brightness);\n                        break outer;\n                    }\n                }\n            }\n        }\n    }\n\n    // Hysteresis: second pass\n    while (currentPixels.length > 0) {\n        var newPixels = [];\n        for (i = 0; i < currentPixels.length; ++i) {\n            for (j = -1; j < 2; ++j) {\n                for (k = -1; k < 2; ++k) {\n                    if (j === 0 && k === 0) {\n                        continue;\n                    }\n                    var row = currentPixels[i][0] + j;\n                    var col = currentPixels[i][1] + k;\n                    if (edges.getValueXY(row, col, 0) === 1 && finalImage.getValueXY(row, col, 0) === 0) {\n                        newPixels.push([row, col]);\n                        finalImage.setValueXY(row, col, 0, brightness);\n                    }\n                }\n            }\n        }\n        currentPixels = newPixels;\n    }\n\n    return finalImage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}