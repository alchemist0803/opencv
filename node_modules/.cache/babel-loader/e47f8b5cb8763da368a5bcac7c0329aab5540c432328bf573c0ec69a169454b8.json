{"ast":null,"code":"// We calculate all the border length with the neighbours\n\nexport default function commonBorderLength(roiMap) {\n  let data = roiMap.data;\n  let dx = [+1, 0, -1, 0];\n  let dy = [0, +1, 0, -1];\n  let minMax = roiMap.minMax;\n  let shift = -minMax.min;\n  let max = minMax.max + shift;\n  let borderInfo = [];\n  for (let i = 0; i <= max; i++) {\n    borderInfo.push(Object.create(null));\n  }\n  for (let x = 0; x < roiMap.width; x++) {\n    for (let y = 0; y < roiMap.height; y++) {\n      let target = x + y * roiMap.width;\n      let currentRoiID = data[target];\n      if (currentRoiID !== 0) {\n        // each pixel may only contribute one time to a border\n        let used = Object.create(null);\n        let isBorder = false;\n        for (let dir = 0; dir < 4; dir++) {\n          let newX = x + dx[dir];\n          let newY = y + dy[dir];\n          if (newX >= 0 && newY >= 0 && newX < roiMap.width && newY < roiMap.height) {\n            let neighbourRoiID = data[newX + newY * roiMap.width];\n            if (currentRoiID !== neighbourRoiID) {\n              isBorder = true;\n              if (neighbourRoiID !== 0 && used[neighbourRoiID] === undefined) {\n                used[neighbourRoiID] = true;\n                if (!borderInfo[neighbourRoiID + shift][currentRoiID]) {\n                  borderInfo[neighbourRoiID + shift][currentRoiID] = 1;\n                } else {\n                  borderInfo[neighbourRoiID + shift][currentRoiID]++;\n                }\n              }\n            }\n          } else {\n            isBorder = true;\n          }\n        }\n        // we will also add an information to specify the border length\n        if (isBorder) {\n          if (!borderInfo[currentRoiID + shift][currentRoiID]) {\n            borderInfo[currentRoiID + shift][currentRoiID] = 1;\n          } else {\n            borderInfo[currentRoiID + shift][currentRoiID]++;\n          }\n        }\n      }\n    }\n  }\n\n  // we convert now the result to an object for fast lookup and we will reshift the result\n  let result = {};\n  for (let i = 0; i < borderInfo.length; i++) {\n    if (Object.keys(borderInfo[i]).length > 0) {\n      result[i - shift] = borderInfo[i];\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["commonBorderLength","roiMap","data","dx","dy","minMax","shift","min","max","borderInfo","i","push","Object","create","x","width","y","height","target","currentRoiID","used","isBorder","dir","newX","newY","neighbourRoiID","undefined","result","length","keys"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/roi/util/commonBorderLength.js"],"sourcesContent":["// We calculate all the border length with the neighbours\n\nexport default function commonBorderLength(roiMap) {\n  let data = roiMap.data;\n  let dx = [+1, 0, -1, 0];\n  let dy = [0, +1, 0, -1];\n\n  let minMax = roiMap.minMax;\n  let shift = -minMax.min;\n  let max = minMax.max + shift;\n  let borderInfo = [];\n  for (let i = 0; i <= max; i++) {\n    borderInfo.push(Object.create(null));\n  }\n\n  for (let x = 0; x < roiMap.width; x++) {\n    for (let y = 0; y < roiMap.height; y++) {\n      let target = x + y * roiMap.width;\n      let currentRoiID = data[target];\n      if (currentRoiID !== 0) {\n        // each pixel may only contribute one time to a border\n        let used = Object.create(null);\n        let isBorder = false;\n        for (let dir = 0; dir < 4; dir++) {\n          let newX = x + dx[dir];\n          let newY = y + dy[dir];\n          if (\n            newX >= 0 &&\n            newY >= 0 &&\n            newX < roiMap.width &&\n            newY < roiMap.height\n          ) {\n            let neighbourRoiID = data[newX + newY * roiMap.width];\n            if (currentRoiID !== neighbourRoiID) {\n              isBorder = true;\n              if (neighbourRoiID !== 0 && used[neighbourRoiID] === undefined) {\n                used[neighbourRoiID] = true;\n                if (!borderInfo[neighbourRoiID + shift][currentRoiID]) {\n                  borderInfo[neighbourRoiID + shift][currentRoiID] = 1;\n                } else {\n                  borderInfo[neighbourRoiID + shift][currentRoiID]++;\n                }\n              }\n            }\n          } else {\n            isBorder = true;\n          }\n        }\n        // we will also add an information to specify the border length\n        if (isBorder) {\n          if (!borderInfo[currentRoiID + shift][currentRoiID]) {\n            borderInfo[currentRoiID + shift][currentRoiID] = 1;\n          } else {\n            borderInfo[currentRoiID + shift][currentRoiID]++;\n          }\n        }\n      }\n    }\n  }\n\n  // we convert now the result to an object for fast lookup and we will reshift the result\n  let result = {};\n  for (let i = 0; i < borderInfo.length; i++) {\n    if (Object.keys(borderInfo[i]).length > 0) {\n      result[i - shift] = borderInfo[i];\n    }\n  }\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}