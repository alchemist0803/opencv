{"ast":null,"code":"/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding method:\n * Kapur, JN; Sahoo, PK & Wong, ACK (1985), \"A New Method for Gray-Level Picture Thresholding Using the Entropy of the Histogram\",\n * Graphical Models and Image Processing 29(3): 273-285\n * @param histogram - the histogram of the image\n *        total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n\nexport default function maxEntropy(histogram, total) {\n  let normHisto = new Array(histogram.length); // normalized histogram\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n  let P1 = new Array(histogram.length); // cumulative normalized histogram\n  let P2 = new Array(histogram.length);\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n\n  /* Determine the first non-zero bin */\n  let firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  let lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  // Calculate the total entropy each gray-level\n  // and find the threshold that maximizes it\n  let threshold = -1;\n  let totEnt; // total entropy\n  let maxEnt = Number.MIN_VALUE; // max entropy\n  let entBack; // entropy of the background pixels at a given threshold\n  let entObj; // entropy of the object pixels at a given threshold\n\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    entBack = 0.0;\n    for (let ih = 0; ih <= it; ih++) {\n      if (histogram[ih] !== 0) {\n        entBack -= normHisto[ih] / P1[it] * Math.log(normHisto[ih] / P1[it]);\n      }\n    }\n\n    /* Entropy of the object pixels */\n    entObj = 0.0;\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      if (histogram[ih] !== 0) {\n        entObj -= normHisto[ih] / P2[it] * Math.log(normHisto[ih] / P2[it]);\n      }\n    }\n\n    /* Total entropy */\n    totEnt = entBack + entObj;\n    if (maxEnt < totEnt) {\n      maxEnt = totEnt;\n      threshold = it;\n    }\n  }\n  return threshold;\n}","map":{"version":3,"names":["maxEntropy","histogram","total","normHisto","Array","length","ih","P1","P2","firstBin","Math","abs","Number","EPSILON","lastBin","threshold","totEnt","maxEnt","MIN_VALUE","entBack","entObj","it","log"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/maxEntropy.js"],"sourcesContent":["/*\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html\n * The method is present in: Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding method:\n * Kapur, JN; Sahoo, PK & Wong, ACK (1985), \"A New Method for Gray-Level Picture Thresholding Using the Entropy of the Histogram\",\n * Graphical Models and Image Processing 29(3): 273-285\n * @param histogram - the histogram of the image\n *        total - the number of pixels in the image\n * @returns {number} - the threshold\n */\n\nexport default function maxEntropy(histogram, total) {\n  let normHisto = new Array(histogram.length); // normalized histogram\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n\n  let P1 = new Array(histogram.length); // cumulative normalized histogram\n  let P2 = new Array(histogram.length);\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n\n  /* Determine the first non-zero bin */\n  let firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  let lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  // Calculate the total entropy each gray-level\n  // and find the threshold that maximizes it\n  let threshold = -1;\n  let totEnt; // total entropy\n  let maxEnt = Number.MIN_VALUE; // max entropy\n  let entBack; // entropy of the background pixels at a given threshold\n  let entObj; // entropy of the object pixels at a given threshold\n\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    entBack = 0.0;\n    for (let ih = 0; ih <= it; ih++) {\n      if (histogram[ih] !== 0) {\n        entBack -= (normHisto[ih] / P1[it]) * Math.log(normHisto[ih] / P1[it]);\n      }\n    }\n\n    /* Entropy of the object pixels */\n    entObj = 0.0;\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      if (histogram[ih] !== 0) {\n        entObj -= (normHisto[ih] / P2[it]) * Math.log(normHisto[ih] / P2[it]);\n      }\n    }\n\n    /* Total entropy */\n    totEnt = entBack + entObj;\n\n    if (maxEnt < totEnt) {\n      maxEnt = totEnt;\n      threshold = it;\n    }\n  }\n  return threshold;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}