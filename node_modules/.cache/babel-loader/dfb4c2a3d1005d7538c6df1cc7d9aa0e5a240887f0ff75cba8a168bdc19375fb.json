{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2017 Sam Thorogood. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n(function (scope) {\n  'use strict';\n\n  // fail early\n  if (scope['TextEncoder'] && scope['TextDecoder']) {\n    return false;\n  }\n  /**\n   * @constructor\n   * @param {string=} utfLabel\n   */\n  function FastTextEncoder(utfLabel = 'utf-8') {\n    if (utfLabel !== 'utf-8') {\n      throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`);\n    }\n  }\n  Object.defineProperty(FastTextEncoder.prototype, 'encoding', {\n    value: 'utf-8'\n  });\n  /**\n   * @param {string} string\n   * @param {{stream: boolean}=} options\n   * @return {!Uint8Array}\n   */\n  FastTextEncoder.prototype.encode = function (string, options = {\n    stream: false\n  }) {\n    if (options.stream) {\n      throw new Error(`Failed to encode: the 'stream' option is unsupported.`);\n    }\n    let pos = 0;\n    const len = string.length;\n    const out = [];\n    let at = 0; // output position\n    let tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n    let target = new Uint8Array(tlen >> 3 << 3); // ... but at 8 byte offset\n    while (pos < len) {\n      let value = string.charCodeAt(pos++);\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < len) {\n          const extra = string.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n        if (value >= 0xd800 && value <= 0xdbff) {\n          continue; // drop lone surrogate\n        }\n      }\n      // expand the buffer if we couldn't write 4 bytes\n      if (at + 4 > target.length) {\n        tlen += 8; // minimum extra\n        tlen *= 1.0 + pos / string.length * 2; // take 2x the remaining\n        tlen = tlen >> 3 << 3; // 8 byte offset\n        const update = new Uint8Array(tlen);\n        update.set(target);\n        target = update;\n      }\n      if ((value & 0xffffff80) === 0) {\n        // 1-byte\n        target[at++] = value; // ASCII\n        continue;\n      } else if ((value & 0xfffff800) === 0) {\n        // 2-byte\n        target[at++] = value >> 6 & 0x1f | 0xc0;\n      } else if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        target[at++] = value >> 12 & 0x0f | 0xe0;\n        target[at++] = value >> 6 & 0x3f | 0x80;\n      } else if ((value & 0xffe00000) === 0) {\n        // 4-byte\n        target[at++] = value >> 18 & 0x07 | 0xf0;\n        target[at++] = value >> 12 & 0x3f | 0x80;\n        target[at++] = value >> 6 & 0x3f | 0x80;\n      } else {\n        // FIXME: do we care\n        continue;\n      }\n      target[at++] = value & 0x3f | 0x80;\n    }\n    return target.slice(0, at);\n  };\n  /**\n   * @constructor\n   * @param {string=} utfLabel\n   * @param {{fatal: boolean}=} options\n   */\n  function FastTextDecoder(utfLabel = 'utf-8', options = {\n    fatal: false\n  }) {\n    if (utfLabel !== 'utf-8') {\n      throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`);\n    }\n    if (options.fatal) {\n      throw new Error(`Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`);\n    }\n  }\n  Object.defineProperty(FastTextDecoder.prototype, 'encoding', {\n    value: 'utf-8'\n  });\n  Object.defineProperty(FastTextDecoder.prototype, 'fatal', {\n    value: false\n  });\n  Object.defineProperty(FastTextDecoder.prototype, 'ignoreBOM', {\n    value: false\n  });\n  /**\n   * @param {(!ArrayBuffer|!ArrayBufferView)} buffer\n   * @param {{stream: boolean}=} options\n   */\n  FastTextDecoder.prototype.decode = function (buffer, options = {\n    stream: false\n  }) {\n    if (options['stream']) {\n      throw new Error(`Failed to decode: the 'stream' option is unsupported.`);\n    }\n    const bytes = new Uint8Array(buffer);\n    let pos = 0;\n    const len = bytes.length;\n    const out = [];\n    while (pos < len) {\n      const byte1 = bytes[pos++];\n      if (byte1 === 0) {\n        break; // NULL\n      }\n      if ((byte1 & 0x80) === 0) {\n        // 1-byte\n        out.push(byte1);\n      } else if ((byte1 & 0xe0) === 0xc0) {\n        // 2-byte\n        const byte2 = bytes[pos++] & 0x3f;\n        out.push((byte1 & 0x1f) << 6 | byte2);\n      } else if ((byte1 & 0xf0) === 0xe0) {\n        const byte2 = bytes[pos++] & 0x3f;\n        const byte3 = bytes[pos++] & 0x3f;\n        out.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n      } else if ((byte1 & 0xf8) === 0xf0) {\n        const byte2 = bytes[pos++] & 0x3f;\n        const byte3 = bytes[pos++] & 0x3f;\n        const byte4 = bytes[pos++] & 0x3f;\n        // this can be > 0xffff, so possibly generate surrogates\n        let codepoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n        if (codepoint > 0xffff) {\n          // codepoint &= ~0x10000;\n          codepoint -= 0x10000;\n          out.push(codepoint >>> 10 & 0x3ff | 0xd800);\n          codepoint = 0xdc00 | codepoint & 0x3ff;\n        }\n        out.push(codepoint);\n      } else {\n        // FIXME: we're ignoring this\n      }\n    }\n    return String.fromCharCode.apply(null, out);\n  };\n  scope['TextEncoder'] = FastTextEncoder;\n  scope['TextDecoder'] = FastTextDecoder;\n})(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : this);","map":{"version":3,"names":["scope","FastTextEncoder","utfLabel","RangeError","Object","defineProperty","prototype","value","encode","string","options","stream","Error","pos","len","length","out","at","tlen","Math","max","target","Uint8Array","charCodeAt","extra","update","set","slice","FastTextDecoder","fatal","decode","buffer","bytes","byte1","push","byte2","byte3","byte4","codepoint","String","fromCharCode","apply","window","self"],"sources":["C:\\Users\\Admin\\Documents\\Workspace\\opencv\\opencv\\node_modules\\iobuffer\\src\\text-encoding-polyfill.js"],"sourcesContent":["/*\n * Copyright 2017 Sam Thorogood. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n(function(scope) {\n  'use strict';\n\n  // fail early\n  if (scope['TextEncoder'] && scope['TextDecoder']) {\n    return false;\n  }\n\n  /**\n   * @constructor\n   * @param {string=} utfLabel\n   */\n  function FastTextEncoder(utfLabel = 'utf-8') {\n    if (utfLabel !== 'utf-8') {\n      throw new RangeError(\n        `Failed to construct 'TextEncoder': The encoding label provided ('${utfLabel}') is invalid.`,\n      );\n    }\n  }\n\n  Object.defineProperty(FastTextEncoder.prototype, 'encoding', {\n    value: 'utf-8',\n  });\n\n  /**\n   * @param {string} string\n   * @param {{stream: boolean}=} options\n   * @return {!Uint8Array}\n   */\n  FastTextEncoder.prototype.encode = function(\n    string,\n    options = { stream: false },\n  ) {\n    if (options.stream) {\n      throw new Error(`Failed to encode: the 'stream' option is unsupported.`);\n    }\n\n    let pos = 0;\n    const len = string.length;\n    const out = [];\n\n    let at = 0; // output position\n    let tlen = Math.max(32, len + (len >> 1) + 7); // 1.5x size\n    let target = new Uint8Array((tlen >> 3) << 3); // ... but at 8 byte offset\n\n    while (pos < len) {\n      let value = string.charCodeAt(pos++);\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < len) {\n          const extra = string.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n        if (value >= 0xd800 && value <= 0xdbff) {\n          continue; // drop lone surrogate\n        }\n      }\n\n      // expand the buffer if we couldn't write 4 bytes\n      if (at + 4 > target.length) {\n        tlen += 8; // minimum extra\n        tlen *= 1.0 + (pos / string.length) * 2; // take 2x the remaining\n        tlen = (tlen >> 3) << 3; // 8 byte offset\n\n        const update = new Uint8Array(tlen);\n        update.set(target);\n        target = update;\n      }\n\n      if ((value & 0xffffff80) === 0) {\n        // 1-byte\n        target[at++] = value; // ASCII\n        continue;\n      } else if ((value & 0xfffff800) === 0) {\n        // 2-byte\n        target[at++] = ((value >> 6) & 0x1f) | 0xc0;\n      } else if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        target[at++] = ((value >> 12) & 0x0f) | 0xe0;\n        target[at++] = ((value >> 6) & 0x3f) | 0x80;\n      } else if ((value & 0xffe00000) === 0) {\n        // 4-byte\n        target[at++] = ((value >> 18) & 0x07) | 0xf0;\n        target[at++] = ((value >> 12) & 0x3f) | 0x80;\n        target[at++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // FIXME: do we care\n        continue;\n      }\n\n      target[at++] = (value & 0x3f) | 0x80;\n    }\n\n    return target.slice(0, at);\n  };\n\n  /**\n   * @constructor\n   * @param {string=} utfLabel\n   * @param {{fatal: boolean}=} options\n   */\n  function FastTextDecoder(utfLabel = 'utf-8', options = { fatal: false }) {\n    if (utfLabel !== 'utf-8') {\n      throw new RangeError(\n        `Failed to construct 'TextDecoder': The encoding label provided ('${utfLabel}') is invalid.`,\n      );\n    }\n    if (options.fatal) {\n      throw new Error(\n        `Failed to construct 'TextDecoder': the 'fatal' option is unsupported.`,\n      );\n    }\n  }\n\n  Object.defineProperty(FastTextDecoder.prototype, 'encoding', {\n    value: 'utf-8',\n  });\n\n  Object.defineProperty(FastTextDecoder.prototype, 'fatal', { value: false });\n\n  Object.defineProperty(FastTextDecoder.prototype, 'ignoreBOM', {\n    value: false,\n  });\n\n  /**\n   * @param {(!ArrayBuffer|!ArrayBufferView)} buffer\n   * @param {{stream: boolean}=} options\n   */\n  FastTextDecoder.prototype.decode = function(\n    buffer,\n    options = { stream: false },\n  ) {\n    if (options['stream']) {\n      throw new Error(`Failed to decode: the 'stream' option is unsupported.`);\n    }\n\n    const bytes = new Uint8Array(buffer);\n    let pos = 0;\n    const len = bytes.length;\n    const out = [];\n\n    while (pos < len) {\n      const byte1 = bytes[pos++];\n      if (byte1 === 0) {\n        break; // NULL\n      }\n\n      if ((byte1 & 0x80) === 0) {\n        // 1-byte\n        out.push(byte1);\n      } else if ((byte1 & 0xe0) === 0xc0) {\n        // 2-byte\n        const byte2 = bytes[pos++] & 0x3f;\n        out.push(((byte1 & 0x1f) << 6) | byte2);\n      } else if ((byte1 & 0xf0) === 0xe0) {\n        const byte2 = bytes[pos++] & 0x3f;\n        const byte3 = bytes[pos++] & 0x3f;\n        out.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n      } else if ((byte1 & 0xf8) === 0xf0) {\n        const byte2 = bytes[pos++] & 0x3f;\n        const byte3 = bytes[pos++] & 0x3f;\n        const byte4 = bytes[pos++] & 0x3f;\n\n        // this can be > 0xffff, so possibly generate surrogates\n        let codepoint =\n          ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n        if (codepoint > 0xffff) {\n          // codepoint &= ~0x10000;\n          codepoint -= 0x10000;\n          out.push(((codepoint >>> 10) & 0x3ff) | 0xd800);\n          codepoint = 0xdc00 | (codepoint & 0x3ff);\n        }\n        out.push(codepoint);\n      } else {\n        // FIXME: we're ignoring this\n      }\n    }\n\n    return String.fromCharCode.apply(null, out);\n  };\n\n  scope['TextEncoder'] = FastTextEncoder;\n  scope['TextDecoder'] = FastTextDecoder;\n})(\n  typeof window !== 'undefined'\n    ? window\n    : typeof self !== 'undefined'\n    ? self\n    : this,\n);\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;AAgBA,CAAC,UAASA,KAAK;EACb,YAAY;;EAEZ;EACA,IAAIA,KAAK,CAAC,aAAa,CAAC,IAAIA,KAAK,CAAC,aAAa,CAAC,EAAE;IAChD,OAAO,KAAK;;EAGd;;;;EAIA,SAASC,eAAeA,CAACC,QAAQ,GAAG,OAAO;IACzC,IAAIA,QAAQ,KAAK,OAAO,EAAE;MACxB,MAAM,IAAIC,UAAU,CAClB,oEAAoED,QAAQ,gBAAgB,CAC7F;;EAEL;EAEAE,MAAM,CAACC,cAAc,CAACJ,eAAe,CAACK,SAAS,EAAE,UAAU,EAAE;IAC3DC,KAAK,EAAE;GACR,CAAC;EAEF;;;;;EAKAN,eAAe,CAACK,SAAS,CAACE,MAAM,GAAG,UACjCC,MAAM,EACNC,OAAO,GAAG;IAAEC,MAAM,EAAE;EAAK,CAAE;IAE3B,IAAID,OAAO,CAACC,MAAM,EAAE;MAClB,MAAM,IAAIC,KAAK,CAAC,uDAAuD,CAAC;;IAG1E,IAAIC,GAAG,GAAG,CAAC;IACX,MAAMC,GAAG,GAAGL,MAAM,CAACM,MAAM;IACzB,MAAMC,GAAG,GAAG,EAAE;IAEd,IAAIC,EAAE,GAAG,CAAC,CAAC,CAAC;IACZ,IAAIC,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,EAAE,EAAEN,GAAG,IAAIA,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAC/C,IAAIO,MAAM,GAAG,IAAIC,UAAU,CAAEJ,IAAI,IAAI,CAAC,IAAK,CAAC,CAAC,CAAC,CAAC;IAE/C,OAAOL,GAAG,GAAGC,GAAG,EAAE;MAChB,IAAIP,KAAK,GAAGE,MAAM,CAACc,UAAU,CAACV,GAAG,EAAE,CAAC;MACpC,IAAIN,KAAK,IAAI,MAAM,IAAIA,KAAK,IAAI,MAAM,EAAE;QACtC;QACA,IAAIM,GAAG,GAAGC,GAAG,EAAE;UACb,MAAMU,KAAK,GAAGf,MAAM,CAACc,UAAU,CAACV,GAAG,CAAC;UACpC,IAAI,CAACW,KAAK,GAAG,MAAM,MAAM,MAAM,EAAE;YAC/B,EAAEX,GAAG;YACLN,KAAK,GAAG,CAAC,CAACA,KAAK,GAAG,KAAK,KAAK,EAAE,KAAKiB,KAAK,GAAG,KAAK,CAAC,GAAG,OAAO;;;QAG/D,IAAIjB,KAAK,IAAI,MAAM,IAAIA,KAAK,IAAI,MAAM,EAAE;UACtC,SAAS,CAAC;;;MAId;MACA,IAAIU,EAAE,GAAG,CAAC,GAAGI,MAAM,CAACN,MAAM,EAAE;QAC1BG,IAAI,IAAI,CAAC,CAAC,CAAC;QACXA,IAAI,IAAI,GAAG,GAAIL,GAAG,GAAGJ,MAAM,CAACM,MAAM,GAAI,CAAC,CAAC,CAAC;QACzCG,IAAI,GAAIA,IAAI,IAAI,CAAC,IAAK,CAAC,CAAC,CAAC;QAEzB,MAAMO,MAAM,GAAG,IAAIH,UAAU,CAACJ,IAAI,CAAC;QACnCO,MAAM,CAACC,GAAG,CAACL,MAAM,CAAC;QAClBA,MAAM,GAAGI,MAAM;;MAGjB,IAAI,CAAClB,KAAK,GAAG,UAAU,MAAM,CAAC,EAAE;QAC9B;QACAc,MAAM,CAACJ,EAAE,EAAE,CAAC,GAAGV,KAAK,CAAC,CAAC;QACtB;OACD,MAAM,IAAI,CAACA,KAAK,GAAG,UAAU,MAAM,CAAC,EAAE;QACrC;QACAc,MAAM,CAACJ,EAAE,EAAE,CAAC,GAAKV,KAAK,IAAI,CAAC,GAAI,IAAI,GAAI,IAAI;OAC5C,MAAM,IAAI,CAACA,KAAK,GAAG,UAAU,MAAM,CAAC,EAAE;QACrC;QACAc,MAAM,CAACJ,EAAE,EAAE,CAAC,GAAKV,KAAK,IAAI,EAAE,GAAI,IAAI,GAAI,IAAI;QAC5Cc,MAAM,CAACJ,EAAE,EAAE,CAAC,GAAKV,KAAK,IAAI,CAAC,GAAI,IAAI,GAAI,IAAI;OAC5C,MAAM,IAAI,CAACA,KAAK,GAAG,UAAU,MAAM,CAAC,EAAE;QACrC;QACAc,MAAM,CAACJ,EAAE,EAAE,CAAC,GAAKV,KAAK,IAAI,EAAE,GAAI,IAAI,GAAI,IAAI;QAC5Cc,MAAM,CAACJ,EAAE,EAAE,CAAC,GAAKV,KAAK,IAAI,EAAE,GAAI,IAAI,GAAI,IAAI;QAC5Cc,MAAM,CAACJ,EAAE,EAAE,CAAC,GAAKV,KAAK,IAAI,CAAC,GAAI,IAAI,GAAI,IAAI;OAC5C,MAAM;QACL;QACA;;MAGFc,MAAM,CAACJ,EAAE,EAAE,CAAC,GAAIV,KAAK,GAAG,IAAI,GAAI,IAAI;;IAGtC,OAAOc,MAAM,CAACM,KAAK,CAAC,CAAC,EAAEV,EAAE,CAAC;EAC5B,CAAC;EAED;;;;;EAKA,SAASW,eAAeA,CAAC1B,QAAQ,GAAG,OAAO,EAAEQ,OAAO,GAAG;IAAEmB,KAAK,EAAE;EAAK,CAAE;IACrE,IAAI3B,QAAQ,KAAK,OAAO,EAAE;MACxB,MAAM,IAAIC,UAAU,CAClB,oEAAoED,QAAQ,gBAAgB,CAC7F;;IAEH,IAAIQ,OAAO,CAACmB,KAAK,EAAE;MACjB,MAAM,IAAIjB,KAAK,CACb,uEAAuE,CACxE;;EAEL;EAEAR,MAAM,CAACC,cAAc,CAACuB,eAAe,CAACtB,SAAS,EAAE,UAAU,EAAE;IAC3DC,KAAK,EAAE;GACR,CAAC;EAEFH,MAAM,CAACC,cAAc,CAACuB,eAAe,CAACtB,SAAS,EAAE,OAAO,EAAE;IAAEC,KAAK,EAAE;EAAK,CAAE,CAAC;EAE3EH,MAAM,CAACC,cAAc,CAACuB,eAAe,CAACtB,SAAS,EAAE,WAAW,EAAE;IAC5DC,KAAK,EAAE;GACR,CAAC;EAEF;;;;EAIAqB,eAAe,CAACtB,SAAS,CAACwB,MAAM,GAAG,UACjCC,MAAM,EACNrB,OAAO,GAAG;IAAEC,MAAM,EAAE;EAAK,CAAE;IAE3B,IAAID,OAAO,CAAC,QAAQ,CAAC,EAAE;MACrB,MAAM,IAAIE,KAAK,CAAC,uDAAuD,CAAC;;IAG1E,MAAMoB,KAAK,GAAG,IAAIV,UAAU,CAACS,MAAM,CAAC;IACpC,IAAIlB,GAAG,GAAG,CAAC;IACX,MAAMC,GAAG,GAAGkB,KAAK,CAACjB,MAAM;IACxB,MAAMC,GAAG,GAAG,EAAE;IAEd,OAAOH,GAAG,GAAGC,GAAG,EAAE;MAChB,MAAMmB,KAAK,GAAGD,KAAK,CAACnB,GAAG,EAAE,CAAC;MAC1B,IAAIoB,KAAK,KAAK,CAAC,EAAE;QACf,MAAM,CAAC;;MAGT,IAAI,CAACA,KAAK,GAAG,IAAI,MAAM,CAAC,EAAE;QACxB;QACAjB,GAAG,CAACkB,IAAI,CAACD,KAAK,CAAC;OAChB,MAAM,IAAI,CAACA,KAAK,GAAG,IAAI,MAAM,IAAI,EAAE;QAClC;QACA,MAAME,KAAK,GAAGH,KAAK,CAACnB,GAAG,EAAE,CAAC,GAAG,IAAI;QACjCG,GAAG,CAACkB,IAAI,CAAE,CAACD,KAAK,GAAG,IAAI,KAAK,CAAC,GAAIE,KAAK,CAAC;OACxC,MAAM,IAAI,CAACF,KAAK,GAAG,IAAI,MAAM,IAAI,EAAE;QAClC,MAAME,KAAK,GAAGH,KAAK,CAACnB,GAAG,EAAE,CAAC,GAAG,IAAI;QACjC,MAAMuB,KAAK,GAAGJ,KAAK,CAACnB,GAAG,EAAE,CAAC,GAAG,IAAI;QACjCG,GAAG,CAACkB,IAAI,CAAE,CAACD,KAAK,GAAG,IAAI,KAAK,EAAE,GAAKE,KAAK,IAAI,CAAE,GAAGC,KAAK,CAAC;OACxD,MAAM,IAAI,CAACH,KAAK,GAAG,IAAI,MAAM,IAAI,EAAE;QAClC,MAAME,KAAK,GAAGH,KAAK,CAACnB,GAAG,EAAE,CAAC,GAAG,IAAI;QACjC,MAAMuB,KAAK,GAAGJ,KAAK,CAACnB,GAAG,EAAE,CAAC,GAAG,IAAI;QACjC,MAAMwB,KAAK,GAAGL,KAAK,CAACnB,GAAG,EAAE,CAAC,GAAG,IAAI;QAEjC;QACA,IAAIyB,SAAS,GACV,CAACL,KAAK,GAAG,IAAI,KAAK,IAAI,GAAKE,KAAK,IAAI,IAAK,GAAIC,KAAK,IAAI,IAAK,GAAGC,KAAK;QACtE,IAAIC,SAAS,GAAG,MAAM,EAAE;UACtB;UACAA,SAAS,IAAI,OAAO;UACpBtB,GAAG,CAACkB,IAAI,CAAGI,SAAS,KAAK,EAAE,GAAI,KAAK,GAAI,MAAM,CAAC;UAC/CA,SAAS,GAAG,MAAM,GAAIA,SAAS,GAAG,KAAM;;QAE1CtB,GAAG,CAACkB,IAAI,CAACI,SAAS,CAAC;OACpB,MAAM;QACL;MAAA;;IAIJ,OAAOC,MAAM,CAACC,YAAY,CAACC,KAAK,CAAC,IAAI,EAAEzB,GAAG,CAAC;EAC7C,CAAC;EAEDhB,KAAK,CAAC,aAAa,CAAC,GAAGC,eAAe;EACtCD,KAAK,CAAC,aAAa,CAAC,GAAG4B,eAAe;AACxC,CAAC,EACC,OAAOc,MAAM,KAAK,WAAW,GACzBA,MAAM,GACN,OAAOC,IAAI,KAAK,WAAW,GAC3BA,IAAI,GACJ,IAAI,CACT","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}