{"ast":null,"code":"/**\n * Returns an array of object with position.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Image} [options.mask] - Region of the image that is analyzed. The rest is omitted.\n * @param {number} [options.region=3] -  1, 2 or 3. Define the region around each points that is analyzed. 1 corresponds to 4 cross points, 2 to\n *        the 8 points around and 3 to the 12 points around the central pixel.\n * @param {number} [options.removeClosePoints=0] - Remove pts which have a distance between them smaller than this param.\n * @param {boolean} [options.invert=false] - Search for minima instead of maxima\n * @param {number} [options.maxEquals=2] - Maximal number of values that may be equal to the maximum\n * @return {number[]} Array whose size is the number of channels\n */\nexport default function localMaxima(options = {}) {\n  let {\n    mask,\n    region = 3,\n    removeClosePoints = 0,\n    invert = false,\n    maxEquals = 2\n  } = options;\n  let image = this;\n  this.checkProcessable('localMaxima', {\n    bitDepth: [8, 16],\n    components: 1\n  });\n  region *= 4;\n  let maskExpectedValue = invert ? 0 : 1;\n  let dx = [+1, 0, -1, 0, +1, +1, -1, -1, +2, 0, -2, 0, +2, +2, -2, -2];\n  let dy = [0, +1, 0, -1, +1, -1, +1, -1, 0, +2, 0, -2, +2, -2, +2, -2];\n  let shift = region <= 8 ? 1 : 2;\n  let points = [];\n  for (let currentY = shift; currentY < image.height - shift; currentY++) {\n    for (let currentX = shift; currentX < image.width - shift; currentX++) {\n      if (mask && mask.getBitXY(currentX, currentY) !== maskExpectedValue) {\n        continue;\n      }\n      let counter = 0;\n      let nbEquals = 0;\n      let currentValue = image.data[currentX + currentY * image.width];\n      for (let dir = 0; dir < region; dir++) {\n        if (invert) {\n          // we search for minima\n          if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] > currentValue) {\n            counter++;\n          }\n        } else {\n          if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] < currentValue) {\n            counter++;\n          }\n        }\n        if (image.data[currentX + dx[dir] + (currentY + dy[dir]) * image.width] === currentValue) {\n          nbEquals++;\n        }\n      }\n      if (counter + nbEquals === region && nbEquals <= maxEquals) {\n        points.push([currentX, currentY]);\n      }\n    }\n  }\n  // TODO How to make a more performant and general way\n  // we don't deal correctly here with groups of points that should be grouped if at the\n  // beginning one of them is closer to another\n  // Seems that we would ened to calculate a matrix and then split this matrix in 'independant matrices'\n  // Or to assign a cluster to each point and regroup them if 2 clusters are close to each other\n  // later approach seems much better\n  if (removeClosePoints > 0) {\n    for (let i = 0; i < points.length; i++) {\n      for (let j = i + 1; j < points.length; j++) {\n        if (Math.sqrt(Math.pow(points[i][0] - points[j][0], 2) + Math.pow(points[i][1] - points[j][1], 2)) < removeClosePoints) {\n          points[i][0] = points[i][0] + points[j][0] >> 1;\n          points[i][1] = points[i][1] + points[j][1] >> 1;\n          points.splice(j, 1);\n          j--;\n        }\n      }\n    }\n  }\n  return points;\n}","map":{"version":3,"names":["localMaxima","options","mask","region","removeClosePoints","invert","maxEquals","image","checkProcessable","bitDepth","components","maskExpectedValue","dx","dy","shift","points","currentY","height","currentX","width","getBitXY","counter","nbEquals","currentValue","data","dir","push","i","length","j","Math","sqrt","pow","splice"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/compute/localMaxima.js"],"sourcesContent":["/**\n * Returns an array of object with position.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {Image} [options.mask] - Region of the image that is analyzed. The rest is omitted.\n * @param {number} [options.region=3] -  1, 2 or 3. Define the region around each points that is analyzed. 1 corresponds to 4 cross points, 2 to\n *        the 8 points around and 3 to the 12 points around the central pixel.\n * @param {number} [options.removeClosePoints=0] - Remove pts which have a distance between them smaller than this param.\n * @param {boolean} [options.invert=false] - Search for minima instead of maxima\n * @param {number} [options.maxEquals=2] - Maximal number of values that may be equal to the maximum\n * @return {number[]} Array whose size is the number of channels\n */\nexport default function localMaxima(options = {}) {\n  let {\n    mask,\n    region = 3,\n    removeClosePoints = 0,\n    invert = false,\n    maxEquals = 2,\n  } = options;\n  let image = this;\n  this.checkProcessable('localMaxima', {\n    bitDepth: [8, 16],\n    components: 1,\n  });\n  region *= 4;\n\n  let maskExpectedValue = invert ? 0 : 1;\n\n  let dx = [+1, 0, -1, 0, +1, +1, -1, -1, +2, 0, -2, 0, +2, +2, -2, -2];\n  let dy = [0, +1, 0, -1, +1, -1, +1, -1, 0, +2, 0, -2, +2, -2, +2, -2];\n  let shift = region <= 8 ? 1 : 2;\n  let points = [];\n  for (let currentY = shift; currentY < image.height - shift; currentY++) {\n    for (let currentX = shift; currentX < image.width - shift; currentX++) {\n      if (mask && mask.getBitXY(currentX, currentY) !== maskExpectedValue) {\n        continue;\n      }\n      let counter = 0;\n      let nbEquals = 0;\n      let currentValue = image.data[currentX + currentY * image.width];\n      for (let dir = 0; dir < region; dir++) {\n        if (invert) {\n          // we search for minima\n          if (\n            image.data[\n              currentX + dx[dir] + (currentY + dy[dir]) * image.width\n            ] > currentValue\n          ) {\n            counter++;\n          }\n        } else {\n          if (\n            image.data[\n              currentX + dx[dir] + (currentY + dy[dir]) * image.width\n            ] < currentValue\n          ) {\n            counter++;\n          }\n        }\n        if (\n          image.data[\n            currentX + dx[dir] + (currentY + dy[dir]) * image.width\n          ] === currentValue\n        ) {\n          nbEquals++;\n        }\n      }\n      if (counter + nbEquals === region && nbEquals <= maxEquals) {\n        points.push([currentX, currentY]);\n      }\n    }\n  }\n  // TODO How to make a more performant and general way\n  // we don't deal correctly here with groups of points that should be grouped if at the\n  // beginning one of them is closer to another\n  // Seems that we would ened to calculate a matrix and then split this matrix in 'independant matrices'\n  // Or to assign a cluster to each point and regroup them if 2 clusters are close to each other\n  // later approach seems much better\n  if (removeClosePoints > 0) {\n    for (let i = 0; i < points.length; i++) {\n      for (let j = i + 1; j < points.length; j++) {\n        if (\n          Math.sqrt(\n            Math.pow(points[i][0] - points[j][0], 2) +\n              Math.pow(points[i][1] - points[j][1], 2),\n          ) < removeClosePoints\n        ) {\n          points[i][0] = (points[i][0] + points[j][0]) >> 1;\n          points[i][1] = (points[i][1] + points[j][1]) >> 1;\n          points.splice(j, 1);\n          j--;\n        }\n      }\n    }\n  }\n  return points;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}