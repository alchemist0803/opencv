{"ast":null,"code":"import { RGB } from '../model/model';\n\n/**\n * Retrieve the data of the current image as RGBA 8 bits\n * The source image may be:\n * * a mask (binary image)\n * * a grey image (8 16 bits) with or without alpha channel\n * * a color image (8 or 16 bits) with or without alpha channel in with RGB model\n * @instance\n * @memberof Image\n * @param {object} [options]\n * @param {boolean} [options.clamped] - If true, the function will return a Uint8ClampedArray\n * @return {Uint8Array|Uint8ClampedArray} - Array with the data\n */\nexport default function getRGBAData(options = {}) {\n  const {\n    clamped\n  } = options;\n  this.checkProcessable('getRGBAData', {\n    components: [1, 3],\n    bitDepth: [1, 8, 16, 32]\n  });\n  const arrayLength = this.width * this.height * 4;\n  let newData = clamped ? new Uint8ClampedArray(arrayLength) : new Uint8Array(arrayLength);\n  if (this.bitDepth === 1) {\n    fillDataFromBinary(this, newData);\n  } else if (this.bitDepth === 32) {\n    this.checkProcessable('getRGBAData', {\n      alpha: 0\n    });\n    if (this.components === 1) {\n      fillDataFromGrey32(this, newData);\n    } else if (this.components === 3) {\n      this.checkProcessable('getRGBAData', {\n        colorModel: [RGB]\n      });\n      fillDataFromRGB32(this, newData);\n    }\n  } else {\n    if (this.components === 1) {\n      fillDataFromGrey(this, newData);\n    } else if (this.components === 3) {\n      this.checkProcessable('getRGBAData', {\n        colorModel: [RGB]\n      });\n      fillDataFromRGB(this, newData);\n    }\n  }\n  if (this.alpha === 1) {\n    this.checkProcessable('getRGBAData', {\n      bitDepth: [8, 16]\n    });\n    copyAlpha(this, newData);\n  } else {\n    fillAlpha(this, newData);\n  }\n  return newData;\n}\nfunction fillDataFromBinary(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    const value = image.getBit(i);\n    newData[i * 4] = value * 255;\n    newData[i * 4 + 1] = value * 255;\n    newData[i * 4 + 2] = value * 255;\n  }\n}\nfunction fillDataFromGrey32(image, newData) {\n  const min = image.min[0];\n  const max = image.max[0];\n  const range = max - min;\n  for (let i = 0; i < image.size; i++) {\n    const val = Math.floor(255 * (image.data[i] - min) / range);\n    newData[i * 4] = val;\n    newData[i * 4 + 1] = val;\n    newData[i * 4 + 2] = val;\n  }\n}\nfunction fillDataFromRGB32(image, newData) {\n  const min = Math.min(...image.min);\n  const max = Math.max(...image.max);\n  const range = max - min;\n  for (let i = 0; i < image.size; i++) {\n    const val1 = Math.floor(255 * (image.data[i * 3] - min) / range);\n    const val2 = Math.floor(255 * (image.data[i * 3 + 1] - min) / range);\n    const val3 = Math.floor(255 * (image.data[i * 3 + 2] - min) / range);\n    newData[i * 4] = val1;\n    newData[i * 4 + 1] = val2;\n    newData[i * 4 + 2] = val3;\n  }\n}\nfunction fillDataFromGrey(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4] = image.data[i * image.channels] >>> image.bitDepth - 8;\n    newData[i * 4 + 1] = image.data[i * image.channels] >>> image.bitDepth - 8;\n    newData[i * 4 + 2] = image.data[i * image.channels] >>> image.bitDepth - 8;\n  }\n}\nfunction fillDataFromRGB(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4] = image.data[i * image.channels] >>> image.bitDepth - 8;\n    newData[i * 4 + 1] = image.data[i * image.channels + 1] >>> image.bitDepth - 8;\n    newData[i * 4 + 2] = image.data[i * image.channels + 2] >>> image.bitDepth - 8;\n  }\n}\nfunction copyAlpha(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4 + 3] = image.data[i * image.channels + image.components] >> image.bitDepth - 8;\n  }\n}\nfunction fillAlpha(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4 + 3] = 255;\n  }\n}","map":{"version":3,"names":["RGB","getRGBAData","options","clamped","checkProcessable","components","bitDepth","arrayLength","width","height","newData","Uint8ClampedArray","Uint8Array","fillDataFromBinary","alpha","fillDataFromGrey32","colorModel","fillDataFromRGB32","fillDataFromGrey","fillDataFromRGB","copyAlpha","fillAlpha","image","i","size","value","getBit","min","max","range","val","Math","floor","data","val1","val2","val3","channels"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/core/getRGBAData.js"],"sourcesContent":["import { RGB } from '../model/model';\n\n/**\n * Retrieve the data of the current image as RGBA 8 bits\n * The source image may be:\n * * a mask (binary image)\n * * a grey image (8 16 bits) with or without alpha channel\n * * a color image (8 or 16 bits) with or without alpha channel in with RGB model\n * @instance\n * @memberof Image\n * @param {object} [options]\n * @param {boolean} [options.clamped] - If true, the function will return a Uint8ClampedArray\n * @return {Uint8Array|Uint8ClampedArray} - Array with the data\n */\nexport default function getRGBAData(options = {}) {\n  const { clamped } = options;\n  this.checkProcessable('getRGBAData', {\n    components: [1, 3],\n    bitDepth: [1, 8, 16, 32],\n  });\n  const arrayLength = this.width * this.height * 4;\n  let newData = clamped\n    ? new Uint8ClampedArray(arrayLength)\n    : new Uint8Array(arrayLength);\n  if (this.bitDepth === 1) {\n    fillDataFromBinary(this, newData);\n  } else if (this.bitDepth === 32) {\n    this.checkProcessable('getRGBAData', { alpha: 0 });\n    if (this.components === 1) {\n      fillDataFromGrey32(this, newData);\n    } else if (this.components === 3) {\n      this.checkProcessable('getRGBAData', { colorModel: [RGB] });\n      fillDataFromRGB32(this, newData);\n    }\n  } else {\n    if (this.components === 1) {\n      fillDataFromGrey(this, newData);\n    } else if (this.components === 3) {\n      this.checkProcessable('getRGBAData', { colorModel: [RGB] });\n      fillDataFromRGB(this, newData);\n    }\n  }\n  if (this.alpha === 1) {\n    this.checkProcessable('getRGBAData', { bitDepth: [8, 16] });\n    copyAlpha(this, newData);\n  } else {\n    fillAlpha(this, newData);\n  }\n  return newData;\n}\n\nfunction fillDataFromBinary(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    const value = image.getBit(i);\n    newData[i * 4] = value * 255;\n    newData[i * 4 + 1] = value * 255;\n    newData[i * 4 + 2] = value * 255;\n  }\n}\n\nfunction fillDataFromGrey32(image, newData) {\n  const min = image.min[0];\n  const max = image.max[0];\n  const range = max - min;\n  for (let i = 0; i < image.size; i++) {\n    const val = Math.floor((255 * (image.data[i] - min)) / range);\n    newData[i * 4] = val;\n    newData[i * 4 + 1] = val;\n    newData[i * 4 + 2] = val;\n  }\n}\n\nfunction fillDataFromRGB32(image, newData) {\n  const min = Math.min(...image.min);\n  const max = Math.max(...image.max);\n  const range = max - min;\n  for (let i = 0; i < image.size; i++) {\n    const val1 = Math.floor((255 * (image.data[i * 3] - min)) / range);\n    const val2 = Math.floor((255 * (image.data[i * 3 + 1] - min)) / range);\n    const val3 = Math.floor((255 * (image.data[i * 3 + 2] - min)) / range);\n    newData[i * 4] = val1;\n    newData[i * 4 + 1] = val2;\n    newData[i * 4 + 2] = val3;\n  }\n}\n\nfunction fillDataFromGrey(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4] = image.data[i * image.channels] >>> (image.bitDepth - 8);\n    newData[i * 4 + 1] =\n      image.data[i * image.channels] >>> (image.bitDepth - 8);\n    newData[i * 4 + 2] =\n      image.data[i * image.channels] >>> (image.bitDepth - 8);\n  }\n}\n\nfunction fillDataFromRGB(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4] = image.data[i * image.channels] >>> (image.bitDepth - 8);\n    newData[i * 4 + 1] =\n      image.data[i * image.channels + 1] >>> (image.bitDepth - 8);\n    newData[i * 4 + 2] =\n      image.data[i * image.channels + 2] >>> (image.bitDepth - 8);\n  }\n}\n\nfunction copyAlpha(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4 + 3] =\n      image.data[i * image.channels + image.components] >> (image.bitDepth - 8);\n  }\n}\n\nfunction fillAlpha(image, newData) {\n  for (let i = 0; i < image.size; i++) {\n    newData[i * 4 + 3] = 255;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}