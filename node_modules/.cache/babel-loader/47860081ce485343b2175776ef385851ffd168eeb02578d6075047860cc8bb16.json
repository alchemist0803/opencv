{"ast":null,"code":"/*\n *\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html.\n * Huang: Implements Huang's fuzzy thresholding method: Huang, L-K & Wang, M-J J (1995),\n * \"Image thresholding by minimizing the measure of fuzziness\", Pattern Recognition 28(1): 41-51\n *\n */\n\nexport default function huang(histogram) {\n  /* Determine the first non-zero bin */\n  let firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (histogram[ih] !== 0) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  let lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (histogram[ih] !== 0) {\n      lastBin = ih;\n      break;\n    }\n  }\n  let term = 1.0 / (lastBin - firstBin);\n  let mu0 = new Array(histogram.length);\n  let sumPix = 0;\n  let numPix = 0;\n  for (let ih = firstBin; ih < histogram.length; ih++) {\n    sumPix += ih * histogram[ih];\n    numPix += histogram[ih];\n    mu0[ih] = sumPix / numPix;\n  }\n  let mu1 = new Array(histogram.length);\n  sumPix = numPix = 0;\n  for (let ih = lastBin; ih > 0; ih--) {\n    sumPix += ih * histogram[ih];\n    numPix += histogram[ih];\n    mu1[ih - 1] = sumPix / numPix;\n  }\n\n  /* Determine the threshold that minimizes the fuzzy entropy*/\n  let threshold = -1;\n  let minEnt = Number.MAX_VALUE;\n  for (let it = 0; it < histogram.length; it++) {\n    let ent = 0;\n    let muX;\n    for (let ih = 0; ih <= it; ih++) {\n      /* Equation (4) in Ref. 1 */\n      muX = 1 / (1 + term * Math.abs(ih - mu0[it]));\n      if (!(muX < 1e-6 || muX > 0.999999)) {\n        /* Equation (6) & (8) in Ref. 1 */\n        ent += histogram[ih] * (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));\n      }\n    }\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      /* Equation (4) in Ref. 1 */\n      muX = 1 / (1 + term * Math.abs(ih - mu1[it]));\n      if (!(muX < 1e-6 || muX > 0.999999)) {\n        /* Equation (6) & (8) in Ref. 1 */\n        ent += histogram[ih] * (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));\n      }\n    }\n    if (ent < minEnt) {\n      minEnt = ent;\n      threshold = it;\n    }\n  }\n  return threshold;\n}","map":{"version":3,"names":["huang","histogram","firstBin","ih","length","lastBin","term","mu0","Array","sumPix","numPix","mu1","threshold","minEnt","Number","MAX_VALUE","it","ent","muX","Math","abs","log"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/huang.js"],"sourcesContent":["/*\n *\n * see http://rsb.info.nih.gov/ij/developer/source/ij/process/AutoThresholder.java.html.\n * Huang: Implements Huang's fuzzy thresholding method: Huang, L-K & Wang, M-J J (1995),\n * \"Image thresholding by minimizing the measure of fuzziness\", Pattern Recognition 28(1): 41-51\n *\n */\n\nexport default function huang(histogram) {\n  /* Determine the first non-zero bin */\n  let firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (histogram[ih] !== 0) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  let lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (histogram[ih] !== 0) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  let term = 1.0 / (lastBin - firstBin);\n  let mu0 = new Array(histogram.length);\n  let sumPix = 0;\n  let numPix = 0;\n  for (let ih = firstBin; ih < histogram.length; ih++) {\n    sumPix += ih * histogram[ih];\n    numPix += histogram[ih];\n    mu0[ih] = sumPix / numPix;\n  }\n\n  let mu1 = new Array(histogram.length);\n  sumPix = numPix = 0;\n  for (let ih = lastBin; ih > 0; ih--) {\n    sumPix += ih * histogram[ih];\n    numPix += histogram[ih];\n    mu1[ih - 1] = sumPix / numPix;\n  }\n\n  /* Determine the threshold that minimizes the fuzzy entropy*/\n  let threshold = -1;\n  let minEnt = Number.MAX_VALUE;\n  for (let it = 0; it < histogram.length; it++) {\n    let ent = 0;\n    let muX;\n    for (let ih = 0; ih <= it; ih++) {\n      /* Equation (4) in Ref. 1 */\n      muX = 1 / (1 + term * Math.abs(ih - mu0[it]));\n      if (!(muX < 1e-6 || muX > 0.999999)) {\n        /* Equation (6) & (8) in Ref. 1 */\n        ent +=\n          histogram[ih] *\n          (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));\n      }\n    }\n\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      /* Equation (4) in Ref. 1 */\n      muX = 1 / (1 + term * Math.abs(ih - mu1[it]));\n      if (!(muX < 1e-6 || muX > 0.999999)) {\n        /* Equation (6) & (8) in Ref. 1 */\n        ent +=\n          histogram[ih] *\n          (-muX * Math.log(muX) - (1 - muX) * Math.log(1 - muX));\n      }\n    }\n\n    if (ent < minEnt) {\n      minEnt = ent;\n      threshold = it;\n    }\n  }\n  return threshold;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}