{"ast":null,"code":"// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Kapur J.N., Sahoo P.K., and Wong A.K.C. (1985) \"A New Method for\n// Gray-Level Picture Thresholding Using the Entropy of the Histogram\"\n// Graphical Models and Image Processing, 29(3): 273-285\n// M. Emre Celebi\n// 06.15.2007\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\nexport default function renyiEntropy(histogram, total) {\n  let optThreshold; // Optimal threshold\n  let firstBin; // First non-zero bin\n  let lastBin; // last non-zero bin\n\n  let normHisto = new Array(histogram.length); // normalized histogram\n  let P1 = new Array(histogram.length); // acumulative normalized histogram\n  let P2 = new Array(histogram.length); // acumulative normalized histogram\n\n  // Entropy Variables\n  let threshold1 = 0;\n  let threshold2 = 0;\n  let threshold3 = 0;\n  let maxEnt1 = 0.0;\n  let maxEnt2 = 0.0;\n  let maxEnt3 = 0.0;\n  let alpha2 = 0.5;\n  let term2 = 1.0 / (1.0 - alpha2);\n  let alpha3 = 2.0;\n  let term3 = 1.0 / (1.0 - alpha3);\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n\n  /* Determine the first non-zero bin */\n  firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  /* Maximum Entropy Thresholding - BEGIN */\n  /* ALPHA = 1.0 */\n  /* Calculate the total entropy each gray-level\n     and find the threshold that maximizes it\n     */\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    let entBack1 = 0.0;\n    let entBack2 = 0.0;\n    let entBack3 = 0.0;\n    for (let ih = 0; ih <= it; ih++) {\n      if (histogram[ih] !== 0) {\n        entBack1 -= normHisto[ih] / P1[it] * Math.log(normHisto[ih] / P1[it]);\n      }\n      entBack2 += Math.sqrt(normHisto[ih] / P1[it]);\n      entBack3 += normHisto[ih] * normHisto[ih] / (P1[it] * P1[it]);\n    }\n\n    /* Entropy of the object pixels */\n    let entObj1 = 0.0;\n    let entObj2 = 0.0;\n    let entObj3 = 0.0;\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      if (histogram[ih] !== 0) {\n        entObj1 -= normHisto[ih] / P2[it] * Math.log(normHisto[ih] / P2[it]);\n      }\n      entObj2 += Math.sqrt(normHisto[ih] / P2[it]);\n      entObj3 += normHisto[ih] * normHisto[ih] / (P2[it] * P2[it]);\n    }\n\n    /* Total entropy */\n    let totEnt1 = entBack1 + entObj1;\n    let totEnt2 = term2 * (entBack2 * entObj2 > 0.0 ? Math.log(entBack2 * entObj2) : 0.0);\n    let totEnt3 = term3 * (entBack3 * entObj3 > 0.0 ? Math.log(entBack3 * entObj3) : 0.0);\n    if (totEnt1 > maxEnt1) {\n      maxEnt1 = totEnt1;\n      threshold1 = it;\n    }\n    if (totEnt2 > maxEnt2) {\n      maxEnt2 = totEnt2;\n      threshold2 = it;\n    }\n    if (totEnt3 > maxEnt3) {\n      maxEnt3 = totEnt3;\n      threshold3 = it;\n    }\n  }\n  /* End Maximum Entropy Thresholding */\n\n  let tStars = [threshold1, threshold2, threshold3];\n  tStars.sort((a, b) => a - b);\n  let betas;\n\n  /* Adjust beta values */\n  if (Math.abs(tStars[0] - tStars[1]) <= 5) {\n    if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n      betas = [1, 2, 1];\n    } else {\n      betas = [0, 1, 3];\n    }\n  } else {\n    if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n      betas = [3, 1, 0];\n    } else {\n      betas = [1, 2, 1];\n    }\n  }\n\n  /* Determine the optimal threshold value */\n  let omega = P1[tStars[2]] - P1[tStars[0]];\n  optThreshold = Math.round(tStars[0] * (P1[tStars[0]] + 0.25 * omega * betas[0]) + 0.25 * tStars[1] * omega * betas[1] + tStars[2] * (P2[tStars[2]] + 0.25 * omega * betas[2]));\n  return optThreshold;\n}","map":{"version":3,"names":["renyiEntropy","histogram","total","optThreshold","firstBin","lastBin","normHisto","Array","length","P1","P2","threshold1","threshold2","threshold3","maxEnt1","maxEnt2","maxEnt3","alpha2","term2","alpha3","term3","ih","Math","abs","Number","EPSILON","it","entBack1","entBack2","entBack3","log","sqrt","entObj1","entObj2","entObj3","totEnt1","totEnt2","totEnt3","tStars","sort","a","b","betas","omega","round"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/mask/renyiEntropy.js"],"sourcesContent":["// see https://github.com/fiji/Auto_Threshold/blob/master/src/main/java/fiji/threshold/Auto_Threshold.java\n// Kapur J.N., Sahoo P.K., and Wong A.K.C. (1985) \"A New Method for\n// Gray-Level Picture Thresholding Using the Entropy of the Histogram\"\n// Graphical Models and Image Processing, 29(3): 273-285\n// M. Emre Celebi\n// 06.15.2007\n// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines\nexport default function renyiEntropy(histogram, total) {\n  let optThreshold; // Optimal threshold\n  let firstBin; // First non-zero bin\n  let lastBin; // last non-zero bin\n\n  let normHisto = new Array(histogram.length); // normalized histogram\n  let P1 = new Array(histogram.length); // acumulative normalized histogram\n  let P2 = new Array(histogram.length); // acumulative normalized histogram\n\n  // Entropy Variables\n  let threshold1 = 0;\n  let threshold2 = 0;\n  let threshold3 = 0;\n  let maxEnt1 = 0.0;\n  let maxEnt2 = 0.0;\n  let maxEnt3 = 0.0;\n  let alpha2 = 0.5;\n  let term2 = 1.0 / (1.0 - alpha2);\n  let alpha3 = 2.0;\n  let term3 = 1.0 / (1.0 - alpha3);\n\n  for (let ih = 0; ih < histogram.length; ih++) {\n    normHisto[ih] = histogram[ih] / total;\n  }\n\n  P1[0] = normHisto[0];\n  P2[0] = 1.0 - P1[0];\n  for (let ih = 1; ih < histogram.length; ih++) {\n    P1[ih] = P1[ih - 1] + normHisto[ih];\n    P2[ih] = 1.0 - P1[ih];\n  }\n\n  /* Determine the first non-zero bin */\n  firstBin = 0;\n  for (let ih = 0; ih < histogram.length; ih++) {\n    if (Math.abs(P1[ih]) >= Number.EPSILON) {\n      firstBin = ih;\n      break;\n    }\n  }\n\n  /* Determine the last non-zero bin */\n  lastBin = histogram.length - 1;\n  for (let ih = histogram.length - 1; ih >= firstBin; ih--) {\n    if (Math.abs(P2[ih]) >= Number.EPSILON) {\n      lastBin = ih;\n      break;\n    }\n  }\n\n  /* Maximum Entropy Thresholding - BEGIN */\n  /* ALPHA = 1.0 */\n  /* Calculate the total entropy each gray-level\n     and find the threshold that maximizes it\n     */\n  for (let it = firstBin; it <= lastBin; it++) {\n    /* Entropy of the background pixels */\n    let entBack1 = 0.0;\n    let entBack2 = 0.0;\n    let entBack3 = 0.0;\n    for (let ih = 0; ih <= it; ih++) {\n      if (histogram[ih] !== 0) {\n        entBack1 -= (normHisto[ih] / P1[it]) * Math.log(normHisto[ih] / P1[it]);\n      }\n      entBack2 += Math.sqrt(normHisto[ih] / P1[it]);\n      entBack3 += (normHisto[ih] * normHisto[ih]) / (P1[it] * P1[it]);\n    }\n\n    /* Entropy of the object pixels */\n    let entObj1 = 0.0;\n    let entObj2 = 0.0;\n    let entObj3 = 0.0;\n    for (let ih = it + 1; ih < histogram.length; ih++) {\n      if (histogram[ih] !== 0) {\n        entObj1 -= (normHisto[ih] / P2[it]) * Math.log(normHisto[ih] / P2[it]);\n      }\n      entObj2 += Math.sqrt(normHisto[ih] / P2[it]);\n      entObj3 += (normHisto[ih] * normHisto[ih]) / (P2[it] * P2[it]);\n    }\n\n    /* Total entropy */\n    let totEnt1 = entBack1 + entObj1;\n    let totEnt2 =\n      term2 * (entBack2 * entObj2 > 0.0 ? Math.log(entBack2 * entObj2) : 0.0);\n    let totEnt3 =\n      term3 * (entBack3 * entObj3 > 0.0 ? Math.log(entBack3 * entObj3) : 0.0);\n\n    if (totEnt1 > maxEnt1) {\n      maxEnt1 = totEnt1;\n      threshold1 = it;\n    }\n\n    if (totEnt2 > maxEnt2) {\n      maxEnt2 = totEnt2;\n      threshold2 = it;\n    }\n\n    if (totEnt3 > maxEnt3) {\n      maxEnt3 = totEnt3;\n      threshold3 = it;\n    }\n  }\n  /* End Maximum Entropy Thresholding */\n\n  let tStars = [threshold1, threshold2, threshold3];\n  tStars.sort((a, b) => a - b);\n\n  let betas;\n\n  /* Adjust beta values */\n  if (Math.abs(tStars[0] - tStars[1]) <= 5) {\n    if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n      betas = [1, 2, 1];\n    } else {\n      betas = [0, 1, 3];\n    }\n  } else {\n    if (Math.abs(tStars[1] - tStars[2]) <= 5) {\n      betas = [3, 1, 0];\n    } else {\n      betas = [1, 2, 1];\n    }\n  }\n\n  /* Determine the optimal threshold value */\n  let omega = P1[tStars[2]] - P1[tStars[0]];\n  optThreshold = Math.round(\n    tStars[0] * (P1[tStars[0]] + 0.25 * omega * betas[0]) +\n      0.25 * tStars[1] * omega * betas[1] +\n      tStars[2] * (P2[tStars[2]] + 0.25 * omega * betas[2]),\n  );\n\n  return optThreshold;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}