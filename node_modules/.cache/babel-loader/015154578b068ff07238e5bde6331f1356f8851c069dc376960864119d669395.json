{"ast":null,"code":"/**\n * Crops the image based on the alpha channel\n * This removes lines and columns where the alpha channel is lower than a threshold value.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.threshold=this.maxValue]\n * @return {Image}\n */\nexport default function cropAlpha(options = {}) {\n  this.checkProcessable('cropAlpha', {\n    alpha: 1\n  });\n  const {\n    threshold = this.maxValue\n  } = options;\n  let left = findLeft(this, threshold, this.components);\n  if (left === -1) {\n    throw new Error('Could not find new dimensions. Threshold may be too high.');\n  }\n  let top = findTop(this, threshold, this.components, left);\n  let bottom = findBottom(this, threshold, this.components, left);\n  let right = findRight(this, threshold, this.components, left, top, bottom);\n  return this.crop({\n    x: left,\n    y: top,\n    width: right - left + 1,\n    height: bottom - top + 1\n  });\n}\nfunction findLeft(image, threshold, channel) {\n  for (let x = 0; x < image.width; x++) {\n    for (let y = 0; y < image.height; y++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return x;\n      }\n    }\n  }\n  return -1;\n}\nfunction findTop(image, threshold, channel, left) {\n  for (let y = 0; y < image.height; y++) {\n    for (let x = left; x < image.width; x++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return y;\n      }\n    }\n  }\n  return -1;\n}\nfunction findBottom(image, threshold, channel, left) {\n  for (let y = image.height - 1; y >= 0; y--) {\n    for (let x = left; x < image.width; x++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return y;\n      }\n    }\n  }\n  return -1;\n}\nfunction findRight(image, threshold, channel, left, top, bottom) {\n  for (let x = image.width - 1; x >= left; x--) {\n    for (let y = top; y <= bottom; y++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return x;\n      }\n    }\n  }\n  return -1;\n}","map":{"version":3,"names":["cropAlpha","options","checkProcessable","alpha","threshold","maxValue","left","findLeft","components","Error","top","findTop","bottom","findBottom","right","findRight","crop","x","y","width","height","image","channel","getValueXY"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/transform/cropAlpha.js"],"sourcesContent":["/**\n * Crops the image based on the alpha channel\n * This removes lines and columns where the alpha channel is lower than a threshold value.\n * @memberof Image\n * @instance\n * @param {object} [options]\n * @param {number} [options.threshold=this.maxValue]\n * @return {Image}\n */\nexport default function cropAlpha(options = {}) {\n  this.checkProcessable('cropAlpha', {\n    alpha: 1,\n  });\n\n  const { threshold = this.maxValue } = options;\n\n  let left = findLeft(this, threshold, this.components);\n\n  if (left === -1) {\n    throw new Error(\n      'Could not find new dimensions. Threshold may be too high.',\n    );\n  }\n\n  let top = findTop(this, threshold, this.components, left);\n  let bottom = findBottom(this, threshold, this.components, left);\n  let right = findRight(this, threshold, this.components, left, top, bottom);\n\n  return this.crop({\n    x: left,\n    y: top,\n    width: right - left + 1,\n    height: bottom - top + 1,\n  });\n}\n\nfunction findLeft(image, threshold, channel) {\n  for (let x = 0; x < image.width; x++) {\n    for (let y = 0; y < image.height; y++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return x;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction findTop(image, threshold, channel, left) {\n  for (let y = 0; y < image.height; y++) {\n    for (let x = left; x < image.width; x++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return y;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction findBottom(image, threshold, channel, left) {\n  for (let y = image.height - 1; y >= 0; y--) {\n    for (let x = left; x < image.width; x++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return y;\n      }\n    }\n  }\n  return -1;\n}\n\nfunction findRight(image, threshold, channel, left, top, bottom) {\n  for (let x = image.width - 1; x >= left; x--) {\n    for (let y = top; y <= bottom; y++) {\n      if (image.getValueXY(x, y, channel) >= threshold) {\n        return x;\n      }\n    }\n  }\n  return -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}