{"ast":null,"code":"import quickSelectMedian from 'median-quickselect';\nimport { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n\n/**\n * Each pixel of the image becomes the median of the neighbor pixels.\n * @memberof Image\n * @instance\n * @param {object} options\n * @param {SelectedChannels} [options.channels] - Specify which channels should be processed.\n * @param {number} [options.radius=1] - Distance of the square to take the mean of.\n * @param {string} [options.border='copy'] - Algorithm that will be applied after to deal with borders.\n * @return {Image}\n */\nexport default function medianFilter(options = {}) {\n  let {\n    radius = 1,\n    border = 'copy',\n    channels\n  } = options;\n  this.checkProcessable('medianFilter', {\n    bitDepth: [8, 16]\n  });\n  if (radius < 1) {\n    throw new Error('radius must be greater than 0');\n  }\n  channels = validateArrayOfChannels(this, channels, true);\n  let kWidth = radius;\n  let kHeight = radius;\n  let newImage = Image.createFrom(this);\n  let size = (kWidth * 2 + 1) * (kHeight * 2 + 1);\n  let kernel = new Array(size);\n  for (let channel = 0; channel < channels.length; channel++) {\n    let c = channels[channel];\n    for (let y = kHeight; y < this.height - kHeight; y++) {\n      for (let x = kWidth; x < this.width - kWidth; x++) {\n        let n = 0;\n        for (let j = -kHeight; j <= kHeight; j++) {\n          for (let i = -kWidth; i <= kWidth; i++) {\n            let index = ((y + j) * this.width + x + i) * this.channels + c;\n            kernel[n++] = this.data[index];\n          }\n        }\n        let index = (y * this.width + x) * this.channels + c;\n        newImage.data[index] = quickSelectMedian(kernel);\n      }\n    }\n  }\n  if (this.alpha && !channels.includes(this.channels)) {\n    for (let i = this.components; i < this.data.length; i = i + this.channels) {\n      newImage.data[i] = this.data[i];\n    }\n  }\n  newImage.setBorder({\n    size: [kWidth, kHeight],\n    algorithm: border\n  });\n  return newImage;\n}","map":{"version":3,"names":["quickSelectMedian","validateArrayOfChannels","Image","medianFilter","options","radius","border","channels","checkProcessable","bitDepth","Error","kWidth","kHeight","newImage","createFrom","size","kernel","Array","channel","length","c","y","height","x","width","n","j","i","index","data","alpha","includes","components","setBorder","algorithm"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/filter/medianFilter.js"],"sourcesContent":["import quickSelectMedian from 'median-quickselect';\n\nimport { validateArrayOfChannels } from '../../util/channel';\nimport Image from '../Image';\n\n/**\n * Each pixel of the image becomes the median of the neighbor pixels.\n * @memberof Image\n * @instance\n * @param {object} options\n * @param {SelectedChannels} [options.channels] - Specify which channels should be processed.\n * @param {number} [options.radius=1] - Distance of the square to take the mean of.\n * @param {string} [options.border='copy'] - Algorithm that will be applied after to deal with borders.\n * @return {Image}\n */\nexport default function medianFilter(options = {}) {\n  let { radius = 1, border = 'copy', channels } = options;\n\n  this.checkProcessable('medianFilter', {\n    bitDepth: [8, 16],\n  });\n\n  if (radius < 1) {\n    throw new Error('radius must be greater than 0');\n  }\n\n  channels = validateArrayOfChannels(this, channels, true);\n\n  let kWidth = radius;\n  let kHeight = radius;\n  let newImage = Image.createFrom(this);\n\n  let size = (kWidth * 2 + 1) * (kHeight * 2 + 1);\n  let kernel = new Array(size);\n\n  for (let channel = 0; channel < channels.length; channel++) {\n    let c = channels[channel];\n    for (let y = kHeight; y < this.height - kHeight; y++) {\n      for (let x = kWidth; x < this.width - kWidth; x++) {\n        let n = 0;\n        for (let j = -kHeight; j <= kHeight; j++) {\n          for (let i = -kWidth; i <= kWidth; i++) {\n            let index = ((y + j) * this.width + x + i) * this.channels + c;\n            kernel[n++] = this.data[index];\n          }\n        }\n\n        let index = (y * this.width + x) * this.channels + c;\n\n        newImage.data[index] = quickSelectMedian(kernel);\n      }\n    }\n  }\n  if (this.alpha && !channels.includes(this.channels)) {\n    for (let i = this.components; i < this.data.length; i = i + this.channels) {\n      newImage.data[i] = this.data[i];\n    }\n  }\n\n  newImage.setBorder({ size: [kWidth, kHeight], algorithm: border });\n\n  return newImage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}