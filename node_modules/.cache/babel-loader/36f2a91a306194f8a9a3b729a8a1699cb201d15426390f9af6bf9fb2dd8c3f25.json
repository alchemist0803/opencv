{"ast":null,"code":"import Qty from 'js-quantities';\nimport deepValue from '../../util/deepValue';\nimport Image from '../Image';\nimport RoiLayer from './RoiLayer';\nimport RoiMap from './RoiMap';\nimport fromMask from './creator/fromMask';\nimport fromMaskConnectedComponentLabelingAlgorithm from './creator/fromMaskConnectedComponentLabelingAlgorithm';\nimport fromMaxima from './creator/fromMaxima';\nimport fromPoints from './creator/fromPoints';\nimport fromWaterShed from './creator/fromWaterShed';\n\n/**\n * A manager of Regions of Interest. A RoiManager is related to a specific Image\n * and may contain multiple layers. Each layer is characterized by a label whose is\n * name by default 'default'\n * @class RoiManager\n * @param {Image} image\n * @param {object} [options]\n */\nexport default class RoiManager {\n  constructor(image, options = {}) {\n    this._image = image;\n    this._options = options;\n    if (!this._options.label) {\n      this._options.label = 'default';\n    }\n    this._layers = {};\n    this._painted = null;\n  }\n\n  // docs is in the corresponding file\n  fromMaxima(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMaxima.call(this._image, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n  }\n\n  // docs is in the corresponding file\n  fromPoints(points, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromPoints.call(this._image, points, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  /**\n   * @param {number[]} map\n   * @param {object} [options]\n   * @return {this}\n   */\n  putMap(map, options = {}) {\n    let roiMap = new RoiMap(this._image, map);\n    let opt = Object.assign({}, this._options, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  // docs is in the corresponding file\n  fromWaterShed(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromWaterShed.call(this._image, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n  }\n\n  // docs is in the corresponding file\n  fromMask(mask, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMask.call(this._image, mask, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n  fromMaskConnectedComponentLabelingAlgorithm(mask, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMaskConnectedComponentLabelingAlgorithm.call(this._image, mask, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  /**\n   *\n   * @param {object} [options]\n   * @return {RoiMap}\n   */\n  getMap(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    this._assertLayerWithLabel(opt.label);\n    return this._layers[opt.label].roiMap;\n  }\n\n  /**\n   * Return statistics about rows\n   * @param {object} [options]\n   * @return {object[]}\n   */\n  rowsInfo(options = {}) {\n    return this.getMap(options).rowsInfo();\n  }\n\n  /**\n   * Return statistics about columns\n   * @param {object} [options]\n   * @return {object[]}\n   */\n  colsInfo(options = {}) {\n    return this.getMap(options).rowsInfo();\n  }\n\n  /**\n   * Return the IDs of the Regions Of Interest (Roi) as an array of number\n   * @param {object} [options]\n   * @return {number[]}\n   */\n  getRoiIds(options = {}) {\n    let rois = this.getRois(options);\n    if (rois) {\n      let ids = new Array(rois.length);\n      for (let i = 0; i < rois.length; i++) {\n        ids[i] = rois[i].id;\n      }\n      return ids;\n    }\n    throw new Error('ROIs not found');\n  }\n\n  /**\n   * Allows to select ROI based on size, label and sign.\n   * @param {object} [options={}]\n   * @param {string} [options.label='default'] Label of the layer containing the ROI\n   * @param {boolean} [options.positive=true] Select the positive region of interest\n   * @param {boolean} [options.negative=true] Select he negative region of interest\n   * @param {number} [options.minSurface=0]\n   * @param {number} [options.maxSurface=Number.POSITIVE_INFINITY]\n   * @param {number} [options.minWidth=0]\n   * @param {number} [options.minHeight=Number.POSITIVE_INFINITY]\n   * @param {number} [options.maxWidth=0]\n   * @param {number} [options.maxHeight=Number.POSITIVE_INFINITY]\n   * @param {number} [options.minRatio=0] Ratio width / height\n   * @param {number} [options.maxRatio=Number.POSITIVE_INFINITY]\n   * @return {Roi[]}\n   */\n  getRois(options = {}) {\n    let {\n      label = this._options.label,\n      positive = true,\n      negative = true,\n      minSurface = 0,\n      maxSurface = Number.POSITIVE_INFINITY,\n      minWidth = 0,\n      maxWidth = Number.POSITIVE_INFINITY,\n      minHeight = 0,\n      maxHeight = Number.POSITIVE_INFINITY,\n      minRatio = 0,\n      maxRatio = Number.POSITIVE_INFINITY\n    } = options;\n    if (!this._layers[label]) {\n      throw new Error(`this Roi layer (${label}) does not exist`);\n    }\n    const allRois = this._layers[label].roi;\n    const rois = [];\n    for (const roi of allRois) {\n      if ((roi.id < 0 && negative || roi.id > 0 && positive) && roi.surface >= minSurface && roi.surface <= maxSurface && roi.width >= minWidth && roi.width <= maxWidth && roi.height >= minHeight && roi.height <= maxHeight && roi.ratio >= minRatio && roi.ratio <= maxRatio) {\n        rois.push(roi);\n      }\n    }\n    return rois;\n  }\n\n  /**\n   * Get an ROI by its id.\n   * @param {number} roiId\n   * @param {object} [options={}]\n   * @param {string} [options.label='default'] Label of the layer containing the ROI\n   * @return {Roi}\n   */\n  getRoi(roiId, options = {}) {\n    const {\n      label = this._options.label\n    } = options;\n    if (!this._layers[label]) {\n      throw new Error(`this Roi layer (${label}) does not exist`);\n    }\n    const roi = this._layers[label].roi.find(roi => roi.id === roiId);\n    if (!roi) {\n      throw new Error(`found no Roi with id ${roiId}`);\n    }\n    return roi;\n  }\n\n  /**\n   * Returns an array of masks\n   * See {@link Roi.getMask} for the options\n   * @param {object} [options]\n   * @return {Image[]} Retuns an array of masks (1 bit Image)\n   */\n  getMasks(options = {}) {\n    let rois = this.getRois(options);\n    let masks = new Array(rois.length);\n    for (let i = 0; i < rois.length; i++) {\n      masks[i] = rois[i].getMask(options);\n    }\n    return masks;\n  }\n\n  /**\n   * Returns an array of masks\n   * See {@link Roi.getAnalysisMasks} for the options\n   * @param {object} [options]\n   * @return {Image[]} Retuns an array of masks (1 bit Image)\n   */\n  getAnalysisMasks(options = {}) {\n    const {\n      analysisProperty\n    } = options;\n    let maskProperty = `${analysisProperty}Mask`;\n    let rois = this.getRois(options);\n    if (rois.length === 0 || !rois[0][maskProperty]) return [];\n    return rois.map(roi => roi[maskProperty]);\n  }\n\n  /**\n   *\n   * @param {object} [options]\n   * @return {number[]}\n   */\n  getData(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    this._assertLayerWithLabel(opt.label);\n    return this._layers[opt.label].roiMap.data;\n  }\n\n  /**\n   * Paint the ROI on a copy of the image and return this image.\n   * For painting options {@link Image.paintMasks}\n   * For ROI selection options, see {@link RoiManager.getMasks}\n   * @param {object} [options] - all the options to select ROIs\n   * @param {string} [options.labelProperty] - Paint a mask property on the image.\n   *                                  May be any property of the ROI like\n   *                                  for example id, surface, width, height, meanX, meanY.\n   * @param {number} [options.pixelSize] Size of a pixel in SI\n   * @param {string} [options.unit=\"pixel\"] Unit in which to display the values\n   * @return {Image} - The painted RGBA 8 bits image\n   */\n  paint(options = {}) {\n    let {\n      labelProperty,\n      analysisProperty\n    } = options;\n    if (!this._painted) {\n      this._painted = this._image.rgba8();\n    }\n    let masks = this.getMasks(options);\n    if (labelProperty) {\n      const rois = this.getRois(options);\n      options.labels = rois.map(roi => deepValue(roi, labelProperty));\n      const max = Math.max(...options.labels);\n      let isSurface = false;\n      let isDistance = false;\n      if (labelProperty.includes('surface')) {\n        isSurface = true;\n      } else if (/(?:perimeter|min|max|external|width|height|length)/.test(labelProperty)) {\n        isDistance = true;\n      }\n      if (isFinite(max)) {\n        let unitLabel = '';\n        if (options.unit !== 'pixel' && options.pixelSize && (isDistance || isSurface)) {\n          unitLabel = isSurface ? `${options.unit}^2` : options.unit;\n          let siLabel = isSurface ? 'm^2' : 'm';\n          let factor = isSurface ? options.pixelSize ** 2 : options.pixelSize;\n          const convert = Qty.swiftConverter(siLabel, unitLabel);\n          options.labels = options.labels.map(value => {\n            return convert(factor * value);\n          });\n        }\n        if (max > 50) {\n          options.labels = options.labels.map(number => Math.round(number) + unitLabel);\n        } else if (max > 10) {\n          options.labels = options.labels.map(number => number.toFixed(1) + unitLabel);\n        } else {\n          options.labels = options.labels.map(number => number.toFixed(2) + unitLabel);\n        }\n      }\n      options.labelsPosition = rois.map(roi => [roi.meanX, roi.meanY]);\n    }\n    this._painted.paintMasks(masks, options);\n    if (analysisProperty) {\n      let analysisMasks = this.getAnalysisMasks(options);\n      this._painted.paintMasks(analysisMasks, {\n        color: options.analysisColor,\n        alpha: options.analysisAlpha\n      });\n    }\n    return this._painted;\n  }\n\n  // return a mask corresponding to all the selected masks\n  getMask(options = {}) {\n    let mask = new Image(this._image.width, this._image.height, {\n      kind: 'BINARY'\n    });\n    let masks = this.getMasks(options);\n    for (let i = 0; i < masks.length; i++) {\n      let roi = masks[i];\n      // we need to find the parent image to calculate the relative position\n\n      for (let x = 0; x < roi.width; x++) {\n        for (let y = 0; y < roi.height; y++) {\n          if (roi.getBitXY(x, y)) {\n            mask.setBitXY(x + roi.position[0], y + roi.position[1]);\n          }\n        }\n      }\n    }\n    return mask;\n  }\n\n  /**\n   * Reset the changes to the current painted iamge to the image that was\n   * used during the creation of the RoiManager except if a new image is\n   * specified as parameter;\n   * @param {object} [options]\n   * @param {Image} [options.image] A new iamge that you would like to sue for painting over\n   */\n  resetPainted(options = {}) {\n    const {\n      image\n    } = options;\n    if (image) {\n      this._painted = this.image.rgba8();\n    } else {\n      this._painted = this._image.rgba8();\n    }\n  }\n\n  /**\n   * In place modification of the roiMap that joins regions of interest\n   * @param {object} [options]\n   * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.\n   *      Current implemented algorithms are 'commonBorderLength' that use the parameters\n   *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses\n   *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.\n   * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging\n   * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging\n   * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging\n   * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging\n   * @return {this}\n   */\n  mergeRoi(options = {}) {\n    const roiMap = this.getMap(options);\n    roiMap.mergeRoi(options);\n    this.putMap(roiMap.data, options);\n    return this;\n  }\n\n  /**\n   * Merge multiple rois into one.\n   * All rois in the provided array will be merged into the first one.\n   * @param {Array<number>} roiIds - A list of Roi ids to merge\n   * @param {object} [options]\n   */\n  mergeRois(roiIds, options = {}) {\n    if (!Array.isArray(roiIds) || roiIds.some(id => !Number.isInteger(id))) {\n      throw new Error('Roi ids must be an array of integers');\n    }\n    if (roiIds.length < 2) {\n      throw new Error('Roi ids must have at least two elements');\n    }\n    if (new Set(roiIds).size !== roiIds.length) {\n      throw new Error('Roi ids must be all different');\n    }\n    // Throws if one of the ids is wrong\n    roiIds.forEach(roiId => this.getRoi(roiId));\n    const roiMap = this.getMap(options);\n    roiMap.mergeRois(roiIds);\n    this.putMap(roiMap.data, options);\n    return this;\n  }\n\n  /**\n   * Finds all corresponding ROIs for all ROIs in the manager\n   * @param {number[]} roiMap\n   * @param {object} [options]\n   * @return {Array} array of objects returned in correspondingRoisInformation\n   */\n  findCorrespondingRoi(roiMap, options = {}) {\n    let allRois = this.getRois(options);\n    let allRelated = [];\n    for (let i = 0; i < allRois.length; i++) {\n      let currentRoi = allRois[i];\n      let x = currentRoi.minX;\n      let y = currentRoi.minY;\n      let allPoints = currentRoi.points;\n      let roiSign = Math.sign(currentRoi.id);\n      let currentRelated = correspondingRoisInformation(x, y, allPoints, roiMap, roiSign);\n      allRelated.push(currentRelated);\n    }\n    return allRelated;\n  }\n  _assertLayerWithLabel(label) {\n    if (!this._layers[label]) {\n      throw new Error(`no layer with label ${label}`);\n    }\n  }\n}\n\n/**\n * For a given ROI, find corresponding ROIs and properties in given ROIMap.\n * Returns an object containing the ID of ROIs, the surface shared by given and corresponding ROIs,\n * the percentage of given ROI surface covered by the corresponding ROI, the number of points with same and opposite signs,\n * the total number of points (same and opposite).\n * @param {number} x - minX value of ROI\n * @param {number} y - minY value of ROI\n * @param {Array<Array<number>>} points - points of ROI\n * @param {Array<number>} roiMap - roiMap from which we get the corresponding ROI\n * @param {number} roiSign - sign of ROI\n * @return {object} {{id: Array, surface: Array, roiSurfaceCovered: Array, same: number, opposite: number, total: number}}\n * @private\n */\nfunction correspondingRoisInformation(x, y, points, roiMap, roiSign) {\n  let correspondingRois = {\n    id: [],\n    surface: [],\n    roiSurfaceCovered: [],\n    same: 0,\n    opposite: 0,\n    total: 0\n  };\n  for (let i = 0; i < points.length; i++) {\n    let currentPoint = points[i];\n    let currentX = currentPoint[0];\n    let currentY = currentPoint[1];\n    let correspondingRoiMapIndex = currentX + x + (currentY + y) * roiMap.width;\n    let value = roiMap.data[correspondingRoiMapIndex];\n    if (value > 0 || value < 0) {\n      if (correspondingRois.id.includes(value)) {\n        correspondingRois.surface[correspondingRois.id.indexOf(value)] += 1;\n      } else {\n        correspondingRois.id.push(value);\n        correspondingRois.surface.push(1);\n      }\n    }\n  }\n  for (let i = 0; i < correspondingRois.id.length; i++) {\n    let currentSign = Math.sign(correspondingRois.id[i]);\n    if (currentSign === roiSign) {\n      correspondingRois.same += correspondingRois.surface[i];\n    } else {\n      correspondingRois.opposite += correspondingRois.surface[i];\n    }\n    correspondingRois.roiSurfaceCovered[i] = correspondingRois.surface[i] / points.length;\n  }\n  correspondingRois.total = correspondingRois.opposite + correspondingRois.same;\n  return correspondingRois;\n}","map":{"version":3,"names":["Qty","deepValue","Image","RoiLayer","RoiMap","fromMask","fromMaskConnectedComponentLabelingAlgorithm","fromMaxima","fromPoints","fromWaterShed","RoiManager","constructor","image","options","_image","_options","label","_layers","_painted","opt","Object","assign","roiMap","call","points","putMap","map","mask","getMap","_assertLayerWithLabel","rowsInfo","colsInfo","getRoiIds","rois","getRois","ids","Array","length","i","id","Error","positive","negative","minSurface","maxSurface","Number","POSITIVE_INFINITY","minWidth","maxWidth","minHeight","maxHeight","minRatio","maxRatio","allRois","roi","surface","width","height","ratio","push","getRoi","roiId","find","getMasks","masks","getMask","getAnalysisMasks","analysisProperty","maskProperty","getData","data","paint","labelProperty","rgba8","labels","max","Math","isSurface","isDistance","includes","test","isFinite","unitLabel","unit","pixelSize","siLabel","factor","convert","swiftConverter","value","number","round","toFixed","labelsPosition","meanX","meanY","paintMasks","analysisMasks","color","analysisColor","alpha","analysisAlpha","kind","x","y","getBitXY","setBitXY","position","resetPainted","mergeRoi","mergeRois","roiIds","isArray","some","isInteger","Set","size","forEach","findCorrespondingRoi","allRelated","currentRoi","minX","minY","allPoints","roiSign","sign","currentRelated","correspondingRoisInformation","correspondingRois","roiSurfaceCovered","same","opposite","total","currentPoint","currentX","currentY","correspondingRoiMapIndex","indexOf","currentSign"],"sources":["C:/Users/Admin/Documents/Workspace/opencv/opencv/node_modules/image-js/src/image/roi/manager.js"],"sourcesContent":["import Qty from 'js-quantities';\n\nimport deepValue from '../../util/deepValue';\nimport Image from '../Image';\n\nimport RoiLayer from './RoiLayer';\nimport RoiMap from './RoiMap';\nimport fromMask from './creator/fromMask';\nimport fromMaskConnectedComponentLabelingAlgorithm from './creator/fromMaskConnectedComponentLabelingAlgorithm';\nimport fromMaxima from './creator/fromMaxima';\nimport fromPoints from './creator/fromPoints';\nimport fromWaterShed from './creator/fromWaterShed';\n\n/**\n * A manager of Regions of Interest. A RoiManager is related to a specific Image\n * and may contain multiple layers. Each layer is characterized by a label whose is\n * name by default 'default'\n * @class RoiManager\n * @param {Image} image\n * @param {object} [options]\n */\nexport default class RoiManager {\n  constructor(image, options = {}) {\n    this._image = image;\n    this._options = options;\n    if (!this._options.label) {\n      this._options.label = 'default';\n    }\n    this._layers = {};\n    this._painted = null;\n  }\n\n  // docs is in the corresponding file\n  fromMaxima(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMaxima.call(this._image, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n  }\n\n  // docs is in the corresponding file\n  fromPoints(points, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromPoints.call(this._image, points, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  /**\n   * @param {number[]} map\n   * @param {object} [options]\n   * @return {this}\n   */\n  putMap(map, options = {}) {\n    let roiMap = new RoiMap(this._image, map);\n    let opt = Object.assign({}, this._options, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  // docs is in the corresponding file\n  fromWaterShed(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromWaterShed.call(this._image, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n  }\n\n  // docs is in the corresponding file\n  fromMask(mask, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMask.call(this._image, mask, options);\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  fromMaskConnectedComponentLabelingAlgorithm(mask, options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    let roiMap = fromMaskConnectedComponentLabelingAlgorithm.call(\n      this._image,\n      mask,\n      options,\n    );\n    this._layers[opt.label] = new RoiLayer(roiMap, opt);\n    return this;\n  }\n\n  /**\n   *\n   * @param {object} [options]\n   * @return {RoiMap}\n   */\n  getMap(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    this._assertLayerWithLabel(opt.label);\n    return this._layers[opt.label].roiMap;\n  }\n\n  /**\n   * Return statistics about rows\n   * @param {object} [options]\n   * @return {object[]}\n   */\n  rowsInfo(options = {}) {\n    return this.getMap(options).rowsInfo();\n  }\n\n  /**\n   * Return statistics about columns\n   * @param {object} [options]\n   * @return {object[]}\n   */\n  colsInfo(options = {}) {\n    return this.getMap(options).rowsInfo();\n  }\n\n  /**\n   * Return the IDs of the Regions Of Interest (Roi) as an array of number\n   * @param {object} [options]\n   * @return {number[]}\n   */\n  getRoiIds(options = {}) {\n    let rois = this.getRois(options);\n    if (rois) {\n      let ids = new Array(rois.length);\n      for (let i = 0; i < rois.length; i++) {\n        ids[i] = rois[i].id;\n      }\n      return ids;\n    }\n    throw new Error('ROIs not found');\n  }\n\n  /**\n   * Allows to select ROI based on size, label and sign.\n   * @param {object} [options={}]\n   * @param {string} [options.label='default'] Label of the layer containing the ROI\n   * @param {boolean} [options.positive=true] Select the positive region of interest\n   * @param {boolean} [options.negative=true] Select he negative region of interest\n   * @param {number} [options.minSurface=0]\n   * @param {number} [options.maxSurface=Number.POSITIVE_INFINITY]\n   * @param {number} [options.minWidth=0]\n   * @param {number} [options.minHeight=Number.POSITIVE_INFINITY]\n   * @param {number} [options.maxWidth=0]\n   * @param {number} [options.maxHeight=Number.POSITIVE_INFINITY]\n   * @param {number} [options.minRatio=0] Ratio width / height\n   * @param {number} [options.maxRatio=Number.POSITIVE_INFINITY]\n   * @return {Roi[]}\n   */\n  getRois(options = {}) {\n    let {\n      label = this._options.label,\n      positive = true,\n      negative = true,\n      minSurface = 0,\n      maxSurface = Number.POSITIVE_INFINITY,\n      minWidth = 0,\n      maxWidth = Number.POSITIVE_INFINITY,\n      minHeight = 0,\n      maxHeight = Number.POSITIVE_INFINITY,\n      minRatio = 0,\n      maxRatio = Number.POSITIVE_INFINITY,\n    } = options;\n\n    if (!this._layers[label]) {\n      throw new Error(`this Roi layer (${label}) does not exist`);\n    }\n\n    const allRois = this._layers[label].roi;\n\n    const rois = [];\n    for (const roi of allRois) {\n      if (\n        ((roi.id < 0 && negative) || (roi.id > 0 && positive)) &&\n        roi.surface >= minSurface &&\n        roi.surface <= maxSurface &&\n        roi.width >= minWidth &&\n        roi.width <= maxWidth &&\n        roi.height >= minHeight &&\n        roi.height <= maxHeight &&\n        roi.ratio >= minRatio &&\n        roi.ratio <= maxRatio\n      ) {\n        rois.push(roi);\n      }\n    }\n    return rois;\n  }\n\n  /**\n   * Get an ROI by its id.\n   * @param {number} roiId\n   * @param {object} [options={}]\n   * @param {string} [options.label='default'] Label of the layer containing the ROI\n   * @return {Roi}\n   */\n  getRoi(roiId, options = {}) {\n    const { label = this._options.label } = options;\n\n    if (!this._layers[label]) {\n      throw new Error(`this Roi layer (${label}) does not exist`);\n    }\n\n    const roi = this._layers[label].roi.find((roi) => roi.id === roiId);\n    if (!roi) {\n      throw new Error(`found no Roi with id ${roiId}`);\n    }\n\n    return roi;\n  }\n\n  /**\n   * Returns an array of masks\n   * See {@link Roi.getMask} for the options\n   * @param {object} [options]\n   * @return {Image[]} Retuns an array of masks (1 bit Image)\n   */\n  getMasks(options = {}) {\n    let rois = this.getRois(options);\n\n    let masks = new Array(rois.length);\n    for (let i = 0; i < rois.length; i++) {\n      masks[i] = rois[i].getMask(options);\n    }\n    return masks;\n  }\n\n  /**\n   * Returns an array of masks\n   * See {@link Roi.getAnalysisMasks} for the options\n   * @param {object} [options]\n   * @return {Image[]} Retuns an array of masks (1 bit Image)\n   */\n  getAnalysisMasks(options = {}) {\n    const { analysisProperty } = options;\n    let maskProperty = `${analysisProperty}Mask`;\n    let rois = this.getRois(options);\n\n    if (rois.length === 0 || !rois[0][maskProperty]) return [];\n    return rois.map((roi) => roi[maskProperty]);\n  }\n\n  /**\n   *\n   * @param {object} [options]\n   * @return {number[]}\n   */\n  getData(options = {}) {\n    let opt = Object.assign({}, this._options, options);\n    this._assertLayerWithLabel(opt.label);\n    return this._layers[opt.label].roiMap.data;\n  }\n\n  /**\n   * Paint the ROI on a copy of the image and return this image.\n   * For painting options {@link Image.paintMasks}\n   * For ROI selection options, see {@link RoiManager.getMasks}\n   * @param {object} [options] - all the options to select ROIs\n   * @param {string} [options.labelProperty] - Paint a mask property on the image.\n   *                                  May be any property of the ROI like\n   *                                  for example id, surface, width, height, meanX, meanY.\n   * @param {number} [options.pixelSize] Size of a pixel in SI\n   * @param {string} [options.unit=\"pixel\"] Unit in which to display the values\n   * @return {Image} - The painted RGBA 8 bits image\n   */\n  paint(options = {}) {\n    let { labelProperty, analysisProperty } = options;\n\n    if (!this._painted) {\n      this._painted = this._image.rgba8();\n    }\n    let masks = this.getMasks(options);\n\n    if (labelProperty) {\n      const rois = this.getRois(options);\n      options.labels = rois.map((roi) => deepValue(roi, labelProperty));\n      const max = Math.max(...options.labels);\n\n      let isSurface = false;\n      let isDistance = false;\n      if (labelProperty.includes('surface')) {\n        isSurface = true;\n      } else if (\n        /(?:perimeter|min|max|external|width|height|length)/.test(labelProperty)\n      ) {\n        isDistance = true;\n      }\n\n      if (isFinite(max)) {\n        let unitLabel = '';\n        if (\n          options.unit !== 'pixel' &&\n          options.pixelSize &&\n          (isDistance || isSurface)\n        ) {\n          unitLabel = isSurface ? `${options.unit}^2` : options.unit;\n          let siLabel = isSurface ? 'm^2' : 'm';\n          let factor = isSurface ? options.pixelSize ** 2 : options.pixelSize;\n          const convert = Qty.swiftConverter(siLabel, unitLabel);\n          options.labels = options.labels.map((value) => {\n            return convert(factor * value);\n          });\n        }\n\n        if (max > 50) {\n          options.labels = options.labels.map(\n            (number) => Math.round(number) + unitLabel,\n          );\n        } else if (max > 10) {\n          options.labels = options.labels.map(\n            (number) => number.toFixed(1) + unitLabel,\n          );\n        } else {\n          options.labels = options.labels.map(\n            (number) => number.toFixed(2) + unitLabel,\n          );\n        }\n      }\n      options.labelsPosition = rois.map((roi) => [roi.meanX, roi.meanY]);\n    }\n\n    this._painted.paintMasks(masks, options);\n\n    if (analysisProperty) {\n      let analysisMasks = this.getAnalysisMasks(options);\n\n      this._painted.paintMasks(analysisMasks, {\n        color: options.analysisColor,\n        alpha: options.analysisAlpha,\n      });\n    }\n\n    return this._painted;\n  }\n\n  // return a mask corresponding to all the selected masks\n  getMask(options = {}) {\n    let mask = new Image(this._image.width, this._image.height, {\n      kind: 'BINARY',\n    });\n    let masks = this.getMasks(options);\n\n    for (let i = 0; i < masks.length; i++) {\n      let roi = masks[i];\n      // we need to find the parent image to calculate the relative position\n\n      for (let x = 0; x < roi.width; x++) {\n        for (let y = 0; y < roi.height; y++) {\n          if (roi.getBitXY(x, y)) {\n            mask.setBitXY(x + roi.position[0], y + roi.position[1]);\n          }\n        }\n      }\n    }\n    return mask;\n  }\n\n  /**\n   * Reset the changes to the current painted iamge to the image that was\n   * used during the creation of the RoiManager except if a new image is\n   * specified as parameter;\n   * @param {object} [options]\n   * @param {Image} [options.image] A new iamge that you would like to sue for painting over\n   */\n  resetPainted(options = {}) {\n    const { image } = options;\n    if (image) {\n      this._painted = this.image.rgba8();\n    } else {\n      this._painted = this._image.rgba8();\n    }\n  }\n\n  /**\n   * In place modification of the roiMap that joins regions of interest\n   * @param {object} [options]\n   * @param {string|function(object,number,number)} [options.algorithm='commonBorderLength'] algorithm used to decide which ROIs are merged.\n   *      Current implemented algorithms are 'commonBorderLength' that use the parameters\n   *      'minCommonBorderLength' and 'maxCommonBorderLength' as well as 'commonBorderRatio' that uses\n   *      the parameters 'minCommonBorderRatio' and 'maxCommonBorderRatio'.\n   * @param {number} [options.minCommonBorderLength=5] minimal common number of pixels for merging\n   * @param {number} [options.maxCommonBorderLength=100] maximal common number of pixels for merging\n   * @param {number} [options.minCommonBorderRatio=0.3] minimal common border ratio for merging\n   * @param {number} [options.maxCommonBorderRatio=1] maximal common border ratio for merging\n   * @return {this}\n   */\n  mergeRoi(options = {}) {\n    const roiMap = this.getMap(options);\n    roiMap.mergeRoi(options);\n    this.putMap(roiMap.data, options);\n    return this;\n  }\n\n  /**\n   * Merge multiple rois into one.\n   * All rois in the provided array will be merged into the first one.\n   * @param {Array<number>} roiIds - A list of Roi ids to merge\n   * @param {object} [options]\n   */\n  mergeRois(roiIds, options = {}) {\n    if (!Array.isArray(roiIds) || roiIds.some((id) => !Number.isInteger(id))) {\n      throw new Error('Roi ids must be an array of integers');\n    }\n    if (roiIds.length < 2) {\n      throw new Error('Roi ids must have at least two elements');\n    }\n    if (new Set(roiIds).size !== roiIds.length) {\n      throw new Error('Roi ids must be all different');\n    }\n    // Throws if one of the ids is wrong\n    roiIds.forEach((roiId) => this.getRoi(roiId));\n\n    const roiMap = this.getMap(options);\n    roiMap.mergeRois(roiIds);\n    this.putMap(roiMap.data, options);\n    return this;\n  }\n\n  /**\n   * Finds all corresponding ROIs for all ROIs in the manager\n   * @param {number[]} roiMap\n   * @param {object} [options]\n   * @return {Array} array of objects returned in correspondingRoisInformation\n   */\n  findCorrespondingRoi(roiMap, options = {}) {\n    let allRois = this.getRois(options);\n    let allRelated = [];\n    for (let i = 0; i < allRois.length; i++) {\n      let currentRoi = allRois[i];\n      let x = currentRoi.minX;\n      let y = currentRoi.minY;\n      let allPoints = currentRoi.points;\n      let roiSign = Math.sign(currentRoi.id);\n      let currentRelated = correspondingRoisInformation(\n        x,\n        y,\n        allPoints,\n        roiMap,\n        roiSign,\n      );\n      allRelated.push(currentRelated);\n    }\n    return allRelated;\n  }\n\n  _assertLayerWithLabel(label) {\n    if (!this._layers[label]) {\n      throw new Error(`no layer with label ${label}`);\n    }\n  }\n}\n\n/**\n * For a given ROI, find corresponding ROIs and properties in given ROIMap.\n * Returns an object containing the ID of ROIs, the surface shared by given and corresponding ROIs,\n * the percentage of given ROI surface covered by the corresponding ROI, the number of points with same and opposite signs,\n * the total number of points (same and opposite).\n * @param {number} x - minX value of ROI\n * @param {number} y - minY value of ROI\n * @param {Array<Array<number>>} points - points of ROI\n * @param {Array<number>} roiMap - roiMap from which we get the corresponding ROI\n * @param {number} roiSign - sign of ROI\n * @return {object} {{id: Array, surface: Array, roiSurfaceCovered: Array, same: number, opposite: number, total: number}}\n * @private\n */\nfunction correspondingRoisInformation(x, y, points, roiMap, roiSign) {\n  let correspondingRois = {\n    id: [],\n    surface: [],\n    roiSurfaceCovered: [],\n    same: 0,\n    opposite: 0,\n    total: 0,\n  };\n  for (let i = 0; i < points.length; i++) {\n    let currentPoint = points[i];\n    let currentX = currentPoint[0];\n    let currentY = currentPoint[1];\n    let correspondingRoiMapIndex = currentX + x + (currentY + y) * roiMap.width;\n    let value = roiMap.data[correspondingRoiMapIndex];\n\n    if (value > 0 || value < 0) {\n      if (correspondingRois.id.includes(value)) {\n        correspondingRois.surface[correspondingRois.id.indexOf(value)] += 1;\n      } else {\n        correspondingRois.id.push(value);\n        correspondingRois.surface.push(1);\n      }\n    }\n  }\n\n  for (let i = 0; i < correspondingRois.id.length; i++) {\n    let currentSign = Math.sign(correspondingRois.id[i]);\n    if (currentSign === roiSign) {\n      correspondingRois.same += correspondingRois.surface[i];\n    } else {\n      correspondingRois.opposite += correspondingRois.surface[i];\n    }\n    correspondingRois.roiSurfaceCovered[i] =\n      correspondingRois.surface[i] / points.length;\n  }\n  correspondingRois.total = correspondingRois.opposite + correspondingRois.same;\n\n  return correspondingRois;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}